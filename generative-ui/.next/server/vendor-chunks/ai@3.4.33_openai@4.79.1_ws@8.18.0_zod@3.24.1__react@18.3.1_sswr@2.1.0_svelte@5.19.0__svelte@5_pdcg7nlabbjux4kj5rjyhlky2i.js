"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/ai@3.4.33_openai@4.79.1_ws@8.18.0_zod@3.24.1__react@18.3.1_sswr@2.1.0_svelte@5.19.0__svelte@5_pdcg7nlabbjux4kj5rjyhlky2i";
exports.ids = ["vendor-chunks/ai@3.4.33_openai@4.79.1_ws@8.18.0_zod@3.24.1__react@18.3.1_sswr@2.1.0_svelte@5.19.0__svelte@5_pdcg7nlabbjux4kj5rjyhlky2i"];
exports.modules = {

/***/ "(ssr)/./node_modules/.pnpm/ai@3.4.33_openai@4.79.1_ws@8.18.0_zod@3.24.1__react@18.3.1_sswr@2.1.0_svelte@5.19.0__svelte@5_pdcg7nlabbjux4kj5rjyhlky2i/node_modules/ai/rsc/dist/rsc-shared.mjs":
/*!*********************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/ai@3.4.33_openai@4.79.1_ws@8.18.0_zod@3.24.1__react@18.3.1_sswr@2.1.0_svelte@5.19.0__svelte@5_pdcg7nlabbjux4kj5rjyhlky2i/node_modules/ai/rsc/dist/rsc-shared.mjs ***!
  \*********************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("var react__WEBPACK_IMPORTED_MODULE_0___namespace_cache;\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   InternalAIProvider: () => (/* binding */ InternalAIProvider),\n/* harmony export */   readStreamableValue: () => (/* binding */ readStreamableValue),\n/* harmony export */   useAIState: () => (/* binding */ useAIState),\n/* harmony export */   useActions: () => (/* binding */ useActions),\n/* harmony export */   useStreamableValue: () => (/* binding */ useStreamableValue),\n/* harmony export */   useSyncUIState: () => (/* binding */ useSyncUIState),\n/* harmony export */   useUIState: () => (/* binding */ useUIState)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/.pnpm/next@14.2.23_@opentelemetry+api@1.9.0_@playwright+test@1.49.1_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var jsondiffpatch__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! jsondiffpatch */ \"(ssr)/./node_modules/.pnpm/jsondiffpatch@0.6.0/node_modules/jsondiffpatch/lib/index.js\");\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react/jsx-runtime */ \"(ssr)/./node_modules/.pnpm/next@14.2.23_@opentelemetry+api@1.9.0_@playwright+test@1.49.1_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react-jsx-runtime.js\");\n/* __next_internal_client_entry_do_not_use__ InternalAIProvider,readStreamableValue,useAIState,useActions,useStreamableValue,useSyncUIState,useUIState auto */ // rsc/streamable-value/streamable-value.ts\nvar STREAMABLE_VALUE_TYPE = Symbol.for(\"ui.streamable.value\");\n// rsc/streamable-value/is-streamable-value.ts\nfunction isStreamableValue(value) {\n    return value != null && typeof value === \"object\" && \"type\" in value && value.type === STREAMABLE_VALUE_TYPE;\n}\n// rsc/streamable-value/read-streamable-value.tsx\nfunction readStreamableValue(streamableValue) {\n    if (!isStreamableValue(streamableValue)) {\n        throw new Error(\"Invalid value: this hook only accepts values created via `createStreamableValue`.\");\n    }\n    return {\n        [Symbol.asyncIterator] () {\n            let row = streamableValue;\n            let value = row.curr;\n            let isDone = false;\n            let isFirstIteration = true;\n            return {\n                async next () {\n                    if (isDone) return {\n                        value,\n                        done: true\n                    };\n                    row = await row;\n                    if (row.error !== void 0) {\n                        throw row.error;\n                    }\n                    if (\"curr\" in row || row.diff) {\n                        if (row.diff) {\n                            if (row.diff[0] === 0) {\n                                if (typeof value !== \"string\") {\n                                    throw new Error(\"Invalid patch: can only append to string types. This is a bug in the AI SDK.\");\n                                }\n                                value = value + row.diff[1];\n                            }\n                        } else {\n                            value = row.curr;\n                        }\n                        if (!row.next) {\n                            isDone = true;\n                            return {\n                                value,\n                                done: false\n                            };\n                        }\n                    }\n                    if (row.next === void 0) {\n                        return {\n                            value,\n                            done: true\n                        };\n                    }\n                    row = row.next;\n                    if (isFirstIteration) {\n                        isFirstIteration = false;\n                        if (value === void 0) {\n                            return this.next();\n                        }\n                    }\n                    return {\n                        value,\n                        done: false\n                    };\n                }\n            };\n        }\n    };\n}\n// rsc/streamable-value/use-streamable-value.tsx\n\nfunction checkStreamableValue(value) {\n    const hasSignature = isStreamableValue(value);\n    if (!hasSignature && value !== void 0) {\n        throw new Error(\"Invalid value: this hook only accepts values created via `createStreamableValue`.\");\n    }\n    return hasSignature;\n}\nfunction useStreamableValue(streamableValue) {\n    const [curr, setCurr] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(checkStreamableValue(streamableValue) ? streamableValue.curr : void 0);\n    const [error, setError] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(checkStreamableValue(streamableValue) ? streamableValue.error : void 0);\n    const [pending, setPending] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(checkStreamableValue(streamableValue) ? !!streamableValue.next : false);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect)(()=>{\n        if (!checkStreamableValue(streamableValue)) return;\n        let cancelled = false;\n        const iterator = readStreamableValue(streamableValue);\n        if (streamableValue.next) {\n            (0,react__WEBPACK_IMPORTED_MODULE_0__.startTransition)(()=>{\n                if (cancelled) return;\n                setPending(true);\n            });\n        }\n        (async ()=>{\n            try {\n                for await (const value of iterator){\n                    if (cancelled) return;\n                    (0,react__WEBPACK_IMPORTED_MODULE_0__.startTransition)(()=>{\n                        if (cancelled) return;\n                        setCurr(value);\n                    });\n                }\n            } catch (e) {\n                if (cancelled) return;\n                (0,react__WEBPACK_IMPORTED_MODULE_0__.startTransition)(()=>{\n                    if (cancelled) return;\n                    setError(e);\n                });\n            } finally{\n                if (cancelled) return;\n                (0,react__WEBPACK_IMPORTED_MODULE_0__.startTransition)(()=>{\n                    if (cancelled) return;\n                    setPending(false);\n                });\n            }\n        })();\n        return ()=>{\n            cancelled = true;\n        };\n    }, [\n        streamableValue\n    ]);\n    return [\n        curr,\n        error,\n        pending\n    ];\n}\n// rsc/shared-client/context.tsx\n\n\n// util/is-function.ts\nvar isFunction = (value)=>typeof value === \"function\";\n// rsc/shared-client/context.tsx\n\nvar InternalUIStateProvider = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createContext(null);\nvar InternalAIStateProvider = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createContext(void 0);\nvar InternalActionProvider = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createContext(null);\nvar InternalSyncUIStateProvider = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createContext(null);\nfunction InternalAIProvider({ children, initialUIState, initialAIState, initialAIStatePatch, wrappedActions, wrappedSyncUIState }) {\n    if (!(\"use\" in /*#__PURE__*/ (react__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (react__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(react__WEBPACK_IMPORTED_MODULE_0__, 2))))) {\n        throw new Error(\"Unsupported React version.\");\n    }\n    const uiState = react__WEBPACK_IMPORTED_MODULE_0__.useState(initialUIState);\n    const setUIState = uiState[1];\n    const resolvedInitialAIStatePatch = initialAIStatePatch ? react__WEBPACK_IMPORTED_MODULE_0__.use(initialAIStatePatch) : void 0;\n    initialAIState = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>{\n        if (resolvedInitialAIStatePatch) {\n            return jsondiffpatch__WEBPACK_IMPORTED_MODULE_2__.patch(jsondiffpatch__WEBPACK_IMPORTED_MODULE_2__.clone(initialAIState), resolvedInitialAIStatePatch);\n        }\n        return initialAIState;\n    }, [\n        initialAIState,\n        resolvedInitialAIStatePatch\n    ]);\n    const aiState = react__WEBPACK_IMPORTED_MODULE_0__.useState(initialAIState);\n    const setAIState = aiState[1];\n    const aiStateRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(aiState[0]);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        aiStateRef.current = aiState[0];\n    }, [\n        aiState[0]\n    ]);\n    const clientWrappedActions = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>Object.fromEntries(Object.entries(wrappedActions).map(([key, action])=>[\n                key,\n                async (...args)=>{\n                    const aiStateSnapshot = aiStateRef.current;\n                    const [aiStateDelta, result] = await action(aiStateSnapshot, ...args);\n                    (async ()=>{\n                        const delta = await aiStateDelta;\n                        if (delta !== void 0) {\n                            aiState[1](jsondiffpatch__WEBPACK_IMPORTED_MODULE_2__.patch(jsondiffpatch__WEBPACK_IMPORTED_MODULE_2__.clone(aiStateSnapshot), delta));\n                        }\n                    })();\n                    return result;\n                }\n            ])), [\n        wrappedActions\n    ]);\n    const clientWrappedSyncUIStateAction = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>{\n        if (!wrappedSyncUIState) {\n            return ()=>{};\n        }\n        return async ()=>{\n            const aiStateSnapshot = aiStateRef.current;\n            const [aiStateDelta, uiState2] = await wrappedSyncUIState(aiStateSnapshot);\n            if (uiState2 !== void 0) {\n                setUIState(uiState2);\n            }\n            const delta = await aiStateDelta;\n            if (delta !== void 0) {\n                const patchedAiState = jsondiffpatch__WEBPACK_IMPORTED_MODULE_2__.patch(jsondiffpatch__WEBPACK_IMPORTED_MODULE_2__.clone(aiStateSnapshot), delta);\n                setAIState(patchedAiState);\n            }\n        };\n    }, [\n        wrappedSyncUIState\n    ]);\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(InternalAIStateProvider.Provider, {\n        value: aiState,\n        children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(InternalUIStateProvider.Provider, {\n            value: uiState,\n            children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(InternalActionProvider.Provider, {\n                value: clientWrappedActions,\n                children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(InternalSyncUIStateProvider.Provider, {\n                    value: clientWrappedSyncUIStateAction,\n                    children\n                })\n            })\n        })\n    });\n}\nfunction useUIState() {\n    const state = react__WEBPACK_IMPORTED_MODULE_0__.useContext(InternalUIStateProvider);\n    if (state === null) {\n        throw new Error(\"`useUIState` must be used inside an <AI> provider.\");\n    }\n    if (!Array.isArray(state)) {\n        throw new Error(\"Invalid state\");\n    }\n    if (state[0] === void 0) {\n        throw new Error(\"`initialUIState` must be provided to `createAI` or `<AI>`\");\n    }\n    return state;\n}\nfunction useAIState(...args) {\n    const state = react__WEBPACK_IMPORTED_MODULE_0__.useContext(InternalAIStateProvider);\n    if (state === null) {\n        throw new Error(\"`useAIState` must be used inside an <AI> provider.\");\n    }\n    if (!Array.isArray(state)) {\n        throw new Error(\"Invalid state\");\n    }\n    if (state[0] === void 0) {\n        throw new Error(\"`initialAIState` must be provided to `createAI` or `<AI>`\");\n    }\n    if (args.length >= 1 && typeof state[0] !== \"object\") {\n        throw new Error(\"When using `useAIState` with a key, the AI state must be an object.\");\n    }\n    const key = args[0];\n    const setter = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(typeof key === \"undefined\" ? state[1] : (newState)=>{\n        if (isFunction(newState)) {\n            return state[1]((s)=>{\n                return {\n                    ...s,\n                    [key]: newState(s[key])\n                };\n            });\n        } else {\n            return state[1]({\n                ...state[0],\n                [key]: newState\n            });\n        }\n    }, [\n        key\n    ]);\n    if (args.length === 0) {\n        return state;\n    } else {\n        return [\n            state[0][args[0]],\n            setter\n        ];\n    }\n}\nfunction useActions() {\n    const actions = react__WEBPACK_IMPORTED_MODULE_0__.useContext(InternalActionProvider);\n    return actions;\n}\nfunction useSyncUIState() {\n    const syncUIState = react__WEBPACK_IMPORTED_MODULE_0__.useContext(InternalSyncUIStateProvider);\n    if (syncUIState === null) {\n        throw new Error(\"`useSyncUIState` must be used inside an <AI> provider.\");\n    }\n    return syncUIState;\n}\n //# sourceMappingURL=rsc-shared.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vYWlAMy40LjMzX29wZW5haUA0Ljc5LjFfd3NAOC4xOC4wX3pvZEAzLjI0LjFfX3JlYWN0QDE4LjMuMV9zc3dyQDIuMS4wX3N2ZWx0ZUA1LjE5LjBfX3N2ZWx0ZUA1X3BkY2c3bmxhYmJqdXg0a2o1cmp5aGxreTJpL25vZGVfbW9kdWxlcy9haS9yc2MvZGlzdC9yc2Mtc2hhcmVkLm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7QUFBTyxJQUFNQSx3QkFBd0JDLE9BQU9DLEdBQUEsQ0FBSTs7QUNFekMsU0FBU0Msa0JBQWtCQyxLQUFBO0lBQ2hDLE9BQ0VBLFNBQVMsUUFDVCxPQUFPQSxVQUFVLFlBQ2pCLFVBQVVBLFNBQ1ZBLE1BQU1DLElBQUEsS0FBU0w7QUFFbkI7O0FDd0JPLFNBQVNNLG9CQUNkQyxlQUFBO0lBRUEsSUFBSSxDQUFDSixrQkFBa0JJLGtCQUFrQjtRQUN2QyxNQUFNLElBQUlDLE1BQ1I7SUFFSjtJQUVBLE9BQU87UUFDTCxDQUFDUCxPQUFPUSxhQUFhO1lBQ25CLElBQUlDLE1BQ0ZIO1lBQ0YsSUFBSUgsUUFBUU0sSUFBSUMsSUFBQTtZQUNoQixJQUFJQyxTQUFTO1lBQ2IsSUFBSUMsbUJBQW1CO1lBRXZCLE9BQU87Z0JBQ0wsTUFBTUM7b0JBRUosSUFBSUYsUUFBUSxPQUFPO3dCQUFFUjt3QkFBT1csTUFBTTtvQkFBSztvQkFHdkNMLE1BQU0sTUFBTUE7b0JBR1osSUFBSUEsSUFBSU0sS0FBQSxLQUFVLFFBQVc7d0JBQzNCLE1BQU1OLElBQUlNLEtBQUE7b0JBQ1o7b0JBR0EsSUFBSSxVQUFVTixPQUFPQSxJQUFJTyxJQUFBLEVBQU07d0JBQzdCLElBQUlQLElBQUlPLElBQUEsRUFBTTs0QkFFWixJQUFJUCxJQUFJTyxJQUFBLENBQUssRUFBQyxLQUFNLEdBQUc7Z0NBQ3JCLElBQUksT0FBT2IsVUFBVSxVQUFVO29DQUM3QixNQUFNLElBQUlJLE1BQ1I7Z0NBRUo7Z0NBR0NKLFFBQW1C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LElBQUlqRixNQUFNO0lBQ2xCO0lBRUEsT0FBT2lGO0FBQ1QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9sYW5nY2hhaW4tbmV4dGpzLXRlbXBsYXRlLy4uL3N0cmVhbWFibGUtdmFsdWUvc3RyZWFtYWJsZS12YWx1ZS50cz9jNWUxIiwid2VicGFjazovL2xhbmdjaGFpbi1uZXh0anMtdGVtcGxhdGUvLi4vc3RyZWFtYWJsZS12YWx1ZS9pcy1zdHJlYW1hYmxlLXZhbHVlLnRzP2ZhYjQiLCJ3ZWJwYWNrOi8vbGFuZ2NoYWluLW5leHRqcy10ZW1wbGF0ZS8uLi9zdHJlYW1hYmxlLXZhbHVlL3JlYWQtc3RyZWFtYWJsZS12YWx1ZS50c3g/MDU2YiIsIndlYnBhY2s6Ly9sYW5nY2hhaW4tbmV4dGpzLXRlbXBsYXRlLy4uL3N0cmVhbWFibGUtdmFsdWUvdXNlLXN0cmVhbWFibGUtdmFsdWUudHN4P2I1NmEiLCJ3ZWJwYWNrOi8vbGFuZ2NoYWluLW5leHRqcy10ZW1wbGF0ZS8uLi9zaGFyZWQtY2xpZW50L2NvbnRleHQudHN4P2NiM2YiLCJ3ZWJwYWNrOi8vbGFuZ2NoYWluLW5leHRqcy10ZW1wbGF0ZS8uLi8uLi91dGlsL2lzLWZ1bmN0aW9uLnRzPzJkNGMiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGNvbnN0IFNUUkVBTUFCTEVfVkFMVUVfVFlQRSA9IFN5bWJvbC5mb3IoJ3VpLnN0cmVhbWFibGUudmFsdWUnKTtcblxuZXhwb3J0IHR5cGUgU3RyZWFtYWJsZVBhdGNoID0gdW5kZWZpbmVkIHwgWzAsIHN0cmluZ107IC8vIEFwcGVuZCBzdHJpbmcuXG5cbmRlY2xhcmUgY29uc3QgX19pbnRlcm5hbF9jdXJyOiB1bmlxdWUgc3ltYm9sO1xuZGVjbGFyZSBjb25zdCBfX2ludGVybmFsX2Vycm9yOiB1bmlxdWUgc3ltYm9sO1xuXG4vKipcbiAqIFN0cmVhbWFibGVWYWx1ZSBpcyBhIHZhbHVlIHRoYXQgY2FuIGJlIHN0cmVhbWVkIG92ZXIgdGhlIG5ldHdvcmsgdmlhIEFJIEFjdGlvbnMuXG4gKiBUbyByZWFkIHRoZSBzdHJlYW1lZCB2YWx1ZXMsIHVzZSB0aGUgYHJlYWRTdHJlYW1hYmxlVmFsdWVgIG9yIGB1c2VTdHJlYW1hYmxlVmFsdWVgIEFQSXMuXG4gKi9cbmV4cG9ydCB0eXBlIFN0cmVhbWFibGVWYWx1ZTxUID0gYW55LCBFID0gYW55PiA9IHtcbiAgLyoqXG4gICAqIEBpbnRlcm5hbCBVc2UgYHJlYWRTdHJlYW1hYmxlVmFsdWVgIHRvIHJlYWQgdGhlIHZhbHVlcy5cbiAgICovXG4gIHR5cGU/OiB0eXBlb2YgU1RSRUFNQUJMRV9WQUxVRV9UWVBFO1xuICAvKipcbiAgICogQGludGVybmFsIFVzZSBgcmVhZFN0cmVhbWFibGVWYWx1ZWAgdG8gcmVhZCB0aGUgdmFsdWVzLlxuICAgKi9cbiAgY3Vycj86IFQ7XG4gIC8qKlxuICAgKiBAaW50ZXJuYWwgVXNlIGByZWFkU3RyZWFtYWJsZVZhbHVlYCB0byByZWFkIHRoZSB2YWx1ZXMuXG4gICAqL1xuICBlcnJvcj86IEU7XG4gIC8qKlxuICAgKiBAaW50ZXJuYWwgVXNlIGByZWFkU3RyZWFtYWJsZVZhbHVlYCB0byByZWFkIHRoZSB2YWx1ZXMuXG4gICAqL1xuICBkaWZmPzogU3RyZWFtYWJsZVBhdGNoO1xuICAvKipcbiAgICogQGludGVybmFsIFVzZSBgcmVhZFN0cmVhbWFibGVWYWx1ZWAgdG8gcmVhZCB0aGUgdmFsdWVzLlxuICAgKi9cbiAgbmV4dD86IFByb21pc2U8U3RyZWFtYWJsZVZhbHVlPFQsIEU+PjtcblxuICAvLyBicmFuZGVkIHR5cGVzIHRvIG1haW50YWluIHR5cGUgc2lnbmF0dXJlIGFmdGVyIGludGVybmFsIHByb3BlcnRpZXMgYXJlIHN0cmlwcGVkLlxuICBbX19pbnRlcm5hbF9jdXJyXT86IFQ7XG4gIFtfX2ludGVybmFsX2Vycm9yXT86IEU7XG59O1xuIiwiaW1wb3J0IHsgU1RSRUFNQUJMRV9WQUxVRV9UWVBFLCBTdHJlYW1hYmxlVmFsdWUgfSBmcm9tICcuL3N0cmVhbWFibGUtdmFsdWUnO1xuXG5leHBvcnQgZnVuY3Rpb24gaXNTdHJlYW1hYmxlVmFsdWUodmFsdWU6IHVua25vd24pOiB2YWx1ZSBpcyBTdHJlYW1hYmxlVmFsdWUge1xuICByZXR1cm4gKFxuICAgIHZhbHVlICE9IG51bGwgJiZcbiAgICB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmXG4gICAgJ3R5cGUnIGluIHZhbHVlICYmXG4gICAgdmFsdWUudHlwZSA9PT0gU1RSRUFNQUJMRV9WQUxVRV9UWVBFXG4gICk7XG59XG4iLCJpbXBvcnQgeyBpc1N0cmVhbWFibGVWYWx1ZSB9IGZyb20gJy4vaXMtc3RyZWFtYWJsZS12YWx1ZSc7XG5pbXBvcnQgeyBTdHJlYW1hYmxlVmFsdWUgfSBmcm9tICcuL3N0cmVhbWFibGUtdmFsdWUnO1xuXG4vKipcbiAqIGByZWFkU3RyZWFtYWJsZVZhbHVlYCB0YWtlcyBhIHN0cmVhbWFibGUgdmFsdWUgY3JlYXRlZCB2aWEgdGhlIGBjcmVhdGVTdHJlYW1hYmxlVmFsdWUoKS52YWx1ZWAgQVBJLFxuICogYW5kIHJldHVybnMgYW4gYXN5bmMgaXRlcmF0b3IuXG4gKlxuICogYGBganNcbiAqIC8vIEluc2lkZSB5b3VyIEFJIGFjdGlvbjpcbiAqXG4gKiBhc3luYyBmdW5jdGlvbiBhY3Rpb24oKSB7XG4gKiAgICd1c2Ugc2VydmVyJ1xuICogICBjb25zdCBzdHJlYW1hYmxlID0gY3JlYXRlU3RyZWFtYWJsZVZhbHVlKCk7XG4gKlxuICogICBzdHJlYW1hYmxlLnVwZGF0ZSgxKTtcbiAqICAgc3RyZWFtYWJsZS51cGRhdGUoMik7XG4gKiAgIHN0cmVhbWFibGUuZG9uZSgzKTtcbiAqICAgLy8gLi4uXG4gKiAgIHJldHVybiBzdHJlYW1hYmxlLnZhbHVlO1xuICogfVxuICogYGBgXG4gKlxuICogQW5kIHRvIHJlYWQgdGhlIHZhbHVlOlxuICpcbiAqIGBgYGpzXG4gKiBjb25zdCBzdHJlYW1hYmxlVmFsdWUgPSBhd2FpdCBhY3Rpb24oKVxuICogZm9yIGF3YWl0IChjb25zdCB2IG9mIHJlYWRTdHJlYW1hYmxlVmFsdWUoc3RyZWFtYWJsZVZhbHVlKSkge1xuICogICBjb25zb2xlLmxvZyh2KVxuICogfVxuICogYGBgXG4gKlxuICogVGhpcyBsb2dzIG91dCAxLCAyLCAzIG9uIGNvbnNvbGUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZWFkU3RyZWFtYWJsZVZhbHVlPFQgPSB1bmtub3duPihcbiAgc3RyZWFtYWJsZVZhbHVlOiBTdHJlYW1hYmxlVmFsdWU8VD4sXG4pOiBBc3luY0l0ZXJhYmxlPFQgfCB1bmRlZmluZWQ+IHtcbiAgaWYgKCFpc1N0cmVhbWFibGVWYWx1ZShzdHJlYW1hYmxlVmFsdWUpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgJ0ludmFsaWQgdmFsdWU6IHRoaXMgaG9vayBvbmx5IGFjY2VwdHMgdmFsdWVzIGNyZWF0ZWQgdmlhIGBjcmVhdGVTdHJlYW1hYmxlVmFsdWVgLicsXG4gICAgKTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSgpIHtcbiAgICAgIGxldCByb3c6IFN0cmVhbWFibGVWYWx1ZTxUPiB8IFByb21pc2U8U3RyZWFtYWJsZVZhbHVlPFQ+PiA9XG4gICAgICAgIHN0cmVhbWFibGVWYWx1ZTtcbiAgICAgIGxldCB2YWx1ZSA9IHJvdy5jdXJyOyAvLyB0aGUgY3VycmVudCB2YWx1ZVxuICAgICAgbGV0IGlzRG9uZSA9IGZhbHNlO1xuICAgICAgbGV0IGlzRmlyc3RJdGVyYXRpb24gPSB0cnVlO1xuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBhc3luYyBuZXh0KCkge1xuICAgICAgICAgIC8vIHRoZSBpdGVyYXRpb24gaXMgZG9uZSBhbHJlYWR5LCByZXR1cm4gdGhlIGxhc3QgdmFsdWU6XG4gICAgICAgICAgaWYgKGlzRG9uZSkgcmV0dXJuIHsgdmFsdWUsIGRvbmU6IHRydWUgfTtcblxuICAgICAgICAgIC8vIHJlc29sdmUgdGhlIHByb21pc2UgYXQgdGhlIGJlZ2lubmluZyBvZiBlYWNoIGl0ZXJhdGlvbjpcbiAgICAgICAgICByb3cgPSBhd2FpdCByb3c7XG5cbiAgICAgICAgICAvLyB0aHJvdyBlcnJvciBpZiBhbnk6XG4gICAgICAgICAgaWYgKHJvdy5lcnJvciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyByb3cuZXJyb3I7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gaWYgdGhlcmUgaXMgYSB2YWx1ZSBvciBhIHBhdGNoLCB1c2UgaXQ6XG4gICAgICAgICAgaWYgKCdjdXJyJyBpbiByb3cgfHwgcm93LmRpZmYpIHtcbiAgICAgICAgICAgIGlmIChyb3cuZGlmZikge1xuICAgICAgICAgICAgICAvLyBzdHJlYW1hYmxlIHBhdGNoICh0ZXh0IG9ubHkpOlxuICAgICAgICAgICAgICBpZiAocm93LmRpZmZbMF0gPT09IDApIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgICAgICAgICAnSW52YWxpZCBwYXRjaDogY2FuIG9ubHkgYXBwZW5kIHRvIHN0cmluZyB0eXBlcy4gVGhpcyBpcyBhIGJ1ZyBpbiB0aGUgQUkgU0RLLicsXG4gICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIGNhc3RpbmcgcmVxdWlyZWQgdG8gcmVtb3ZlIFQgJiBzdHJpbmcgbGltaXRhdGlvblxuICAgICAgICAgICAgICAgICh2YWx1ZSBhcyBzdHJpbmcpID0gdmFsdWUgKyByb3cuZGlmZlsxXTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgLy8gcmVwbGFjZSB0aGUgdmFsdWUgKGZ1bGwgbmV3IHZhbHVlKVxuICAgICAgICAgICAgICB2YWx1ZSA9IHJvdy5jdXJyO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBUaGUgbGFzdCBlbWl0dGVkIHsgZG9uZTogdHJ1ZSB9IHdvbid0IGJlIHVzZWQgYXMgdGhlIHZhbHVlXG4gICAgICAgICAgICAvLyBieSB0aGUgZm9yIGF3YWl0Li4ub2Ygc3ludGF4LlxuICAgICAgICAgICAgaWYgKCFyb3cubmV4dCkge1xuICAgICAgICAgICAgICBpc0RvbmUgPSB0cnVlO1xuICAgICAgICAgICAgICByZXR1cm4geyB2YWx1ZSwgZG9uZTogZmFsc2UgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyB0aGVyZSBhcmUgbm8gZnVydGhlciByb3dzIHRvIGl0ZXJhdGUgb3ZlcjpcbiAgICAgICAgICBpZiAocm93Lm5leHQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWUsIGRvbmU6IHRydWUgfTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByb3cgPSByb3cubmV4dDtcblxuICAgICAgICAgIGlmIChpc0ZpcnN0SXRlcmF0aW9uKSB7XG4gICAgICAgICAgICBpc0ZpcnN0SXRlcmF0aW9uID0gZmFsc2U7IC8vIFRPRE8gc2hvdWxkIHRoaXMgYmUgc2V0IGZvciBldmVyeSByZXR1cm4/XG5cbiAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIC8vIFRoaXMgaXMgdGhlIGluaXRpYWwgY2h1bmsgYW5kIHRoZXJlIGlzbid0IGFuIGluaXRpYWwgdmFsdWUgeWV0LlxuICAgICAgICAgICAgICAvLyBMZXQncyBza2lwIHRoaXMgb25lLlxuICAgICAgICAgICAgICByZXR1cm4gdGhpcy5uZXh0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHsgdmFsdWUsIGRvbmU6IGZhbHNlIH07XG4gICAgICAgIH0sXG4gICAgICB9O1xuICAgIH0sXG4gIH07XG59XG4iLCJpbXBvcnQgeyBzdGFydFRyYW5zaXRpb24sIHVzZUxheW91dEVmZmVjdCwgdXNlU3RhdGUgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyByZWFkU3RyZWFtYWJsZVZhbHVlIH0gZnJvbSAnLi9yZWFkLXN0cmVhbWFibGUtdmFsdWUnO1xuaW1wb3J0IHsgU3RyZWFtYWJsZVZhbHVlIH0gZnJvbSAnLi9zdHJlYW1hYmxlLXZhbHVlJztcbmltcG9ydCB7IGlzU3RyZWFtYWJsZVZhbHVlIH0gZnJvbSAnLi9pcy1zdHJlYW1hYmxlLXZhbHVlJztcblxuZnVuY3Rpb24gY2hlY2tTdHJlYW1hYmxlVmFsdWUodmFsdWU6IHVua25vd24pOiB2YWx1ZSBpcyBTdHJlYW1hYmxlVmFsdWUge1xuICBjb25zdCBoYXNTaWduYXR1cmUgPSBpc1N0cmVhbWFibGVWYWx1ZSh2YWx1ZSk7XG5cbiAgaWYgKCFoYXNTaWduYXR1cmUgJiYgdmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICdJbnZhbGlkIHZhbHVlOiB0aGlzIGhvb2sgb25seSBhY2NlcHRzIHZhbHVlcyBjcmVhdGVkIHZpYSBgY3JlYXRlU3RyZWFtYWJsZVZhbHVlYC4nLFxuICAgICk7XG4gIH1cblxuICByZXR1cm4gaGFzU2lnbmF0dXJlO1xufVxuXG4vKipcbiAqIGB1c2VTdHJlYW1hYmxlVmFsdWVgIGlzIGEgUmVhY3QgaG9vayB0aGF0IHRha2VzIGEgc3RyZWFtYWJsZSB2YWx1ZSBjcmVhdGVkIHZpYSB0aGUgYGNyZWF0ZVN0cmVhbWFibGVWYWx1ZSgpLnZhbHVlYCBBUEksXG4gKiBhbmQgcmV0dXJucyB0aGUgY3VycmVudCB2YWx1ZSwgZXJyb3IsIGFuZCBwZW5kaW5nIHN0YXRlLlxuICpcbiAqIFRoaXMgaXMgdXNlZnVsIGZvciBjb25zdW1pbmcgc3RyZWFtYWJsZSB2YWx1ZXMgcmVjZWl2ZWQgZnJvbSBhIGNvbXBvbmVudCdzIHByb3BzLiBGb3IgZXhhbXBsZTpcbiAqXG4gKiBgYGBqc1xuICogZnVuY3Rpb24gTXlDb21wb25lbnQoeyBzdHJlYW1hYmxlVmFsdWUgfSkge1xuICogICBjb25zdCBbZGF0YSwgZXJyb3IsIHBlbmRpbmddID0gdXNlU3RyZWFtYWJsZVZhbHVlKHN0cmVhbWFibGVWYWx1ZSk7XG4gKlxuICogICBpZiAocGVuZGluZykgcmV0dXJuIDxkaXY+TG9hZGluZy4uLjwvZGl2PjtcbiAqICAgaWYgKGVycm9yKSByZXR1cm4gPGRpdj5FcnJvcjoge2Vycm9yLm1lc3NhZ2V9PC9kaXY+O1xuICpcbiAqICAgcmV0dXJuIDxkaXY+RGF0YToge2RhdGF9PC9kaXY+O1xuICogfVxuICogYGBgXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VTdHJlYW1hYmxlVmFsdWU8VCA9IHVua25vd24sIEVycm9yID0gdW5rbm93bj4oXG4gIHN0cmVhbWFibGVWYWx1ZT86IFN0cmVhbWFibGVWYWx1ZTxUPixcbik6IFtkYXRhOiBUIHwgdW5kZWZpbmVkLCBlcnJvcjogRXJyb3IgfCB1bmRlZmluZWQsIHBlbmRpbmc6IGJvb2xlYW5dIHtcbiAgY29uc3QgW2N1cnIsIHNldEN1cnJdID0gdXNlU3RhdGU8VCB8IHVuZGVmaW5lZD4oXG4gICAgY2hlY2tTdHJlYW1hYmxlVmFsdWUoc3RyZWFtYWJsZVZhbHVlKSA/IHN0cmVhbWFibGVWYWx1ZS5jdXJyIDogdW5kZWZpbmVkLFxuICApO1xuICBjb25zdCBbZXJyb3IsIHNldEVycm9yXSA9IHVzZVN0YXRlPEVycm9yIHwgdW5kZWZpbmVkPihcbiAgICBjaGVja1N0cmVhbWFibGVWYWx1ZShzdHJlYW1hYmxlVmFsdWUpID8gc3RyZWFtYWJsZVZhbHVlLmVycm9yIDogdW5kZWZpbmVkLFxuICApO1xuICBjb25zdCBbcGVuZGluZywgc2V0UGVuZGluZ10gPSB1c2VTdGF0ZTxib29sZWFuPihcbiAgICBjaGVja1N0cmVhbWFibGVWYWx1ZShzdHJlYW1hYmxlVmFsdWUpID8gISFzdHJlYW1hYmxlVmFsdWUubmV4dCA6IGZhbHNlLFxuICApO1xuXG4gIHVzZUxheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKCFjaGVja1N0cmVhbWFibGVWYWx1ZShzdHJlYW1hYmxlVmFsdWUpKSByZXR1cm47XG5cbiAgICBsZXQgY2FuY2VsbGVkID0gZmFsc2U7XG5cbiAgICBjb25zdCBpdGVyYXRvciA9IHJlYWRTdHJlYW1hYmxlVmFsdWUoc3RyZWFtYWJsZVZhbHVlKTtcbiAgICBpZiAoc3RyZWFtYWJsZVZhbHVlLm5leHQpIHtcbiAgICAgIHN0YXJ0VHJhbnNpdGlvbigoKSA9PiB7XG4gICAgICAgIGlmIChjYW5jZWxsZWQpIHJldHVybjtcbiAgICAgICAgc2V0UGVuZGluZyh0cnVlKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIChhc3luYyAoKSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBmb3IgYXdhaXQgKGNvbnN0IHZhbHVlIG9mIGl0ZXJhdG9yKSB7XG4gICAgICAgICAgaWYgKGNhbmNlbGxlZCkgcmV0dXJuO1xuICAgICAgICAgIHN0YXJ0VHJhbnNpdGlvbigoKSA9PiB7XG4gICAgICAgICAgICBpZiAoY2FuY2VsbGVkKSByZXR1cm47XG4gICAgICAgICAgICBzZXRDdXJyKHZhbHVlKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBpZiAoY2FuY2VsbGVkKSByZXR1cm47XG4gICAgICAgIHN0YXJ0VHJhbnNpdGlvbigoKSA9PiB7XG4gICAgICAgICAgaWYgKGNhbmNlbGxlZCkgcmV0dXJuO1xuICAgICAgICAgIHNldEVycm9yKGUgYXMgRXJyb3IpO1xuICAgICAgICB9KTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIGlmIChjYW5jZWxsZWQpIHJldHVybjtcbiAgICAgICAgc3RhcnRUcmFuc2l0aW9uKCgpID0+IHtcbiAgICAgICAgICBpZiAoY2FuY2VsbGVkKSByZXR1cm47XG4gICAgICAgICAgc2V0UGVuZGluZyhmYWxzZSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pKCk7XG5cbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgY2FuY2VsbGVkID0gdHJ1ZTtcbiAgICB9O1xuICB9LCBbc3RyZWFtYWJsZVZhbHVlXSk7XG5cbiAgcmV0dXJuIFtjdXJyLCBlcnJvciwgcGVuZGluZ107XG59XG4iLCIvKiBlc2xpbnQtZGlzYWJsZSByZWFjdC1ob29rcy9leGhhdXN0aXZlLWRlcHMgKi9cbid1c2UgY2xpZW50JztcblxuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xuXG5pbXBvcnQgKiBhcyBqc29uZGlmZnBhdGNoIGZyb20gJ2pzb25kaWZmcGF0Y2gnO1xuaW1wb3J0IHsgaXNGdW5jdGlvbiB9IGZyb20gJy4uLy4uL3V0aWwvaXMtZnVuY3Rpb24nO1xuaW1wb3J0IHR5cGUge1xuICBBSVByb3ZpZGVyLFxuICBJbmZlckFjdGlvbnMsXG4gIEluZmVyQUlTdGF0ZSxcbiAgSW5mZXJVSVN0YXRlLFxuICBJbnRlcm5hbEFJUHJvdmlkZXJQcm9wcyxcbiAgVmFsdWVPclVwZGF0ZXIsXG59IGZyb20gJy4uL3R5cGVzJztcblxuY29uc3QgSW50ZXJuYWxVSVN0YXRlUHJvdmlkZXIgPSBSZWFjdC5jcmVhdGVDb250ZXh0PG51bGwgfCBhbnk+KG51bGwpO1xuY29uc3QgSW50ZXJuYWxBSVN0YXRlUHJvdmlkZXIgPSBSZWFjdC5jcmVhdGVDb250ZXh0PHVuZGVmaW5lZCB8IGFueT4odW5kZWZpbmVkKTtcbmNvbnN0IEludGVybmFsQWN0aW9uUHJvdmlkZXIgPSBSZWFjdC5jcmVhdGVDb250ZXh0PG51bGwgfCBhbnk+KG51bGwpO1xuY29uc3QgSW50ZXJuYWxTeW5jVUlTdGF0ZVByb3ZpZGVyID0gUmVhY3QuY3JlYXRlQ29udGV4dDxudWxsIHwgYW55PihudWxsKTtcblxuZXhwb3J0IGZ1bmN0aW9uIEludGVybmFsQUlQcm92aWRlcih7XG4gIGNoaWxkcmVuLFxuICBpbml0aWFsVUlTdGF0ZSxcbiAgaW5pdGlhbEFJU3RhdGUsXG4gIGluaXRpYWxBSVN0YXRlUGF0Y2gsXG4gIHdyYXBwZWRBY3Rpb25zLFxuICB3cmFwcGVkU3luY1VJU3RhdGUsXG59OiBJbnRlcm5hbEFJUHJvdmlkZXJQcm9wcykge1xuICBpZiAoISgndXNlJyBpbiBSZWFjdCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkIFJlYWN0IHZlcnNpb24uJyk7XG4gIH1cblxuICBjb25zdCB1aVN0YXRlID0gUmVhY3QudXNlU3RhdGUoaW5pdGlhbFVJU3RhdGUpO1xuICBjb25zdCBzZXRVSVN0YXRlID0gdWlTdGF0ZVsxXTtcblxuICBjb25zdCByZXNvbHZlZEluaXRpYWxBSVN0YXRlUGF0Y2ggPSBpbml0aWFsQUlTdGF0ZVBhdGNoXG4gICAgPyAoUmVhY3QgYXMgYW55KS51c2UoaW5pdGlhbEFJU3RhdGVQYXRjaClcbiAgICA6IHVuZGVmaW5lZDtcbiAgaW5pdGlhbEFJU3RhdGUgPSBSZWFjdC51c2VNZW1vKCgpID0+IHtcbiAgICBpZiAocmVzb2x2ZWRJbml0aWFsQUlTdGF0ZVBhdGNoKSB7XG4gICAgICByZXR1cm4ganNvbmRpZmZwYXRjaC5wYXRjaChcbiAgICAgICAganNvbmRpZmZwYXRjaC5jbG9uZShpbml0aWFsQUlTdGF0ZSksXG4gICAgICAgIHJlc29sdmVkSW5pdGlhbEFJU3RhdGVQYXRjaCxcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiBpbml0aWFsQUlTdGF0ZTtcbiAgfSwgW2luaXRpYWxBSVN0YXRlLCByZXNvbHZlZEluaXRpYWxBSVN0YXRlUGF0Y2hdKTtcblxuICBjb25zdCBhaVN0YXRlID0gUmVhY3QudXNlU3RhdGUoaW5pdGlhbEFJU3RhdGUpO1xuICBjb25zdCBzZXRBSVN0YXRlID0gYWlTdGF0ZVsxXTtcbiAgY29uc3QgYWlTdGF0ZVJlZiA9IFJlYWN0LnVzZVJlZihhaVN0YXRlWzBdKTtcblxuICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIGFpU3RhdGVSZWYuY3VycmVudCA9IGFpU3RhdGVbMF07XG4gIH0sIFthaVN0YXRlWzBdXSk7XG5cbiAgY29uc3QgY2xpZW50V3JhcHBlZEFjdGlvbnMgPSBSZWFjdC51c2VNZW1vKFxuICAgICgpID0+XG4gICAgICBPYmplY3QuZnJvbUVudHJpZXMoXG4gICAgICAgIE9iamVjdC5lbnRyaWVzKHdyYXBwZWRBY3Rpb25zKS5tYXAoKFtrZXksIGFjdGlvbl0pID0+IFtcbiAgICAgICAgICBrZXksXG4gICAgICAgICAgYXN5bmMgKC4uLmFyZ3M6IGFueSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgYWlTdGF0ZVNuYXBzaG90ID0gYWlTdGF0ZVJlZi5jdXJyZW50O1xuICAgICAgICAgICAgY29uc3QgW2FpU3RhdGVEZWx0YSwgcmVzdWx0XSA9IGF3YWl0IGFjdGlvbihcbiAgICAgICAgICAgICAgYWlTdGF0ZVNuYXBzaG90LFxuICAgICAgICAgICAgICAuLi5hcmdzLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIChhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgIGNvbnN0IGRlbHRhID0gYXdhaXQgYWlTdGF0ZURlbHRhO1xuICAgICAgICAgICAgICBpZiAoZGVsdGEgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGFpU3RhdGVbMV0oXG4gICAgICAgICAgICAgICAgICBqc29uZGlmZnBhdGNoLnBhdGNoKFxuICAgICAgICAgICAgICAgICAgICBqc29uZGlmZnBhdGNoLmNsb25lKGFpU3RhdGVTbmFwc2hvdCksXG4gICAgICAgICAgICAgICAgICAgIGRlbHRhLFxuICAgICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KSgpO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICB9LFxuICAgICAgICBdKSxcbiAgICAgICksXG4gICAgW3dyYXBwZWRBY3Rpb25zXSxcbiAgKTtcblxuICBjb25zdCBjbGllbnRXcmFwcGVkU3luY1VJU3RhdGVBY3Rpb24gPSBSZWFjdC51c2VNZW1vKCgpID0+IHtcbiAgICBpZiAoIXdyYXBwZWRTeW5jVUlTdGF0ZSkge1xuICAgICAgcmV0dXJuICgpID0+IHt9O1xuICAgIH1cblxuICAgIHJldHVybiBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBhaVN0YXRlU25hcHNob3QgPSBhaVN0YXRlUmVmLmN1cnJlbnQ7XG4gICAgICBjb25zdCBbYWlTdGF0ZURlbHRhLCB1aVN0YXRlXSA9IGF3YWl0IHdyYXBwZWRTeW5jVUlTdGF0ZSEoXG4gICAgICAgIGFpU3RhdGVTbmFwc2hvdCxcbiAgICAgICk7XG5cbiAgICAgIGlmICh1aVN0YXRlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgc2V0VUlTdGF0ZSh1aVN0YXRlKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgZGVsdGEgPSBhd2FpdCBhaVN0YXRlRGVsdGE7XG4gICAgICBpZiAoZGVsdGEgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjb25zdCBwYXRjaGVkQWlTdGF0ZSA9IGpzb25kaWZmcGF0Y2gucGF0Y2goXG4gICAgICAgICAganNvbmRpZmZwYXRjaC5jbG9uZShhaVN0YXRlU25hcHNob3QpLFxuICAgICAgICAgIGRlbHRhLFxuICAgICAgICApO1xuICAgICAgICBzZXRBSVN0YXRlKHBhdGNoZWRBaVN0YXRlKTtcbiAgICAgIH1cbiAgICB9O1xuICB9LCBbd3JhcHBlZFN5bmNVSVN0YXRlXSk7XG5cbiAgcmV0dXJuIChcbiAgICA8SW50ZXJuYWxBSVN0YXRlUHJvdmlkZXIuUHJvdmlkZXIgdmFsdWU9e2FpU3RhdGV9PlxuICAgICAgPEludGVybmFsVUlTdGF0ZVByb3ZpZGVyLlByb3ZpZGVyIHZhbHVlPXt1aVN0YXRlfT5cbiAgICAgICAgPEludGVybmFsQWN0aW9uUHJvdmlkZXIuUHJvdmlkZXIgdmFsdWU9e2NsaWVudFdyYXBwZWRBY3Rpb25zfT5cbiAgICAgICAgICA8SW50ZXJuYWxTeW5jVUlTdGF0ZVByb3ZpZGVyLlByb3ZpZGVyXG4gICAgICAgICAgICB2YWx1ZT17Y2xpZW50V3JhcHBlZFN5bmNVSVN0YXRlQWN0aW9ufVxuICAgICAgICAgID5cbiAgICAgICAgICAgIHtjaGlsZHJlbn1cbiAgICAgICAgICA8L0ludGVybmFsU3luY1VJU3RhdGVQcm92aWRlci5Qcm92aWRlcj5cbiAgICAgICAgPC9JbnRlcm5hbEFjdGlvblByb3ZpZGVyLlByb3ZpZGVyPlxuICAgICAgPC9JbnRlcm5hbFVJU3RhdGVQcm92aWRlci5Qcm92aWRlcj5cbiAgICA8L0ludGVybmFsQUlTdGF0ZVByb3ZpZGVyLlByb3ZpZGVyPlxuICApO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdXNlVUlTdGF0ZTxBSSBleHRlbmRzIEFJUHJvdmlkZXIgPSBhbnk+KCkge1xuICB0eXBlIFQgPSBJbmZlclVJU3RhdGU8QUksIGFueT47XG5cbiAgY29uc3Qgc3RhdGUgPSBSZWFjdC51c2VDb250ZXh0PFxuICAgIFtULCAodjogVCB8ICgodl86IFQpID0+IFQpKSA9PiB2b2lkXSB8IG51bGwgfCB1bmRlZmluZWRcbiAgPihJbnRlcm5hbFVJU3RhdGVQcm92aWRlcik7XG4gIGlmIChzdGF0ZSA9PT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBFcnJvcignYHVzZVVJU3RhdGVgIG11c3QgYmUgdXNlZCBpbnNpZGUgYW4gPEFJPiBwcm92aWRlci4nKTtcbiAgfVxuICBpZiAoIUFycmF5LmlzQXJyYXkoc3RhdGUpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHN0YXRlJyk7XG4gIH1cbiAgaWYgKHN0YXRlWzBdID09PSB1bmRlZmluZWQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAnYGluaXRpYWxVSVN0YXRlYCBtdXN0IGJlIHByb3ZpZGVkIHRvIGBjcmVhdGVBSWAgb3IgYDxBST5gJyxcbiAgICApO1xuICB9XG4gIHJldHVybiBzdGF0ZTtcbn1cblxuLy8gVE9ETzogSG93IGRvIHdlIGF2b2lkIGNhdXNpbmcgYSByZS1yZW5kZXIgd2hlbiB0aGUgQUkgc3RhdGUgY2hhbmdlcyBidXQgeW91XG4vLyBhcmUgb25seSBsaXN0ZW5pbmcgdG8gYSBzcGVjaWZpYyBrZXk/IFdlIG5lZWQgdXNlU0VTIHBlcmhhcHM/XG5mdW5jdGlvbiB1c2VBSVN0YXRlPEFJIGV4dGVuZHMgQUlQcm92aWRlciA9IGFueT4oKTogW1xuICBJbmZlckFJU3RhdGU8QUksIGFueT4sXG4gIChuZXdTdGF0ZTogVmFsdWVPclVwZGF0ZXI8SW5mZXJBSVN0YXRlPEFJLCBhbnk+PikgPT4gdm9pZCxcbl07XG5mdW5jdGlvbiB1c2VBSVN0YXRlPEFJIGV4dGVuZHMgQUlQcm92aWRlciA9IGFueT4oXG4gIGtleToga2V5b2YgSW5mZXJBSVN0YXRlPEFJLCBhbnk+LFxuKTogW1xuICBJbmZlckFJU3RhdGU8QUksIGFueT5bdHlwZW9mIGtleV0sXG4gIChuZXdTdGF0ZTogVmFsdWVPclVwZGF0ZXI8SW5mZXJBSVN0YXRlPEFJLCBhbnk+W3R5cGVvZiBrZXldPikgPT4gdm9pZCxcbl07XG5mdW5jdGlvbiB1c2VBSVN0YXRlPEFJIGV4dGVuZHMgQUlQcm92aWRlciA9IGFueT4oXG4gIC4uLmFyZ3M6IFtdIHwgW2tleW9mIEluZmVyQUlTdGF0ZTxBSSwgYW55Pl1cbikge1xuICB0eXBlIFQgPSBJbmZlckFJU3RhdGU8QUksIGFueT47XG5cbiAgY29uc3Qgc3RhdGUgPSBSZWFjdC51c2VDb250ZXh0PFxuICAgIFtULCAobmV3U3RhdGU6IFZhbHVlT3JVcGRhdGVyPFQ+KSA9PiB2b2lkXSB8IG51bGwgfCB1bmRlZmluZWRcbiAgPihJbnRlcm5hbEFJU3RhdGVQcm92aWRlcik7XG4gIGlmIChzdGF0ZSA9PT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBFcnJvcignYHVzZUFJU3RhdGVgIG11c3QgYmUgdXNlZCBpbnNpZGUgYW4gPEFJPiBwcm92aWRlci4nKTtcbiAgfVxuICBpZiAoIUFycmF5LmlzQXJyYXkoc3RhdGUpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHN0YXRlJyk7XG4gIH1cbiAgaWYgKHN0YXRlWzBdID09PSB1bmRlZmluZWQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAnYGluaXRpYWxBSVN0YXRlYCBtdXN0IGJlIHByb3ZpZGVkIHRvIGBjcmVhdGVBSWAgb3IgYDxBST5gJyxcbiAgICApO1xuICB9XG4gIGlmIChhcmdzLmxlbmd0aCA+PSAxICYmIHR5cGVvZiBzdGF0ZVswXSAhPT0gJ29iamVjdCcpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAnV2hlbiB1c2luZyBgdXNlQUlTdGF0ZWAgd2l0aCBhIGtleSwgdGhlIEFJIHN0YXRlIG11c3QgYmUgYW4gb2JqZWN0LicsXG4gICAgKTtcbiAgfVxuXG4gIGNvbnN0IGtleSA9IGFyZ3NbMF07XG4gIGNvbnN0IHNldHRlciA9IFJlYWN0LnVzZUNhbGxiYWNrKFxuICAgIHR5cGVvZiBrZXkgPT09ICd1bmRlZmluZWQnXG4gICAgICA/IHN0YXRlWzFdXG4gICAgICA6IChuZXdTdGF0ZTogVmFsdWVPclVwZGF0ZXI8VD4pID0+IHtcbiAgICAgICAgICBpZiAoaXNGdW5jdGlvbihuZXdTdGF0ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBzdGF0ZVsxXShzID0+IHtcbiAgICAgICAgICAgICAgcmV0dXJuIHsgLi4ucywgW2tleV06IG5ld1N0YXRlKHNba2V5XSkgfTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gc3RhdGVbMV0oeyAuLi5zdGF0ZVswXSwgW2tleV06IG5ld1N0YXRlIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICBba2V5XSxcbiAgKTtcblxuICBpZiAoYXJncy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gc3RhdGU7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIFtzdGF0ZVswXVthcmdzWzBdXSwgc2V0dGVyXTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gdXNlQWN0aW9uczxBSSBleHRlbmRzIEFJUHJvdmlkZXIgPSBhbnk+KCkge1xuICB0eXBlIFQgPSBJbmZlckFjdGlvbnM8QUksIGFueT47XG5cbiAgY29uc3QgYWN0aW9ucyA9IFJlYWN0LnVzZUNvbnRleHQ8VD4oSW50ZXJuYWxBY3Rpb25Qcm92aWRlcik7XG4gIHJldHVybiBhY3Rpb25zO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdXNlU3luY1VJU3RhdGUoKSB7XG4gIGNvbnN0IHN5bmNVSVN0YXRlID0gUmVhY3QudXNlQ29udGV4dDwoKSA9PiBQcm9taXNlPHZvaWQ+PihcbiAgICBJbnRlcm5hbFN5bmNVSVN0YXRlUHJvdmlkZXIsXG4gICk7XG5cbiAgaWYgKHN5bmNVSVN0YXRlID09PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdgdXNlU3luY1VJU3RhdGVgIG11c3QgYmUgdXNlZCBpbnNpZGUgYW4gPEFJPiBwcm92aWRlci4nKTtcbiAgfVxuXG4gIHJldHVybiBzeW5jVUlTdGF0ZTtcbn1cblxuZXhwb3J0IHsgdXNlQUlTdGF0ZSB9O1xuIiwiLyoqXG4gKiBDaGVja3MgaWYgdGhlIGdpdmVuIHZhbHVlIGlzIGEgZnVuY3Rpb24uXG4gKlxuICogQHBhcmFtIHt1bmtub3dufSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHRoZSB2YWx1ZSBpcyBhIGZ1bmN0aW9uLCBmYWxzZSBvdGhlcndpc2UuXG4gKi9cbmV4cG9ydCBjb25zdCBpc0Z1bmN0aW9uID0gKHZhbHVlOiB1bmtub3duKTogdmFsdWUgaXMgRnVuY3Rpb24gPT5cbiAgdHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nO1xuIl0sIm5hbWVzIjpbIlNUUkVBTUFCTEVfVkFMVUVfVFlQRSIsIlN5bWJvbCIsImZvciIsImlzU3RyZWFtYWJsZVZhbHVlIiwidmFsdWUiLCJ0eXBlIiwicmVhZFN0cmVhbWFibGVWYWx1ZSIsInN0cmVhbWFibGVWYWx1ZSIsIkVycm9yIiwiYXN5bmNJdGVyYXRvciIsInJvdyIsImN1cnIiLCJpc0RvbmUiLCJpc0ZpcnN0SXRlcmF0aW9uIiwibmV4dCIsImRvbmUiLCJlcnJvciIsImRpZmYiLCJzdGFydFRyYW5zaXRpb24iLCJ1c2VMYXlvdXRFZmZlY3QiLCJ1c2VTdGF0ZSIsImNoZWNrU3RyZWFtYWJsZVZhbHVlIiwiaGFzU2lnbmF0dXJlIiwidXNlU3RyZWFtYWJsZVZhbHVlIiwic2V0Q3VyciIsInNldEVycm9yIiwicGVuZGluZyIsInNldFBlbmRpbmciLCJjYW5jZWxsZWQiLCJpdGVyYXRvciIsImUiLCJSZWFjdCIsImpzb25kaWZmcGF0Y2giLCJpc0Z1bmN0aW9uIiwianN4IiwiSW50ZXJuYWxVSVN0YXRlUHJvdmlkZXIiLCJjcmVhdGVDb250ZXh0IiwiSW50ZXJuYWxBSVN0YXRlUHJvdmlkZXIiLCJJbnRlcm5hbEFjdGlvblByb3ZpZGVyIiwiSW50ZXJuYWxTeW5jVUlTdGF0ZVByb3ZpZGVyIiwiSW50ZXJuYWxBSVByb3ZpZGVyIiwiY2hpbGRyZW4iLCJpbml0aWFsVUlTdGF0ZSIsImluaXRpYWxBSVN0YXRlIiwiaW5pdGlhbEFJU3RhdGVQYXRjaCIsIndyYXBwZWRBY3Rpb25zIiwid3JhcHBlZFN5bmNVSVN0YXRlIiwidWlTdGF0ZSIsInNldFVJU3RhdGUiLCJyZXNvbHZlZEluaXRpYWxBSVN0YXRlUGF0Y2giLCJ1c2UiLCJ1c2VNZW1vIiwicGF0Y2giLCJjbG9uZSIsImFpU3RhdGUiLCJzZXRBSVN0YXRlIiwiYWlTdGF0ZVJlZiIsInVzZVJlZiIsInVzZUVmZmVjdCIsImN1cnJlbnQiLCJjbGllbnRXcmFwcGVkQWN0aW9ucyIsIk9iamVjdCIsImZyb21FbnRyaWVzIiwiZW50cmllcyIsIm1hcCIsImtleSIsImFjdGlvbiIsImFyZ3MiLCJhaVN0YXRlU25hcHNob3QiLCJhaVN0YXRlRGVsdGEiLCJyZXN1bHQiLCJkZWx0YSIsImNsaWVudFdyYXBwZWRTeW5jVUlTdGF0ZUFjdGlvbiIsInBhdGNoZWRBaVN0YXRlIiwiUHJvdmlkZXIiLCJ1c2VVSVN0YXRlIiwic3RhdGUiLCJ1c2VDb250ZXh0IiwiQXJyYXkiLCJpc0FycmF5IiwidXNlQUlTdGF0ZSIsImxlbmd0aCIsInNldHRlciIsInVzZUNhbGxiYWNrIiwibmV3U3RhdGUiLCJzIiwidXNlQWN0aW9ucyIsImFjdGlvbnMiLCJ1c2VTeW5jVUlTdGF0ZSIsInN5bmNVSVN0YXRlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/ai@3.4.33_openai@4.79.1_ws@8.18.0_zod@3.24.1__react@18.3.1_sswr@2.1.0_svelte@5.19.0__svelte@5_pdcg7nlabbjux4kj5rjyhlky2i/node_modules/ai/rsc/dist/rsc-shared.mjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/.pnpm/ai@3.4.33_openai@4.79.1_ws@8.18.0_zod@3.24.1__react@18.3.1_sswr@2.1.0_svelte@5.19.0__svelte@5_pdcg7nlabbjux4kj5rjyhlky2i/node_modules/ai/rsc/dist/rsc-server.mjs":
/*!*********************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/ai@3.4.33_openai@4.79.1_ws@8.18.0_zod@3.24.1__react@18.3.1_sswr@2.1.0_svelte@5.19.0__svelte@5_pdcg7nlabbjux4kj5rjyhlky2i/node_modules/ai/rsc/dist/rsc-server.mjs ***!
  \*********************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("var react__WEBPACK_IMPORTED_MODULE_4___namespace_cache;\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   $$ACTION_0: () => (/* binding */ $$ACTION_0),\n/* harmony export */   createAI: () => (/* binding */ createAI),\n/* harmony export */   createStreamableUI: () => (/* binding */ createStreamableUI),\n/* harmony export */   createStreamableValue: () => (/* binding */ createStreamableValue),\n/* harmony export */   getAIState: () => (/* binding */ getAIState),\n/* harmony export */   getMutableAIState: () => (/* binding */ getMutableAIState),\n/* harmony export */   render: () => (/* binding */ render),\n/* harmony export */   streamUI: () => (/* binding */ streamUI)\n/* harmony export */ });\n/* harmony import */ var private_next_rsc_server_reference__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! private-next-rsc-server-reference */ \"(rsc)/./node_modules/.pnpm/next@14.2.23_@opentelemetry+api@1.9.0_@playwright+test@1.49.1_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/next/dist/build/webpack/loaders/next-flight-loader/server-reference.js\");\n/* harmony import */ var private_next_rsc_action_encryption__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! private-next-rsc-action-encryption */ \"(rsc)/./node_modules/.pnpm/next@14.2.23_@opentelemetry+api@1.9.0_@playwright+test@1.49.1_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/next/dist/server/app-render/encryption.js\");\n/* harmony import */ var jsondiffpatch__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! jsondiffpatch */ \"(rsc)/./node_modules/.pnpm/jsondiffpatch@0.6.0/node_modules/jsondiffpatch/lib/index.js\");\n/* harmony import */ var async_hooks__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! async_hooks */ \"async_hooks\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! react */ \"(rsc)/./node_modules/.pnpm/next@14.2.23_@opentelemetry+api@1.9.0_@playwright+test@1.49.1_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/next/dist/server/future/route-modules/app-page/vendored/rsc/react.js\");\n/* harmony import */ var _rsc_shared_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./rsc-shared.mjs */ \"(rsc)/./node_modules/.pnpm/ai@3.4.33_openai@4.79.1_ws@8.18.0_zod@3.24.1__react@18.3.1_sswr@2.1.0_svelte@5.19.0__svelte@5_pdcg7nlabbjux4kj5rjyhlky2i/node_modules/ai/rsc/dist/rsc-shared.mjs\");\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! react/jsx-runtime */ \"(rsc)/./node_modules/.pnpm/next@14.2.23_@opentelemetry+api@1.9.0_@playwright+test@1.49.1_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/next/dist/server/future/route-modules/app-page/vendored/rsc/react-jsx-runtime.js\");\n/* harmony import */ var _ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @ai-sdk/provider-utils */ \"(rsc)/./node_modules/.pnpm/@ai-sdk+provider-utils@1.0.22_zod@3.24.1/node_modules/@ai-sdk/provider-utils/dist/index.mjs\");\n/* harmony import */ var _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @ai-sdk/provider */ \"(rsc)/./node_modules/.pnpm/@ai-sdk+provider@0.0.26/node_modules/@ai-sdk/provider/dist/index.mjs\");\n/* harmony import */ var zod__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! zod */ \"(rsc)/./node_modules/.pnpm/zod@3.24.1/node_modules/zod/lib/index.mjs\");\n/* harmony import */ var _ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @ai-sdk/ui-utils */ \"(rsc)/./node_modules/.pnpm/@ai-sdk+ui-utils@0.0.50_zod@3.24.1/node_modules/@ai-sdk/ui-utils/dist/index.mjs\");\n/* harmony import */ var zod_to_json_schema__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! zod-to-json-schema */ \"(rsc)/./node_modules/.pnpm/zod-to-json-schema@3.24.1_zod@3.24.1/node_modules/zod-to-json-schema/dist/esm/index.js\");\n/* harmony import */ var eventsource_parser__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! eventsource-parser */ \"(rsc)/./node_modules/.pnpm/eventsource-parser@1.1.2/node_modules/eventsource-parser/dist/index.js\");\n// rsc/ai-state.tsx\n/* __next_internal_action_entry_do_not_use__ {\"a18ba366ca7730ba8ad8d959a2dac7d651e62563\":\"$$ACTION_0\"} */ \n\n\n\n// util/create-resolvable-promise.ts\nfunction createResolvablePromise() {\n    let resolve;\n    let reject;\n    const promise = new Promise((res, rej)=>{\n        resolve = res;\n        reject = rej;\n    });\n    return {\n        promise,\n        resolve,\n        reject\n    };\n}\n// util/is-function.ts\nvar isFunction = (value)=>typeof value === \"function\";\n// rsc/ai-state.tsx\nvar asyncAIStateStorage = new async_hooks__WEBPACK_IMPORTED_MODULE_2__.AsyncLocalStorage();\nfunction getAIStateStoreOrThrow(message) {\n    const store = asyncAIStateStorage.getStore();\n    if (!store) {\n        throw new Error(message);\n    }\n    return store;\n}\nfunction withAIState({ state: state1, options }, fn) {\n    return asyncAIStateStorage.run({\n        currentState: JSON.parse(JSON.stringify(state1)),\n        // deep clone object\n        originalState: state1,\n        sealed: false,\n        options\n    }, fn);\n}\nfunction getAIStateDeltaPromise() {\n    const store = getAIStateStoreOrThrow(\"Internal error occurred.\");\n    return store.mutationDeltaPromise;\n}\nfunction sealMutableAIState() {\n    const store = getAIStateStoreOrThrow(\"Internal error occurred.\");\n    store.sealed = true;\n}\nfunction getAIState(...args) {\n    const store = getAIStateStoreOrThrow(\"`getAIState` must be called within an AI Action.\");\n    if (args.length > 0) {\n        const key = args[0];\n        if (typeof store.currentState !== \"object\") {\n            throw new Error(`You can't get the \"${String(key)}\" field from the AI state because it's not an object.`);\n        }\n        return store.currentState[key];\n    }\n    return store.currentState;\n}\nfunction getMutableAIState(...args) {\n    const store = getAIStateStoreOrThrow(\"`getMutableAIState` must be called within an AI Action.\");\n    if (store.sealed) {\n        throw new Error(\"`getMutableAIState` must be called before returning from an AI Action. Please move it to the top level of the Action's function body.\");\n    }\n    if (!store.mutationDeltaPromise) {\n        const { promise, resolve } = createResolvablePromise();\n        store.mutationDeltaPromise = promise;\n        store.mutationDeltaResolve = resolve;\n    }\n    function doUpdate(newState, done) {\n        var _a9, _b;\n        if (args.length > 0) {\n            if (typeof store.currentState !== \"object\") {\n                const key = args[0];\n                throw new Error(`You can't modify the \"${String(key)}\" field of the AI state because it's not an object.`);\n            }\n        }\n        if (isFunction(newState)) {\n            if (args.length > 0) {\n                store.currentState[args[0]] = newState(store.currentState[args[0]]);\n            } else {\n                store.currentState = newState(store.currentState);\n            }\n        } else {\n            if (args.length > 0) {\n                store.currentState[args[0]] = newState;\n            } else {\n                store.currentState = newState;\n            }\n        }\n        (_b = (_a9 = store.options).onSetAIState) == null ? void 0 : _b.call(_a9, {\n            key: args.length > 0 ? args[0] : void 0,\n            state: store.currentState,\n            done\n        });\n    }\n    const mutableState = {\n        get: ()=>{\n            if (args.length > 0) {\n                const key = args[0];\n                if (typeof store.currentState !== \"object\") {\n                    throw new Error(`You can't get the \"${String(key)}\" field from the AI state because it's not an object.`);\n                }\n                return store.currentState[key];\n            }\n            return store.currentState;\n        },\n        update: function update(newAIState) {\n            doUpdate(newAIState, false);\n        },\n        done: function done(...doneArgs) {\n            if (doneArgs.length > 0) {\n                doUpdate(doneArgs[0], true);\n            }\n            const delta = jsondiffpatch__WEBPACK_IMPORTED_MODULE_3__.diff(store.originalState, store.currentState);\n            store.mutationDeltaResolve(delta);\n        }\n    };\n    return mutableState;\n}\n// rsc/provider.tsx\n\n\n\nvar innerAction = (0,private_next_rsc_server_reference__WEBPACK_IMPORTED_MODULE_0__.registerServerReference)(\"a18ba366ca7730ba8ad8d959a2dac7d651e62563\", $$ACTION_0);\nasync function $$ACTION_0({ action, options }, state1, ...args) {\n    return await withAIState({\n        state: state1,\n        options\n    }, async ()=>{\n        const result = await action(...args);\n        sealMutableAIState();\n        return [\n            getAIStateDeltaPromise(),\n            result\n        ];\n    });\n}\nfunction wrapAction(action, options) {\n    return innerAction.bind(null, {\n        action,\n        options\n    });\n}\nfunction createAI({ actions, initialAIState, initialUIState, onSetAIState, onGetUIState }) {\n    const wrappedActions = {};\n    for(const name9 in actions){\n        wrappedActions[name9] = wrapAction(actions[name9], {\n            onSetAIState\n        });\n    }\n    const wrappedSyncUIState = onGetUIState ? wrapAction(onGetUIState, {}) : void 0;\n    const AI = async (props)=>{\n        var _a9, _b;\n        if (\"useState\" in /*#__PURE__*/ (react__WEBPACK_IMPORTED_MODULE_4___namespace_cache || (react__WEBPACK_IMPORTED_MODULE_4___namespace_cache = __webpack_require__.t(react__WEBPACK_IMPORTED_MODULE_4__, 2)))) {\n            throw new Error(\"This component can only be used inside Server Components.\");\n        }\n        let uiState = (_a9 = props.initialUIState) != null ? _a9 : initialUIState;\n        let aiState = (_b = props.initialAIState) != null ? _b : initialAIState;\n        let aiStateDelta = void 0;\n        if (wrappedSyncUIState) {\n            const [newAIStateDelta, newUIState] = await wrappedSyncUIState(aiState);\n            if (newUIState !== void 0) {\n                aiStateDelta = newAIStateDelta;\n                uiState = newUIState;\n            }\n        }\n        return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(_rsc_shared_mjs__WEBPACK_IMPORTED_MODULE_6__.InternalAIProvider, {\n            wrappedActions,\n            wrappedSyncUIState,\n            initialUIState: uiState,\n            initialAIState: aiState,\n            initialAIStatePatch: aiStateDelta,\n            children: props.children\n        });\n    };\n    return AI;\n}\n// rsc/stream-ui/stream-ui.tsx\n\n// util/download-error.ts\n\nvar name = \"AI_DownloadError\";\nvar marker = `vercel.ai.error.${name}`;\nvar symbol = Symbol.for(marker);\nvar _a;\nvar DownloadError = class extends _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_7__.AISDKError {\n    constructor({ url, statusCode, statusText, cause, message = cause == null ? `Failed to download ${url}: ${statusCode} ${statusText}` : `Failed to download ${url}: ${cause}` }){\n        super({\n            name,\n            message,\n            cause\n        });\n        this[_a] = true;\n        this.url = url;\n        this.statusCode = statusCode;\n        this.statusText = statusText;\n    }\n    static isInstance(error) {\n        return _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_7__.AISDKError.hasMarker(error, marker);\n    }\n    /**\n   * @deprecated use `isInstance` instead\n   */ static isDownloadError(error) {\n        return error instanceof Error && error.name === name && typeof error.url === \"string\" && (error.statusCode == null || typeof error.statusCode === \"number\") && (error.statusText == null || typeof error.statusText === \"string\");\n    }\n    /**\n   * @deprecated Do not use this method. It will be removed in the next major version.\n   */ toJSON() {\n        return {\n            name: this.name,\n            message: this.message,\n            url: this.url,\n            statusCode: this.statusCode,\n            statusText: this.statusText,\n            cause: this.cause\n        };\n    }\n};\n_a = symbol;\n// util/download.ts\nasync function download({ url, fetchImplementation = fetch }) {\n    var _a9;\n    const urlText = url.toString();\n    try {\n        const response = await fetchImplementation(urlText);\n        if (!response.ok) {\n            throw new DownloadError({\n                url: urlText,\n                statusCode: response.status,\n                statusText: response.statusText\n            });\n        }\n        return {\n            data: new Uint8Array(await response.arrayBuffer()),\n            mimeType: (_a9 = response.headers.get(\"content-type\")) != null ? _a9 : void 0\n        };\n    } catch (error) {\n        if (DownloadError.isInstance(error)) {\n            throw error;\n        }\n        throw new DownloadError({\n            url: urlText,\n            cause: error\n        });\n    }\n}\n// core/util/detect-image-mimetype.ts\nvar mimeTypeSignatures = [\n    {\n        mimeType: \"image/gif\",\n        bytes: [\n            71,\n            73,\n            70\n        ]\n    },\n    {\n        mimeType: \"image/png\",\n        bytes: [\n            137,\n            80,\n            78,\n            71\n        ]\n    },\n    {\n        mimeType: \"image/jpeg\",\n        bytes: [\n            255,\n            216\n        ]\n    },\n    {\n        mimeType: \"image/webp\",\n        bytes: [\n            82,\n            73,\n            70,\n            70\n        ]\n    }\n];\nfunction detectImageMimeType(image) {\n    for (const { bytes, mimeType } of mimeTypeSignatures){\n        if (image.length >= bytes.length && bytes.every((byte, index)=>image[index] === byte)) {\n            return mimeType;\n        }\n    }\n    return void 0;\n}\n// core/prompt/data-content.ts\n\n// core/prompt/invalid-data-content-error.ts\n\nvar name2 = \"AI_InvalidDataContentError\";\nvar marker2 = `vercel.ai.error.${name2}`;\nvar symbol2 = Symbol.for(marker2);\nvar _a2;\nvar InvalidDataContentError = class extends _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_7__.AISDKError {\n    constructor({ content, cause, message = `Invalid data content. Expected a base64 string, Uint8Array, ArrayBuffer, or Buffer, but got ${typeof content}.` }){\n        super({\n            name: name2,\n            message,\n            cause\n        });\n        this[_a2] = true;\n        this.content = content;\n    }\n    static isInstance(error) {\n        return _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_7__.AISDKError.hasMarker(error, marker2);\n    }\n    /**\n   * @deprecated use `isInstance` instead\n   */ static isInvalidDataContentError(error) {\n        return error instanceof Error && error.name === name2 && error.content != null;\n    }\n    /**\n   * @deprecated Do not use this method. It will be removed in the next major version.\n   */ toJSON() {\n        return {\n            name: this.name,\n            message: this.message,\n            stack: this.stack,\n            cause: this.cause,\n            content: this.content\n        };\n    }\n};\n_a2 = symbol2;\n// core/prompt/data-content.ts\n\nvar dataContentSchema = zod__WEBPACK_IMPORTED_MODULE_8__.z.union([\n    zod__WEBPACK_IMPORTED_MODULE_8__.z.string(),\n    zod__WEBPACK_IMPORTED_MODULE_8__.z.instanceof(Uint8Array),\n    zod__WEBPACK_IMPORTED_MODULE_8__.z.instanceof(ArrayBuffer),\n    zod__WEBPACK_IMPORTED_MODULE_8__.z.custom(// Buffer might not be available in some environments such as CloudFlare:\n    (value)=>{\n        var _a9, _b;\n        return (_b = (_a9 = globalThis.Buffer) == null ? void 0 : _a9.isBuffer(value)) != null ? _b : false;\n    }, {\n        message: \"Must be a Buffer\"\n    })\n]);\nfunction convertDataContentToBase64String(content) {\n    if (typeof content === \"string\") {\n        return content;\n    }\n    if (content instanceof ArrayBuffer) {\n        return (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_9__.convertUint8ArrayToBase64)(new Uint8Array(content));\n    }\n    return (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_9__.convertUint8ArrayToBase64)(content);\n}\nfunction convertDataContentToUint8Array(content) {\n    if (content instanceof Uint8Array) {\n        return content;\n    }\n    if (typeof content === \"string\") {\n        try {\n            return (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_9__.convertBase64ToUint8Array)(content);\n        } catch (error) {\n            throw new InvalidDataContentError({\n                message: \"Invalid data content. Content string is not a base64-encoded media.\",\n                content,\n                cause: error\n            });\n        }\n    }\n    if (content instanceof ArrayBuffer) {\n        return new Uint8Array(content);\n    }\n    throw new InvalidDataContentError({\n        content\n    });\n}\nfunction convertUint8ArrayToText(uint8Array) {\n    try {\n        return new TextDecoder().decode(uint8Array);\n    } catch (error) {\n        throw new Error(\"Error decoding Uint8Array to text\");\n    }\n}\n// core/prompt/invalid-message-role-error.ts\n\nvar name3 = \"AI_InvalidMessageRoleError\";\nvar marker3 = `vercel.ai.error.${name3}`;\nvar symbol3 = Symbol.for(marker3);\nvar _a3;\nvar InvalidMessageRoleError = class extends _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_7__.AISDKError {\n    constructor({ role, message = `Invalid message role: '${role}'. Must be one of: \"system\", \"user\", \"assistant\", \"tool\".` }){\n        super({\n            name: name3,\n            message\n        });\n        this[_a3] = true;\n        this.role = role;\n    }\n    static isInstance(error) {\n        return _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_7__.AISDKError.hasMarker(error, marker3);\n    }\n    /**\n   * @deprecated use `isInstance` instead\n   */ static isInvalidMessageRoleError(error) {\n        return error instanceof Error && error.name === name3 && typeof error.role === \"string\";\n    }\n    /**\n   * @deprecated Do not use this method. It will be removed in the next major version.\n   */ toJSON() {\n        return {\n            name: this.name,\n            message: this.message,\n            stack: this.stack,\n            role: this.role\n        };\n    }\n};\n_a3 = symbol3;\n// core/prompt/split-data-url.ts\nfunction splitDataUrl(dataUrl) {\n    try {\n        const [header, base64Content] = dataUrl.split(\",\");\n        return {\n            mimeType: header.split(\";\")[0].split(\":\")[1],\n            base64Content\n        };\n    } catch (error) {\n        return {\n            mimeType: void 0,\n            base64Content: void 0\n        };\n    }\n}\n// core/prompt/convert-to-language-model-prompt.ts\nasync function convertToLanguageModelPrompt({ prompt, modelSupportsImageUrls = true, modelSupportsUrl = ()=>false, downloadImplementation = download }) {\n    const downloadedAssets = await downloadAssets(prompt.messages, downloadImplementation, modelSupportsImageUrls, modelSupportsUrl);\n    return [\n        ...prompt.system != null ? [\n            {\n                role: \"system\",\n                content: prompt.system\n            }\n        ] : [],\n        ...prompt.messages.map((message)=>convertToLanguageModelMessage(message, downloadedAssets))\n    ];\n}\nfunction convertToLanguageModelMessage(message, downloadedAssets) {\n    const role = message.role;\n    switch(role){\n        case \"system\":\n            {\n                return {\n                    role: \"system\",\n                    content: message.content,\n                    providerMetadata: message.experimental_providerMetadata\n                };\n            }\n        case \"user\":\n            {\n                if (typeof message.content === \"string\") {\n                    return {\n                        role: \"user\",\n                        content: [\n                            {\n                                type: \"text\",\n                                text: message.content\n                            }\n                        ],\n                        providerMetadata: message.experimental_providerMetadata\n                    };\n                }\n                return {\n                    role: \"user\",\n                    content: message.content.map((part)=>convertPartToLanguageModelPart(part, downloadedAssets)).filter((part)=>part.type !== \"text\" || part.text !== \"\"),\n                    providerMetadata: message.experimental_providerMetadata\n                };\n            }\n        case \"assistant\":\n            {\n                if (typeof message.content === \"string\") {\n                    return {\n                        role: \"assistant\",\n                        content: [\n                            {\n                                type: \"text\",\n                                text: message.content\n                            }\n                        ],\n                        providerMetadata: message.experimental_providerMetadata\n                    };\n                }\n                return {\n                    role: \"assistant\",\n                    content: message.content.filter(// remove empty text parts:\n                    (part)=>part.type !== \"text\" || part.text !== \"\").map((part)=>{\n                        const { experimental_providerMetadata, ...rest } = part;\n                        return {\n                            ...rest,\n                            providerMetadata: experimental_providerMetadata\n                        };\n                    }),\n                    providerMetadata: message.experimental_providerMetadata\n                };\n            }\n        case \"tool\":\n            {\n                return {\n                    role: \"tool\",\n                    content: message.content.map((part)=>({\n                            type: \"tool-result\",\n                            toolCallId: part.toolCallId,\n                            toolName: part.toolName,\n                            result: part.result,\n                            content: part.experimental_content,\n                            isError: part.isError,\n                            providerMetadata: part.experimental_providerMetadata\n                        })),\n                    providerMetadata: message.experimental_providerMetadata\n                };\n            }\n        default:\n            {\n                const _exhaustiveCheck = role;\n                throw new InvalidMessageRoleError({\n                    role: _exhaustiveCheck\n                });\n            }\n    }\n}\nasync function downloadAssets(messages, downloadImplementation, modelSupportsImageUrls, modelSupportsUrl) {\n    const urls = messages.filter((message)=>message.role === \"user\").map((message)=>message.content).filter((content)=>Array.isArray(content)).flat().filter((part)=>part.type === \"image\" || part.type === \"file\").filter((part)=>!(part.type === \"image\" && modelSupportsImageUrls === true)).map((part)=>part.type === \"image\" ? part.image : part.data).map((part)=>// support string urls:\n        typeof part === \"string\" && (part.startsWith(\"http:\") || part.startsWith(\"https:\")) ? new URL(part) : part).filter((image)=>image instanceof URL).filter((url)=>!modelSupportsUrl(url));\n    const downloadedImages = await Promise.all(urls.map(async (url)=>({\n            url,\n            data: await downloadImplementation({\n                url\n            })\n        })));\n    return Object.fromEntries(downloadedImages.map(({ url, data })=>[\n            url.toString(),\n            data\n        ]));\n}\nfunction convertPartToLanguageModelPart(part, downloadedAssets) {\n    if (part.type === \"text\") {\n        return {\n            type: \"text\",\n            text: part.text,\n            providerMetadata: part.experimental_providerMetadata\n        };\n    }\n    let mimeType = part.mimeType;\n    let data;\n    let content;\n    let normalizedData;\n    const type = part.type;\n    switch(type){\n        case \"image\":\n            data = part.image;\n            break;\n        case \"file\":\n            data = part.data;\n            break;\n        default:\n            throw new Error(`Unsupported part type: ${type}`);\n    }\n    try {\n        content = typeof data === \"string\" ? new URL(data) : data;\n    } catch (error) {\n        content = data;\n    }\n    if (content instanceof URL) {\n        if (content.protocol === \"data:\") {\n            const { mimeType: dataUrlMimeType, base64Content } = splitDataUrl(content.toString());\n            if (dataUrlMimeType == null || base64Content == null) {\n                throw new Error(`Invalid data URL format in part ${type}`);\n            }\n            mimeType = dataUrlMimeType;\n            normalizedData = convertDataContentToUint8Array(base64Content);\n        } else {\n            const downloadedFile = downloadedAssets[content.toString()];\n            if (downloadedFile) {\n                normalizedData = downloadedFile.data;\n                mimeType != null ? mimeType : mimeType = downloadedFile.mimeType;\n            } else {\n                normalizedData = content;\n            }\n        }\n    } else {\n        normalizedData = convertDataContentToUint8Array(content);\n    }\n    switch(type){\n        case \"image\":\n            if (mimeType == null && normalizedData instanceof Uint8Array) {\n                mimeType = detectImageMimeType(normalizedData);\n            }\n            return {\n                type: \"image\",\n                image: normalizedData,\n                mimeType,\n                providerMetadata: part.experimental_providerMetadata\n            };\n        case \"file\":\n            if (mimeType == null) {\n                throw new Error(`Mime type is missing for file part`);\n            }\n            return {\n                type: \"file\",\n                data: normalizedData instanceof Uint8Array ? convertDataContentToBase64String(normalizedData) : normalizedData,\n                mimeType,\n                providerMetadata: part.experimental_providerMetadata\n            };\n    }\n}\n// errors/invalid-argument-error.ts\n\nvar name4 = \"AI_InvalidArgumentError\";\nvar marker4 = `vercel.ai.error.${name4}`;\nvar symbol4 = Symbol.for(marker4);\nvar _a4;\nvar InvalidArgumentError = class extends _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_7__.AISDKError {\n    constructor({ parameter, value, message }){\n        super({\n            name: name4,\n            message: `Invalid argument for parameter ${parameter}: ${message}`\n        });\n        this[_a4] = true;\n        this.parameter = parameter;\n        this.value = value;\n    }\n    static isInstance(error) {\n        return _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_7__.AISDKError.hasMarker(error, marker4);\n    }\n    /**\n   * @deprecated use `isInstance` instead\n   */ static isInvalidArgumentError(error) {\n        return error instanceof Error && error.name === name4 && typeof error.parameter === \"string\" && typeof error.value === \"string\";\n    }\n    toJSON() {\n        return {\n            name: this.name,\n            message: this.message,\n            stack: this.stack,\n            parameter: this.parameter,\n            value: this.value\n        };\n    }\n};\n_a4 = symbol4;\n// core/prompt/prepare-call-settings.ts\nfunction prepareCallSettings({ maxTokens, temperature, topP, topK, presencePenalty, frequencyPenalty, stopSequences, seed, maxRetries }) {\n    if (maxTokens != null) {\n        if (!Number.isInteger(maxTokens)) {\n            throw new InvalidArgumentError({\n                parameter: \"maxTokens\",\n                value: maxTokens,\n                message: \"maxTokens must be an integer\"\n            });\n        }\n        if (maxTokens < 1) {\n            throw new InvalidArgumentError({\n                parameter: \"maxTokens\",\n                value: maxTokens,\n                message: \"maxTokens must be >= 1\"\n            });\n        }\n    }\n    if (temperature != null) {\n        if (typeof temperature !== \"number\") {\n            throw new InvalidArgumentError({\n                parameter: \"temperature\",\n                value: temperature,\n                message: \"temperature must be a number\"\n            });\n        }\n    }\n    if (topP != null) {\n        if (typeof topP !== \"number\") {\n            throw new InvalidArgumentError({\n                parameter: \"topP\",\n                value: topP,\n                message: \"topP must be a number\"\n            });\n        }\n    }\n    if (topK != null) {\n        if (typeof topK !== \"number\") {\n            throw new InvalidArgumentError({\n                parameter: \"topK\",\n                value: topK,\n                message: \"topK must be a number\"\n            });\n        }\n    }\n    if (presencePenalty != null) {\n        if (typeof presencePenalty !== \"number\") {\n            throw new InvalidArgumentError({\n                parameter: \"presencePenalty\",\n                value: presencePenalty,\n                message: \"presencePenalty must be a number\"\n            });\n        }\n    }\n    if (frequencyPenalty != null) {\n        if (typeof frequencyPenalty !== \"number\") {\n            throw new InvalidArgumentError({\n                parameter: \"frequencyPenalty\",\n                value: frequencyPenalty,\n                message: \"frequencyPenalty must be a number\"\n            });\n        }\n    }\n    if (seed != null) {\n        if (!Number.isInteger(seed)) {\n            throw new InvalidArgumentError({\n                parameter: \"seed\",\n                value: seed,\n                message: \"seed must be an integer\"\n            });\n        }\n    }\n    if (maxRetries != null) {\n        if (!Number.isInteger(maxRetries)) {\n            throw new InvalidArgumentError({\n                parameter: \"maxRetries\",\n                value: maxRetries,\n                message: \"maxRetries must be an integer\"\n            });\n        }\n        if (maxRetries < 0) {\n            throw new InvalidArgumentError({\n                parameter: \"maxRetries\",\n                value: maxRetries,\n                message: \"maxRetries must be >= 0\"\n            });\n        }\n    }\n    return {\n        maxTokens,\n        temperature: temperature != null ? temperature : 0,\n        topP,\n        topK,\n        presencePenalty,\n        frequencyPenalty,\n        stopSequences: stopSequences != null && stopSequences.length > 0 ? stopSequences : void 0,\n        seed,\n        maxRetries: maxRetries != null ? maxRetries : 2\n    };\n}\n// core/prompt/prepare-tools-and-tool-choice.ts\n\n// core/util/is-non-empty-object.ts\nfunction isNonEmptyObject(object) {\n    return object != null && Object.keys(object).length > 0;\n}\n// core/prompt/prepare-tools-and-tool-choice.ts\nfunction prepareToolsAndToolChoice({ tools, toolChoice, activeTools }) {\n    if (!isNonEmptyObject(tools)) {\n        return {\n            tools: void 0,\n            toolChoice: void 0\n        };\n    }\n    const filteredTools = activeTools != null ? Object.entries(tools).filter(([name9])=>activeTools.includes(name9)) : Object.entries(tools);\n    return {\n        tools: filteredTools.map(([name9, tool])=>{\n            const toolType = tool.type;\n            switch(toolType){\n                case void 0:\n                case \"function\":\n                    return {\n                        type: \"function\",\n                        name: name9,\n                        description: tool.description,\n                        parameters: (0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_10__.asSchema)(tool.parameters).jsonSchema\n                    };\n                case \"provider-defined\":\n                    return {\n                        type: \"provider-defined\",\n                        name: name9,\n                        id: tool.id,\n                        args: tool.args\n                    };\n                default:\n                    {\n                        const exhaustiveCheck = toolType;\n                        throw new Error(`Unsupported tool type: ${exhaustiveCheck}`);\n                    }\n            }\n        }),\n        toolChoice: toolChoice == null ? {\n            type: \"auto\"\n        } : typeof toolChoice === \"string\" ? {\n            type: toolChoice\n        } : {\n            type: \"tool\",\n            toolName: toolChoice.toolName\n        }\n    };\n}\n// core/prompt/standardize-prompt.ts\n\n\n\n// core/prompt/message.ts\n\n// core/types/provider-metadata.ts\n\n// core/types/json-value.ts\n\nvar jsonValueSchema = zod__WEBPACK_IMPORTED_MODULE_8__.z.lazy(()=>zod__WEBPACK_IMPORTED_MODULE_8__.z.union([\n        zod__WEBPACK_IMPORTED_MODULE_8__.z.null(),\n        zod__WEBPACK_IMPORTED_MODULE_8__.z.string(),\n        zod__WEBPACK_IMPORTED_MODULE_8__.z.number(),\n        zod__WEBPACK_IMPORTED_MODULE_8__.z.boolean(),\n        zod__WEBPACK_IMPORTED_MODULE_8__.z.record(zod__WEBPACK_IMPORTED_MODULE_8__.z.string(), jsonValueSchema),\n        zod__WEBPACK_IMPORTED_MODULE_8__.z.array(jsonValueSchema)\n    ]));\n// core/types/provider-metadata.ts\nvar providerMetadataSchema = zod__WEBPACK_IMPORTED_MODULE_8__.z.record(zod__WEBPACK_IMPORTED_MODULE_8__.z.string(), zod__WEBPACK_IMPORTED_MODULE_8__.z.record(zod__WEBPACK_IMPORTED_MODULE_8__.z.string(), jsonValueSchema));\n// core/prompt/content-part.ts\n\n// core/prompt/tool-result-content.ts\n\nvar toolResultContentSchema = zod__WEBPACK_IMPORTED_MODULE_8__.z.array(zod__WEBPACK_IMPORTED_MODULE_8__.z.union([\n    zod__WEBPACK_IMPORTED_MODULE_8__.z.object({\n        type: zod__WEBPACK_IMPORTED_MODULE_8__.z.literal(\"text\"),\n        text: zod__WEBPACK_IMPORTED_MODULE_8__.z.string()\n    }),\n    zod__WEBPACK_IMPORTED_MODULE_8__.z.object({\n        type: zod__WEBPACK_IMPORTED_MODULE_8__.z.literal(\"image\"),\n        data: zod__WEBPACK_IMPORTED_MODULE_8__.z.string(),\n        mimeType: zod__WEBPACK_IMPORTED_MODULE_8__.z.string().optional()\n    })\n]));\n// core/prompt/content-part.ts\nvar textPartSchema = zod__WEBPACK_IMPORTED_MODULE_8__.z.object({\n    type: zod__WEBPACK_IMPORTED_MODULE_8__.z.literal(\"text\"),\n    text: zod__WEBPACK_IMPORTED_MODULE_8__.z.string(),\n    experimental_providerMetadata: providerMetadataSchema.optional()\n});\nvar imagePartSchema = zod__WEBPACK_IMPORTED_MODULE_8__.z.object({\n    type: zod__WEBPACK_IMPORTED_MODULE_8__.z.literal(\"image\"),\n    image: zod__WEBPACK_IMPORTED_MODULE_8__.z.union([\n        dataContentSchema,\n        zod__WEBPACK_IMPORTED_MODULE_8__.z.instanceof(URL)\n    ]),\n    mimeType: zod__WEBPACK_IMPORTED_MODULE_8__.z.string().optional(),\n    experimental_providerMetadata: providerMetadataSchema.optional()\n});\nvar filePartSchema = zod__WEBPACK_IMPORTED_MODULE_8__.z.object({\n    type: zod__WEBPACK_IMPORTED_MODULE_8__.z.literal(\"file\"),\n    data: zod__WEBPACK_IMPORTED_MODULE_8__.z.union([\n        dataContentSchema,\n        zod__WEBPACK_IMPORTED_MODULE_8__.z.instanceof(URL)\n    ]),\n    mimeType: zod__WEBPACK_IMPORTED_MODULE_8__.z.string(),\n    experimental_providerMetadata: providerMetadataSchema.optional()\n});\nvar toolCallPartSchema = zod__WEBPACK_IMPORTED_MODULE_8__.z.object({\n    type: zod__WEBPACK_IMPORTED_MODULE_8__.z.literal(\"tool-call\"),\n    toolCallId: zod__WEBPACK_IMPORTED_MODULE_8__.z.string(),\n    toolName: zod__WEBPACK_IMPORTED_MODULE_8__.z.string(),\n    args: zod__WEBPACK_IMPORTED_MODULE_8__.z.unknown()\n});\nvar toolResultPartSchema = zod__WEBPACK_IMPORTED_MODULE_8__.z.object({\n    type: zod__WEBPACK_IMPORTED_MODULE_8__.z.literal(\"tool-result\"),\n    toolCallId: zod__WEBPACK_IMPORTED_MODULE_8__.z.string(),\n    toolName: zod__WEBPACK_IMPORTED_MODULE_8__.z.string(),\n    result: zod__WEBPACK_IMPORTED_MODULE_8__.z.unknown(),\n    content: toolResultContentSchema.optional(),\n    isError: zod__WEBPACK_IMPORTED_MODULE_8__.z.boolean().optional(),\n    experimental_providerMetadata: providerMetadataSchema.optional()\n});\n// core/prompt/message.ts\nvar coreSystemMessageSchema = zod__WEBPACK_IMPORTED_MODULE_8__.z.object({\n    role: zod__WEBPACK_IMPORTED_MODULE_8__.z.literal(\"system\"),\n    content: zod__WEBPACK_IMPORTED_MODULE_8__.z.string(),\n    experimental_providerMetadata: providerMetadataSchema.optional()\n});\nvar coreUserMessageSchema = zod__WEBPACK_IMPORTED_MODULE_8__.z.object({\n    role: zod__WEBPACK_IMPORTED_MODULE_8__.z.literal(\"user\"),\n    content: zod__WEBPACK_IMPORTED_MODULE_8__.z.union([\n        zod__WEBPACK_IMPORTED_MODULE_8__.z.string(),\n        zod__WEBPACK_IMPORTED_MODULE_8__.z.array(zod__WEBPACK_IMPORTED_MODULE_8__.z.union([\n            textPartSchema,\n            imagePartSchema,\n            filePartSchema\n        ]))\n    ]),\n    experimental_providerMetadata: providerMetadataSchema.optional()\n});\nvar coreAssistantMessageSchema = zod__WEBPACK_IMPORTED_MODULE_8__.z.object({\n    role: zod__WEBPACK_IMPORTED_MODULE_8__.z.literal(\"assistant\"),\n    content: zod__WEBPACK_IMPORTED_MODULE_8__.z.union([\n        zod__WEBPACK_IMPORTED_MODULE_8__.z.string(),\n        zod__WEBPACK_IMPORTED_MODULE_8__.z.array(zod__WEBPACK_IMPORTED_MODULE_8__.z.union([\n            textPartSchema,\n            toolCallPartSchema\n        ]))\n    ]),\n    experimental_providerMetadata: providerMetadataSchema.optional()\n});\nvar coreToolMessageSchema = zod__WEBPACK_IMPORTED_MODULE_8__.z.object({\n    role: zod__WEBPACK_IMPORTED_MODULE_8__.z.literal(\"tool\"),\n    content: zod__WEBPACK_IMPORTED_MODULE_8__.z.array(toolResultPartSchema),\n    experimental_providerMetadata: providerMetadataSchema.optional()\n});\nvar coreMessageSchema = zod__WEBPACK_IMPORTED_MODULE_8__.z.union([\n    coreSystemMessageSchema,\n    coreUserMessageSchema,\n    coreAssistantMessageSchema,\n    coreToolMessageSchema\n]);\n// core/prompt/detect-prompt-type.ts\nfunction detectPromptType(prompt) {\n    if (!Array.isArray(prompt)) {\n        return \"other\";\n    }\n    if (prompt.length === 0) {\n        return \"messages\";\n    }\n    const characteristics = prompt.map(detectSingleMessageCharacteristics);\n    if (characteristics.some((c)=>c === \"has-ui-specific-parts\")) {\n        return \"ui-messages\";\n    } else if (characteristics.every((c)=>c === \"has-core-specific-parts\" || c === \"message\")) {\n        return \"messages\";\n    } else {\n        return \"other\";\n    }\n}\nfunction detectSingleMessageCharacteristics(message) {\n    if (typeof message === \"object\" && message !== null && (message.role === \"function\" || // UI-only role\n    message.role === \"data\" || // UI-only role\n    \"toolInvocations\" in message || // UI-specific field\n    \"experimental_attachments\" in message)) {\n        return \"has-ui-specific-parts\";\n    } else if (typeof message === \"object\" && message !== null && \"content\" in message && (Array.isArray(message.content) || // Core messages can have array content\n    \"experimental_providerMetadata\" in message)) {\n        return \"has-core-specific-parts\";\n    } else if (typeof message === \"object\" && message !== null && \"role\" in message && \"content\" in message && typeof message.content === \"string\" && [\n        \"system\",\n        \"user\",\n        \"assistant\",\n        \"tool\"\n    ].includes(message.role)) {\n        return \"message\";\n    } else {\n        return \"other\";\n    }\n}\n// core/prompt/attachments-to-parts.ts\nfunction attachmentsToParts(attachments) {\n    var _a9, _b, _c;\n    const parts = [];\n    for (const attachment of attachments){\n        let url;\n        try {\n            url = new URL(attachment.url);\n        } catch (error) {\n            throw new Error(`Invalid URL: ${attachment.url}`);\n        }\n        switch(url.protocol){\n            case \"http:\":\n            case \"https:\":\n                {\n                    if ((_a9 = attachment.contentType) == null ? void 0 : _a9.startsWith(\"image/\")) {\n                        parts.push({\n                            type: \"image\",\n                            image: url\n                        });\n                    } else {\n                        if (!attachment.contentType) {\n                            throw new Error(\"If the attachment is not an image, it must specify a content type\");\n                        }\n                        parts.push({\n                            type: \"file\",\n                            data: url,\n                            mimeType: attachment.contentType\n                        });\n                    }\n                    break;\n                }\n            case \"data:\":\n                {\n                    let header;\n                    let base64Content;\n                    let mimeType;\n                    try {\n                        [header, base64Content] = attachment.url.split(\",\");\n                        mimeType = header.split(\";\")[0].split(\":\")[1];\n                    } catch (error) {\n                        throw new Error(`Error processing data URL: ${attachment.url}`);\n                    }\n                    if (mimeType == null || base64Content == null) {\n                        throw new Error(`Invalid data URL format: ${attachment.url}`);\n                    }\n                    if ((_b = attachment.contentType) == null ? void 0 : _b.startsWith(\"image/\")) {\n                        parts.push({\n                            type: \"image\",\n                            image: convertDataContentToUint8Array(base64Content)\n                        });\n                    } else if ((_c = attachment.contentType) == null ? void 0 : _c.startsWith(\"text/\")) {\n                        parts.push({\n                            type: \"text\",\n                            text: convertUint8ArrayToText(convertDataContentToUint8Array(base64Content))\n                        });\n                    } else {\n                        if (!attachment.contentType) {\n                            throw new Error(\"If the attachment is not an image or text, it must specify a content type\");\n                        }\n                        parts.push({\n                            type: \"file\",\n                            data: base64Content,\n                            mimeType: attachment.contentType\n                        });\n                    }\n                    break;\n                }\n            default:\n                {\n                    throw new Error(`Unsupported URL protocol: ${url.protocol}`);\n                }\n        }\n    }\n    return parts;\n}\n// core/prompt/message-conversion-error.ts\n\nvar name5 = \"AI_MessageConversionError\";\nvar marker5 = `vercel.ai.error.${name5}`;\nvar symbol5 = Symbol.for(marker5);\nvar _a5;\nvar MessageConversionError = class extends _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_7__.AISDKError {\n    constructor({ originalMessage, message }){\n        super({\n            name: name5,\n            message\n        });\n        this[_a5] = true;\n        this.originalMessage = originalMessage;\n    }\n    static isInstance(error) {\n        return _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_7__.AISDKError.hasMarker(error, marker5);\n    }\n};\n_a5 = symbol5;\n// core/prompt/convert-to-core-messages.ts\nfunction convertToCoreMessages(messages, options) {\n    var _a9;\n    const tools = (_a9 = options == null ? void 0 : options.tools) != null ? _a9 : {};\n    const coreMessages = [];\n    for (const message of messages){\n        const { role, content, toolInvocations, experimental_attachments } = message;\n        switch(role){\n            case \"system\":\n                {\n                    coreMessages.push({\n                        role: \"system\",\n                        content\n                    });\n                    break;\n                }\n            case \"user\":\n                {\n                    coreMessages.push({\n                        role: \"user\",\n                        content: experimental_attachments ? [\n                            {\n                                type: \"text\",\n                                text: content\n                            },\n                            ...attachmentsToParts(experimental_attachments)\n                        ] : content\n                    });\n                    break;\n                }\n            case \"assistant\":\n                {\n                    if (toolInvocations == null) {\n                        coreMessages.push({\n                            role: \"assistant\",\n                            content\n                        });\n                        break;\n                    }\n                    coreMessages.push({\n                        role: \"assistant\",\n                        content: [\n                            {\n                                type: \"text\",\n                                text: content\n                            },\n                            ...toolInvocations.map(({ toolCallId, toolName, args })=>({\n                                    type: \"tool-call\",\n                                    toolCallId,\n                                    toolName,\n                                    args\n                                }))\n                        ]\n                    });\n                    coreMessages.push({\n                        role: \"tool\",\n                        content: toolInvocations.map((toolInvocation)=>{\n                            if (!(\"result\" in toolInvocation)) {\n                                throw new MessageConversionError({\n                                    originalMessage: message,\n                                    message: \"ToolInvocation must have a result: \" + JSON.stringify(toolInvocation)\n                                });\n                            }\n                            const { toolCallId, toolName, result } = toolInvocation;\n                            const tool = tools[toolName];\n                            return (tool == null ? void 0 : tool.experimental_toToolResultContent) != null ? {\n                                type: \"tool-result\",\n                                toolCallId,\n                                toolName,\n                                result: tool.experimental_toToolResultContent(result),\n                                experimental_content: tool.experimental_toToolResultContent(result)\n                            } : {\n                                type: \"tool-result\",\n                                toolCallId,\n                                toolName,\n                                result\n                            };\n                        })\n                    });\n                    break;\n                }\n            case \"function\":\n            case \"data\":\n            case \"tool\":\n                {\n                    break;\n                }\n            default:\n                {\n                    const _exhaustiveCheck = role;\n                    throw new MessageConversionError({\n                        originalMessage: message,\n                        message: `Unsupported role: ${_exhaustiveCheck}`\n                    });\n                }\n        }\n    }\n    return coreMessages;\n}\n// core/prompt/standardize-prompt.ts\nfunction standardizePrompt({ prompt, tools }) {\n    if (prompt.prompt == null && prompt.messages == null) {\n        throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_7__.InvalidPromptError({\n            prompt,\n            message: \"prompt or messages must be defined\"\n        });\n    }\n    if (prompt.prompt != null && prompt.messages != null) {\n        throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_7__.InvalidPromptError({\n            prompt,\n            message: \"prompt and messages cannot be defined at the same time\"\n        });\n    }\n    if (prompt.system != null && typeof prompt.system !== \"string\") {\n        throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_7__.InvalidPromptError({\n            prompt,\n            message: \"system must be a string\"\n        });\n    }\n    if (prompt.prompt != null) {\n        if (typeof prompt.prompt !== \"string\") {\n            throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_7__.InvalidPromptError({\n                prompt,\n                message: \"prompt must be a string\"\n            });\n        }\n        return {\n            type: \"prompt\",\n            system: prompt.system,\n            messages: [\n                {\n                    role: \"user\",\n                    content: prompt.prompt\n                }\n            ]\n        };\n    }\n    if (prompt.messages != null) {\n        const promptType = detectPromptType(prompt.messages);\n        if (promptType === \"other\") {\n            throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_7__.InvalidPromptError({\n                prompt,\n                message: \"messages must be an array of CoreMessage or UIMessage\"\n            });\n        }\n        const messages = promptType === \"ui-messages\" ? convertToCoreMessages(prompt.messages, {\n            tools\n        }) : prompt.messages;\n        const validationResult = (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_9__.safeValidateTypes)({\n            value: messages,\n            schema: zod__WEBPACK_IMPORTED_MODULE_8__.z.array(coreMessageSchema)\n        });\n        if (!validationResult.success) {\n            throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_7__.InvalidPromptError({\n                prompt,\n                message: \"messages must be an array of CoreMessage or UIMessage\",\n                cause: validationResult.error\n            });\n        }\n        return {\n            type: \"messages\",\n            messages,\n            system: prompt.system\n        };\n    }\n    throw new Error(\"unreachable\");\n}\n// core/types/usage.ts\nfunction calculateLanguageModelUsage(usage) {\n    return {\n        promptTokens: usage.promptTokens,\n        completionTokens: usage.completionTokens,\n        totalTokens: usage.promptTokens + usage.completionTokens\n    };\n}\n// errors/invalid-tool-arguments-error.ts\n\nvar name6 = \"AI_InvalidToolArgumentsError\";\nvar marker6 = `vercel.ai.error.${name6}`;\nvar symbol6 = Symbol.for(marker6);\nvar _a6;\nvar InvalidToolArgumentsError = class extends _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_7__.AISDKError {\n    constructor({ toolArgs, toolName, cause, message = `Invalid arguments for tool ${toolName}: ${(0,_ai_sdk_provider__WEBPACK_IMPORTED_MODULE_7__.getErrorMessage)(cause)}` }){\n        super({\n            name: name6,\n            message,\n            cause\n        });\n        this[_a6] = true;\n        this.toolArgs = toolArgs;\n        this.toolName = toolName;\n    }\n    static isInstance(error) {\n        return _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_7__.AISDKError.hasMarker(error, marker6);\n    }\n    /**\n   * @deprecated use `isInstance` instead\n   */ static isInvalidToolArgumentsError(error) {\n        return error instanceof Error && error.name === name6 && typeof error.toolName === \"string\" && typeof error.toolArgs === \"string\";\n    }\n    /**\n   * @deprecated Do not use this method. It will be removed in the next major version.\n   */ toJSON() {\n        return {\n            name: this.name,\n            message: this.message,\n            cause: this.cause,\n            stack: this.stack,\n            toolName: this.toolName,\n            toolArgs: this.toolArgs\n        };\n    }\n};\n_a6 = symbol6;\n// errors/no-such-tool-error.ts\n\nvar name7 = \"AI_NoSuchToolError\";\nvar marker7 = `vercel.ai.error.${name7}`;\nvar symbol7 = Symbol.for(marker7);\nvar _a7;\nvar NoSuchToolError = class extends _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_7__.AISDKError {\n    constructor({ toolName, availableTools = void 0, message = `Model tried to call unavailable tool '${toolName}'. ${availableTools === void 0 ? \"No tools are available.\" : `Available tools: ${availableTools.join(\", \")}.`}` }){\n        super({\n            name: name7,\n            message\n        });\n        this[_a7] = true;\n        this.toolName = toolName;\n        this.availableTools = availableTools;\n    }\n    static isInstance(error) {\n        return _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_7__.AISDKError.hasMarker(error, marker7);\n    }\n    /**\n   * @deprecated use `isInstance` instead\n   */ static isNoSuchToolError(error) {\n        return error instanceof Error && error.name === name7 && \"toolName\" in error && error.toolName != void 0 && typeof error.name === \"string\";\n    }\n    /**\n   * @deprecated Do not use this method. It will be removed in the next major version.\n   */ toJSON() {\n        return {\n            name: this.name,\n            message: this.message,\n            stack: this.stack,\n            toolName: this.toolName,\n            availableTools: this.availableTools\n        };\n    }\n};\n_a7 = symbol7;\n// util/is-async-generator.ts\nfunction isAsyncGenerator(value) {\n    return value != null && typeof value === \"object\" && Symbol.asyncIterator in value;\n}\n// util/is-generator.ts\nfunction isGenerator(value) {\n    return value != null && typeof value === \"object\" && Symbol.iterator in value;\n}\n// util/retry-with-exponential-backoff.ts\n\n\n// util/delay.ts\nasync function delay(delayInMs) {\n    return delayInMs === void 0 ? Promise.resolve() : new Promise((resolve)=>setTimeout(resolve, delayInMs));\n}\n// util/retry-error.ts\n\nvar name8 = \"AI_RetryError\";\nvar marker8 = `vercel.ai.error.${name8}`;\nvar symbol8 = Symbol.for(marker8);\nvar _a8;\nvar RetryError = class extends _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_7__.AISDKError {\n    constructor({ message, reason, errors }){\n        super({\n            name: name8,\n            message\n        });\n        this[_a8] = true;\n        this.reason = reason;\n        this.errors = errors;\n        this.lastError = errors[errors.length - 1];\n    }\n    static isInstance(error) {\n        return _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_7__.AISDKError.hasMarker(error, marker8);\n    }\n    /**\n   * @deprecated use `isInstance` instead\n   */ static isRetryError(error) {\n        return error instanceof Error && error.name === name8 && typeof error.reason === \"string\" && Array.isArray(error.errors);\n    }\n    /**\n   * @deprecated Do not use this method. It will be removed in the next major version.\n   */ toJSON() {\n        return {\n            name: this.name,\n            message: this.message,\n            reason: this.reason,\n            lastError: this.lastError,\n            errors: this.errors\n        };\n    }\n};\n_a8 = symbol8;\n// util/retry-with-exponential-backoff.ts\nvar retryWithExponentialBackoff = ({ maxRetries = 2, initialDelayInMs = 2e3, backoffFactor = 2 } = {})=>async (f)=>_retryWithExponentialBackoff(f, {\n            maxRetries,\n            delayInMs: initialDelayInMs,\n            backoffFactor\n        });\nasync function _retryWithExponentialBackoff(f, { maxRetries, delayInMs, backoffFactor }, errors = []) {\n    try {\n        return await f();\n    } catch (error) {\n        if ((0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_9__.isAbortError)(error)) {\n            throw error;\n        }\n        if (maxRetries === 0) {\n            throw error;\n        }\n        const errorMessage = (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_9__.getErrorMessage)(error);\n        const newErrors = [\n            ...errors,\n            error\n        ];\n        const tryNumber = newErrors.length;\n        if (tryNumber > maxRetries) {\n            throw new RetryError({\n                message: `Failed after ${tryNumber} attempts. Last error: ${errorMessage}`,\n                reason: \"maxRetriesExceeded\",\n                errors: newErrors\n            });\n        }\n        if (error instanceof Error && _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_7__.APICallError.isAPICallError(error) && error.isRetryable === true && tryNumber <= maxRetries) {\n            await delay(delayInMs);\n            return _retryWithExponentialBackoff(f, {\n                maxRetries,\n                delayInMs: backoffFactor * delayInMs,\n                backoffFactor\n            }, newErrors);\n        }\n        if (tryNumber === 1) {\n            throw error;\n        }\n        throw new RetryError({\n            message: `Failed after ${tryNumber} attempts with non-retryable error: '${errorMessage}'`,\n            reason: \"errorNotRetryable\",\n            errors: newErrors\n        });\n    }\n}\n// util/constants.ts\nvar HANGING_STREAM_WARNING_TIME_MS = 15 * 1e3;\n// rsc/streamable-ui/create-suspended-chunk.tsx\n\n\nvar R = [\n    async ({ c: current, n: next })=>{\n        const chunk = await next;\n        if (chunk.done) {\n            return chunk.value;\n        }\n        if (chunk.append) {\n            return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.Fragment, {\n                children: [\n                    current,\n                    /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(react__WEBPACK_IMPORTED_MODULE_4__.Suspense, {\n                        fallback: chunk.value,\n                        children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(R, {\n                            c: chunk.value,\n                            n: chunk.next\n                        })\n                    })\n                ]\n            });\n        }\n        return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(react__WEBPACK_IMPORTED_MODULE_4__.Suspense, {\n            fallback: chunk.value,\n            children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(R, {\n                c: chunk.value,\n                n: chunk.next\n            })\n        });\n    }\n][0];\nfunction createSuspendedChunk(initialValue) {\n    const { promise, resolve, reject } = createResolvablePromise();\n    return {\n        row: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(react__WEBPACK_IMPORTED_MODULE_4__.Suspense, {\n            fallback: initialValue,\n            children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_5__.jsx)(R, {\n                c: initialValue,\n                n: promise\n            })\n        }),\n        resolve,\n        reject\n    };\n}\n// rsc/streamable-ui/create-streamable-ui.tsx\nfunction createStreamableUI(initialValue) {\n    let currentValue = initialValue;\n    let closed = false;\n    let { row, resolve, reject } = createSuspendedChunk(initialValue);\n    function assertStream(method) {\n        if (closed) {\n            throw new Error(method + \": UI stream is already closed.\");\n        }\n    }\n    let warningTimeout;\n    function warnUnclosedStream() {\n        if (true) {\n            if (warningTimeout) {\n                clearTimeout(warningTimeout);\n            }\n            warningTimeout = setTimeout(()=>{\n                console.warn(\"The streamable UI has been slow to update. This may be a bug or a performance issue or you forgot to call `.done()`.\");\n            }, HANGING_STREAM_WARNING_TIME_MS);\n        }\n    }\n    warnUnclosedStream();\n    const streamable2 = {\n        value: row,\n        update (value) {\n            assertStream(\".update()\");\n            if (value === currentValue) {\n                warnUnclosedStream();\n                return streamable2;\n            }\n            const resolvable = createResolvablePromise();\n            currentValue = value;\n            resolve({\n                value: currentValue,\n                done: false,\n                next: resolvable.promise\n            });\n            resolve = resolvable.resolve;\n            reject = resolvable.reject;\n            warnUnclosedStream();\n            return streamable2;\n        },\n        append (value) {\n            assertStream(\".append()\");\n            const resolvable = createResolvablePromise();\n            currentValue = value;\n            resolve({\n                value,\n                done: false,\n                append: true,\n                next: resolvable.promise\n            });\n            resolve = resolvable.resolve;\n            reject = resolvable.reject;\n            warnUnclosedStream();\n            return streamable2;\n        },\n        error (error) {\n            assertStream(\".error()\");\n            if (warningTimeout) {\n                clearTimeout(warningTimeout);\n            }\n            closed = true;\n            reject(error);\n            return streamable2;\n        },\n        done (...args) {\n            assertStream(\".done()\");\n            if (warningTimeout) {\n                clearTimeout(warningTimeout);\n            }\n            closed = true;\n            if (args.length) {\n                resolve({\n                    value: args[0],\n                    done: true\n                });\n                return streamable2;\n            }\n            resolve({\n                value: currentValue,\n                done: true\n            });\n            return streamable2;\n        }\n    };\n    return streamable2;\n}\n// rsc/stream-ui/stream-ui.tsx\nvar defaultTextRenderer = ({ content })=>content;\nasync function streamUI({ model, tools, toolChoice, system, prompt, messages, maxRetries, abortSignal, headers, initial, text, experimental_providerMetadata: providerMetadata, onFinish, ...settings }) {\n    if (typeof model === \"string\") {\n        throw new Error(\"`model` cannot be a string in `streamUI`. Use the actual model instance instead.\");\n    }\n    if (\"functions\" in settings) {\n        throw new Error(\"`functions` is not supported in `streamUI`, use `tools` instead.\");\n    }\n    if (\"provider\" in settings) {\n        throw new Error(\"`provider` is no longer needed in `streamUI`. Use `model` instead.\");\n    }\n    if (tools) {\n        for (const [name9, tool] of Object.entries(tools)){\n            if (\"render\" in tool) {\n                throw new Error(\"Tool definition in `streamUI` should not have `render` property. Use `generate` instead. Found in tool: \" + name9);\n            }\n        }\n    }\n    const ui = createStreamableUI(initial);\n    const textRender = text || defaultTextRenderer;\n    let finished;\n    let finishEvent = null;\n    async function render2({ args, renderer, streamableUI, isLastCall = false }) {\n        if (!renderer) return;\n        const renderFinished = createResolvablePromise();\n        finished = finished ? finished.then(()=>renderFinished.promise) : renderFinished.promise;\n        const rendererResult = renderer(...args);\n        if (isAsyncGenerator(rendererResult) || isGenerator(rendererResult)) {\n            while(true){\n                const { done, value } = await rendererResult.next();\n                const node = await value;\n                if (isLastCall && done) {\n                    streamableUI.done(node);\n                } else {\n                    streamableUI.update(node);\n                }\n                if (done) break;\n            }\n        } else {\n            const node = await rendererResult;\n            if (isLastCall) {\n                streamableUI.done(node);\n            } else {\n                streamableUI.update(node);\n            }\n        }\n        renderFinished.resolve(void 0);\n    }\n    const retry = retryWithExponentialBackoff({\n        maxRetries\n    });\n    const validatedPrompt = standardizePrompt({\n        prompt: {\n            system,\n            prompt,\n            messages\n        },\n        tools: void 0\n    });\n    const result = await retry(async ()=>model.doStream({\n            mode: {\n                type: \"regular\",\n                ...prepareToolsAndToolChoice({\n                    tools,\n                    toolChoice,\n                    activeTools: void 0\n                })\n            },\n            ...prepareCallSettings(settings),\n            inputFormat: validatedPrompt.type,\n            prompt: await convertToLanguageModelPrompt({\n                prompt: validatedPrompt,\n                modelSupportsImageUrls: model.supportsImageUrls,\n                modelSupportsUrl: model.supportsUrl\n            }),\n            providerMetadata,\n            abortSignal,\n            headers\n        }));\n    const [stream, forkedStream] = result.stream.tee();\n    (async ()=>{\n        try {\n            let content = \"\";\n            let hasToolCall = false;\n            const reader = forkedStream.getReader();\n            while(true){\n                const { done, value } = await reader.read();\n                if (done) break;\n                switch(value.type){\n                    case \"text-delta\":\n                        {\n                            content += value.textDelta;\n                            render2({\n                                renderer: textRender,\n                                args: [\n                                    {\n                                        content,\n                                        done: false,\n                                        delta: value.textDelta\n                                    }\n                                ],\n                                streamableUI: ui\n                            });\n                            break;\n                        }\n                    case \"tool-call-delta\":\n                        {\n                            hasToolCall = true;\n                            break;\n                        }\n                    case \"tool-call\":\n                        {\n                            const toolName = value.toolName;\n                            if (!tools) {\n                                throw new NoSuchToolError({\n                                    toolName\n                                });\n                            }\n                            const tool = tools[toolName];\n                            if (!tool) {\n                                throw new NoSuchToolError({\n                                    toolName,\n                                    availableTools: Object.keys(tools)\n                                });\n                            }\n                            hasToolCall = true;\n                            const parseResult = (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_9__.safeParseJSON)({\n                                text: value.args,\n                                schema: tool.parameters\n                            });\n                            if (parseResult.success === false) {\n                                throw new InvalidToolArgumentsError({\n                                    toolName,\n                                    toolArgs: value.args,\n                                    cause: parseResult.error\n                                });\n                            }\n                            render2({\n                                renderer: tool.generate,\n                                args: [\n                                    parseResult.value,\n                                    {\n                                        toolName,\n                                        toolCallId: value.toolCallId\n                                    }\n                                ],\n                                streamableUI: ui,\n                                isLastCall: true\n                            });\n                            break;\n                        }\n                    case \"error\":\n                        {\n                            throw value.error;\n                        }\n                    case \"finish\":\n                        {\n                            finishEvent = {\n                                finishReason: value.finishReason,\n                                usage: calculateLanguageModelUsage(value.usage),\n                                warnings: result.warnings,\n                                rawResponse: result.rawResponse\n                            };\n                            break;\n                        }\n                }\n            }\n            if (!hasToolCall) {\n                render2({\n                    renderer: textRender,\n                    args: [\n                        {\n                            content,\n                            done: true\n                        }\n                    ],\n                    streamableUI: ui,\n                    isLastCall: true\n                });\n            }\n            await finished;\n            if (finishEvent && onFinish) {\n                await onFinish({\n                    ...finishEvent,\n                    value: ui.value\n                });\n            }\n        } catch (error) {\n            ui.error(error);\n        }\n    })();\n    return {\n        ...result,\n        stream,\n        value: ui.value\n    };\n}\n// rsc/stream-ui/render.ts\n\n// streams/ai-stream.ts\n\nfunction createEventStreamTransformer(customParser) {\n    const textDecoder = new TextDecoder();\n    let eventSourceParser;\n    return new TransformStream({\n        async start (controller) {\n            eventSourceParser = (0,eventsource_parser__WEBPACK_IMPORTED_MODULE_12__.createParser)((event)=>{\n                if (\"data\" in event && event.type === \"event\" && event.data === \"[DONE]\" || // Replicate doesn't send [DONE] but does send a 'done' event\n                // @see https://replicate.com/docs/streaming\n                event.event === \"done\") {\n                    controller.terminate();\n                    return;\n                }\n                if (\"data\" in event) {\n                    const parsedMessage = customParser ? customParser(event.data, {\n                        event: event.event\n                    }) : event.data;\n                    if (parsedMessage) controller.enqueue(parsedMessage);\n                }\n            });\n        },\n        transform (chunk) {\n            eventSourceParser.feed(textDecoder.decode(chunk));\n        }\n    });\n}\nfunction createCallbacksTransformer(cb) {\n    const textEncoder = new TextEncoder();\n    let aggregatedResponse = \"\";\n    const callbacks = cb || {};\n    return new TransformStream({\n        async start () {\n            if (callbacks.onStart) await callbacks.onStart();\n        },\n        async transform (message, controller) {\n            const content = typeof message === \"string\" ? message : message.content;\n            controller.enqueue(textEncoder.encode(content));\n            aggregatedResponse += content;\n            if (callbacks.onToken) await callbacks.onToken(content);\n            if (callbacks.onText && typeof message === \"string\") {\n                await callbacks.onText(message);\n            }\n        },\n        async flush () {\n            const isOpenAICallbacks = isOfTypeOpenAIStreamCallbacks(callbacks);\n            if (callbacks.onCompletion) {\n                await callbacks.onCompletion(aggregatedResponse);\n            }\n            if (callbacks.onFinal && !isOpenAICallbacks) {\n                await callbacks.onFinal(aggregatedResponse);\n            }\n        }\n    });\n}\nfunction isOfTypeOpenAIStreamCallbacks(callbacks) {\n    return \"experimental_onFunctionCall\" in callbacks;\n}\nfunction trimStartOfStreamHelper() {\n    let isStreamStart = true;\n    return (text)=>{\n        if (isStreamStart) {\n            text = text.trimStart();\n            if (text) isStreamStart = false;\n        }\n        return text;\n    };\n}\nfunction AIStream(response, customParser, callbacks) {\n    if (!response.ok) {\n        if (response.body) {\n            const reader = response.body.getReader();\n            return new ReadableStream({\n                async start (controller) {\n                    const { done, value } = await reader.read();\n                    if (!done) {\n                        const errorText = new TextDecoder().decode(value);\n                        controller.error(new Error(`Response error: ${errorText}`));\n                    }\n                }\n            });\n        } else {\n            return new ReadableStream({\n                start (controller) {\n                    controller.error(new Error(\"Response error: No response body\"));\n                }\n            });\n        }\n    }\n    const responseBodyStream = response.body || createEmptyReadableStream();\n    return responseBodyStream.pipeThrough(createEventStreamTransformer(customParser)).pipeThrough(createCallbacksTransformer(callbacks));\n}\nfunction createEmptyReadableStream() {\n    return new ReadableStream({\n        start (controller) {\n            controller.close();\n        }\n    });\n}\nfunction readableFromAsyncIterable(iterable) {\n    let it = iterable[Symbol.asyncIterator]();\n    return new ReadableStream({\n        async pull (controller) {\n            const { done, value } = await it.next();\n            if (done) controller.close();\n            else controller.enqueue(value);\n        },\n        async cancel (reason) {\n            var _a9;\n            await ((_a9 = it.return) == null ? void 0 : _a9.call(it, reason));\n        }\n    });\n}\n// streams/stream-data.ts\n\nfunction createStreamDataTransformer() {\n    const encoder = new TextEncoder();\n    const decoder = new TextDecoder();\n    return new TransformStream({\n        transform: async (chunk, controller)=>{\n            const message = decoder.decode(chunk);\n            controller.enqueue(encoder.encode((0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_10__.formatStreamPart)(\"text\", message)));\n        }\n    });\n}\n// streams/openai-stream.ts\n\nfunction parseOpenAIStream() {\n    const extract = chunkToText();\n    return (data)=>extract(JSON.parse(data));\n}\nasync function* streamable(stream) {\n    const extract = chunkToText();\n    for await (let chunk of stream){\n        if (\"promptFilterResults\" in chunk) {\n            chunk = {\n                id: chunk.id,\n                created: chunk.created.getDate(),\n                object: chunk.object,\n                // not exposed by Azure API\n                model: chunk.model,\n                // not exposed by Azure API\n                choices: chunk.choices.map((choice)=>{\n                    var _a9, _b, _c, _d, _e, _f, _g;\n                    return {\n                        delta: {\n                            content: (_a9 = choice.delta) == null ? void 0 : _a9.content,\n                            function_call: (_b = choice.delta) == null ? void 0 : _b.functionCall,\n                            role: (_c = choice.delta) == null ? void 0 : _c.role,\n                            tool_calls: ((_e = (_d = choice.delta) == null ? void 0 : _d.toolCalls) == null ? void 0 : _e.length) ? (_g = (_f = choice.delta) == null ? void 0 : _f.toolCalls) == null ? void 0 : _g.map((toolCall, index)=>({\n                                    index,\n                                    id: toolCall.id,\n                                    function: toolCall.function,\n                                    type: toolCall.type\n                                })) : void 0\n                        },\n                        finish_reason: choice.finishReason,\n                        index: choice.index\n                    };\n                })\n            };\n        }\n        const text = extract(chunk);\n        if (text) yield text;\n    }\n}\nfunction chunkToText() {\n    const trimStartOfStream = trimStartOfStreamHelper();\n    let isFunctionStreamingIn;\n    return (json)=>{\n        var _a9, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p, _q, _r;\n        if (isChatCompletionChunk(json)) {\n            const delta = (_a9 = json.choices[0]) == null ? void 0 : _a9.delta;\n            if ((_b = delta.function_call) == null ? void 0 : _b.name) {\n                isFunctionStreamingIn = true;\n                return {\n                    isText: false,\n                    content: `{\"function_call\": {\"name\": \"${delta.function_call.name}\", \"arguments\": \"`\n                };\n            } else if ((_e = (_d = (_c = delta.tool_calls) == null ? void 0 : _c[0]) == null ? void 0 : _d.function) == null ? void 0 : _e.name) {\n                isFunctionStreamingIn = true;\n                const toolCall = delta.tool_calls[0];\n                if (toolCall.index === 0) {\n                    return {\n                        isText: false,\n                        content: `{\"tool_calls\":[ {\"id\": \"${toolCall.id}\", \"type\": \"function\", \"function\": {\"name\": \"${(_f = toolCall.function) == null ? void 0 : _f.name}\", \"arguments\": \"`\n                    };\n                } else {\n                    return {\n                        isText: false,\n                        content: `\"}}, {\"id\": \"${toolCall.id}\", \"type\": \"function\", \"function\": {\"name\": \"${(_g = toolCall.function) == null ? void 0 : _g.name}\", \"arguments\": \"`\n                    };\n                }\n            } else if ((_h = delta.function_call) == null ? void 0 : _h.arguments) {\n                return {\n                    isText: false,\n                    content: cleanupArguments((_i = delta.function_call) == null ? void 0 : _i.arguments)\n                };\n            } else if ((_l = (_k = (_j = delta.tool_calls) == null ? void 0 : _j[0]) == null ? void 0 : _k.function) == null ? void 0 : _l.arguments) {\n                return {\n                    isText: false,\n                    content: cleanupArguments((_o = (_n = (_m = delta.tool_calls) == null ? void 0 : _m[0]) == null ? void 0 : _n.function) == null ? void 0 : _o.arguments)\n                };\n            } else if (isFunctionStreamingIn && (((_p = json.choices[0]) == null ? void 0 : _p.finish_reason) === \"function_call\" || ((_q = json.choices[0]) == null ? void 0 : _q.finish_reason) === \"stop\")) {\n                isFunctionStreamingIn = false;\n                return {\n                    isText: false,\n                    content: '\"}}'\n                };\n            } else if (isFunctionStreamingIn && ((_r = json.choices[0]) == null ? void 0 : _r.finish_reason) === \"tool_calls\") {\n                isFunctionStreamingIn = false;\n                return {\n                    isText: false,\n                    content: '\"}}]}'\n                };\n            }\n        }\n        const text = trimStartOfStream(isChatCompletionChunk(json) && json.choices[0].delta.content ? json.choices[0].delta.content : isCompletion(json) ? json.choices[0].text : \"\");\n        return text;\n    };\n    function cleanupArguments(argumentChunk) {\n        let escapedPartialJson = argumentChunk.replace(/\\\\/g, \"\\\\\\\\\").replace(/\\//g, \"\\\\/\").replace(/\"/g, '\\\\\"').replace(/\\n/g, \"\\\\n\").replace(/\\r/g, \"\\\\r\").replace(/\\t/g, \"\\\\t\").replace(/\\f/g, \"\\\\f\");\n        return `${escapedPartialJson}`;\n    }\n}\nvar __internal__OpenAIFnMessagesSymbol = Symbol(\"internal_openai_fn_messages\");\nfunction isChatCompletionChunk(data) {\n    return \"choices\" in data && data.choices && data.choices[0] && \"delta\" in data.choices[0];\n}\nfunction isCompletion(data) {\n    return \"choices\" in data && data.choices && data.choices[0] && \"text\" in data.choices[0];\n}\nfunction OpenAIStream(res, callbacks) {\n    const cb = callbacks;\n    let stream;\n    if (Symbol.asyncIterator in res) {\n        stream = readableFromAsyncIterable(streamable(res)).pipeThrough(createCallbacksTransformer((cb == null ? void 0 : cb.experimental_onFunctionCall) || (cb == null ? void 0 : cb.experimental_onToolCall) ? {\n            ...cb,\n            onFinal: void 0\n        } : {\n            ...cb\n        }));\n    } else {\n        stream = AIStream(res, parseOpenAIStream(), (cb == null ? void 0 : cb.experimental_onFunctionCall) || (cb == null ? void 0 : cb.experimental_onToolCall) ? {\n            ...cb,\n            onFinal: void 0\n        } : {\n            ...cb\n        });\n    }\n    if (cb && (cb.experimental_onFunctionCall || cb.experimental_onToolCall)) {\n        const functionCallTransformer = createFunctionCallTransformer(cb);\n        return stream.pipeThrough(functionCallTransformer);\n    } else {\n        return stream.pipeThrough(createStreamDataTransformer());\n    }\n}\nfunction createFunctionCallTransformer(callbacks) {\n    const textEncoder = new TextEncoder();\n    let isFirstChunk = true;\n    let aggregatedResponse = \"\";\n    let aggregatedFinalCompletionResponse = \"\";\n    let isFunctionStreamingIn = false;\n    let functionCallMessages = callbacks[__internal__OpenAIFnMessagesSymbol] || [];\n    const decode = (0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_10__.createChunkDecoder)();\n    return new TransformStream({\n        async transform (chunk, controller) {\n            const message = decode(chunk);\n            aggregatedFinalCompletionResponse += message;\n            const shouldHandleAsFunction = isFirstChunk && (message.startsWith('{\"function_call\":') || message.startsWith('{\"tool_calls\":'));\n            if (shouldHandleAsFunction) {\n                isFunctionStreamingIn = true;\n                aggregatedResponse += message;\n                isFirstChunk = false;\n                return;\n            }\n            if (!isFunctionStreamingIn) {\n                controller.enqueue(textEncoder.encode((0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_10__.formatStreamPart)(\"text\", message)));\n                return;\n            } else {\n                aggregatedResponse += message;\n            }\n        },\n        async flush (controller) {\n            try {\n                if (!isFirstChunk && isFunctionStreamingIn && (callbacks.experimental_onFunctionCall || callbacks.experimental_onToolCall)) {\n                    isFunctionStreamingIn = false;\n                    const payload = JSON.parse(aggregatedResponse);\n                    let newFunctionCallMessages = [\n                        ...functionCallMessages\n                    ];\n                    let functionResponse = void 0;\n                    if (callbacks.experimental_onFunctionCall) {\n                        if (payload.function_call === void 0) {\n                            console.warn(\"experimental_onFunctionCall should not be defined when using tools\");\n                        }\n                        const argumentsPayload = JSON.parse(payload.function_call.arguments);\n                        functionResponse = await callbacks.experimental_onFunctionCall({\n                            name: payload.function_call.name,\n                            arguments: argumentsPayload\n                        }, (result)=>{\n                            newFunctionCallMessages = [\n                                ...functionCallMessages,\n                                {\n                                    role: \"assistant\",\n                                    content: \"\",\n                                    function_call: payload.function_call\n                                },\n                                {\n                                    role: \"function\",\n                                    name: payload.function_call.name,\n                                    content: JSON.stringify(result)\n                                }\n                            ];\n                            return newFunctionCallMessages;\n                        });\n                    }\n                    if (callbacks.experimental_onToolCall) {\n                        const toolCalls = {\n                            tools: []\n                        };\n                        for (const tool of payload.tool_calls){\n                            toolCalls.tools.push({\n                                id: tool.id,\n                                type: \"function\",\n                                func: {\n                                    name: tool.function.name,\n                                    arguments: JSON.parse(tool.function.arguments)\n                                }\n                            });\n                        }\n                        let responseIndex = 0;\n                        try {\n                            functionResponse = await callbacks.experimental_onToolCall(toolCalls, (result)=>{\n                                if (result) {\n                                    const { tool_call_id, function_name, tool_call_result } = result;\n                                    newFunctionCallMessages = [\n                                        ...newFunctionCallMessages,\n                                        // Only append the assistant message if it's the first response\n                                        ...responseIndex === 0 ? [\n                                            {\n                                                role: \"assistant\",\n                                                content: \"\",\n                                                tool_calls: payload.tool_calls.map((tc)=>({\n                                                        id: tc.id,\n                                                        type: \"function\",\n                                                        function: {\n                                                            name: tc.function.name,\n                                                            // we send the arguments an object to the user, but as the API expects a string, we need to stringify it\n                                                            arguments: JSON.stringify(tc.function.arguments)\n                                                        }\n                                                    }))\n                                            }\n                                        ] : [],\n                                        // Append the function call result message\n                                        {\n                                            role: \"tool\",\n                                            tool_call_id,\n                                            name: function_name,\n                                            content: JSON.stringify(tool_call_result)\n                                        }\n                                    ];\n                                    responseIndex++;\n                                }\n                                return newFunctionCallMessages;\n                            });\n                        } catch (e) {\n                            console.error(\"Error calling experimental_onToolCall:\", e);\n                        }\n                    }\n                    if (!functionResponse) {\n                        controller.enqueue(textEncoder.encode((0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_10__.formatStreamPart)(payload.function_call ? \"function_call\" : \"tool_calls\", // parse to prevent double-encoding:\n                        JSON.parse(aggregatedResponse))));\n                        return;\n                    } else if (typeof functionResponse === \"string\") {\n                        controller.enqueue(textEncoder.encode((0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_10__.formatStreamPart)(\"text\", functionResponse)));\n                        aggregatedFinalCompletionResponse = functionResponse;\n                        return;\n                    }\n                    const filteredCallbacks = {\n                        ...callbacks,\n                        onStart: void 0\n                    };\n                    callbacks.onFinal = void 0;\n                    const openAIStream = OpenAIStream(functionResponse, {\n                        ...filteredCallbacks,\n                        [__internal__OpenAIFnMessagesSymbol]: newFunctionCallMessages\n                    });\n                    const reader = openAIStream.getReader();\n                    while(true){\n                        const { done, value } = await reader.read();\n                        if (done) {\n                            break;\n                        }\n                        controller.enqueue(value);\n                    }\n                }\n            } finally{\n                if (callbacks.onFinal && aggregatedFinalCompletionResponse) {\n                    await callbacks.onFinal(aggregatedFinalCompletionResponse);\n                }\n            }\n        }\n    });\n}\n// util/consume-stream.ts\nasync function consumeStream(stream) {\n    const reader = stream.getReader();\n    while(true){\n        const { done } = await reader.read();\n        if (done) break;\n    }\n}\n// rsc/stream-ui/render.ts\nfunction render(options) {\n    const ui = createStreamableUI(options.initial);\n    const text = options.text ? options.text : ({ content })=>content;\n    const functions = options.functions ? Object.entries(options.functions).map(([name9, { description, parameters }])=>{\n        return {\n            name: name9,\n            description,\n            parameters: (0,zod_to_json_schema__WEBPACK_IMPORTED_MODULE_11__[\"default\"])(parameters)\n        };\n    }) : void 0;\n    const tools = options.tools ? Object.entries(options.tools).map(([name9, { description, parameters }])=>{\n        return {\n            type: \"function\",\n            function: {\n                name: name9,\n                description,\n                parameters: (0,zod_to_json_schema__WEBPACK_IMPORTED_MODULE_11__[\"default\"])(parameters)\n            }\n        };\n    }) : void 0;\n    if (functions && tools) {\n        throw new Error(\"You can't have both functions and tools defined. Please choose one or the other.\");\n    }\n    let finished;\n    async function handleRender(args, renderer, res) {\n        if (!renderer) return;\n        const resolvable = createResolvablePromise();\n        if (finished) {\n            finished = finished.then(()=>resolvable.promise);\n        } else {\n            finished = resolvable.promise;\n        }\n        const value = renderer(args);\n        if (value instanceof Promise || value && typeof value === \"object\" && \"then\" in value && typeof value.then === \"function\") {\n            const node = await value;\n            res.update(node);\n            resolvable.resolve(void 0);\n        } else if (value && typeof value === \"object\" && Symbol.asyncIterator in value) {\n            const it = value;\n            while(true){\n                const { done, value: value2 } = await it.next();\n                res.update(value2);\n                if (done) break;\n            }\n            resolvable.resolve(void 0);\n        } else if (value && typeof value === \"object\" && Symbol.iterator in value) {\n            const it = value;\n            while(true){\n                const { done, value: value2 } = it.next();\n                res.update(value2);\n                if (done) break;\n            }\n            resolvable.resolve(void 0);\n        } else {\n            res.update(value);\n            resolvable.resolve(void 0);\n        }\n    }\n    (async ()=>{\n        let hasFunction = false;\n        let content = \"\";\n        consumeStream(OpenAIStream(await options.provider.chat.completions.create({\n            model: options.model,\n            messages: options.messages,\n            temperature: options.temperature,\n            stream: true,\n            ...functions ? {\n                functions\n            } : {},\n            ...tools ? {\n                tools\n            } : {}\n        }), {\n            ...functions ? {\n                async experimental_onFunctionCall (functionCallPayload) {\n                    var _a9, _b;\n                    hasFunction = true;\n                    handleRender(functionCallPayload.arguments, (_b = (_a9 = options.functions) == null ? void 0 : _a9[functionCallPayload.name]) == null ? void 0 : _b.render, ui);\n                }\n            } : {},\n            ...tools ? {\n                async experimental_onToolCall (toolCallPayload) {\n                    var _a9, _b;\n                    hasFunction = true;\n                    for (const tool of toolCallPayload.tools){\n                        handleRender(tool.func.arguments, (_b = (_a9 = options.tools) == null ? void 0 : _a9[tool.func.name]) == null ? void 0 : _b.render, ui);\n                    }\n                }\n            } : {},\n            onText (chunk) {\n                content += chunk;\n                handleRender({\n                    content,\n                    done: false,\n                    delta: chunk\n                }, text, ui);\n            },\n            async onFinal () {\n                if (hasFunction) {\n                    await finished;\n                    ui.done();\n                    return;\n                }\n                handleRender({\n                    content,\n                    done: true\n                }, text, ui);\n                await finished;\n                ui.done();\n            }\n        }));\n    })();\n    return ui.value;\n}\n// rsc/streamable-value/streamable-value.ts\nvar STREAMABLE_VALUE_TYPE = Symbol.for(\"ui.streamable.value\");\n// rsc/streamable-value/create-streamable-value.ts\nvar STREAMABLE_VALUE_INTERNAL_LOCK = Symbol(\"streamable.value.lock\");\nfunction createStreamableValue(initialValue) {\n    const isReadableStream = initialValue instanceof ReadableStream || typeof initialValue === \"object\" && initialValue !== null && \"getReader\" in initialValue && typeof initialValue.getReader === \"function\" && \"locked\" in initialValue && typeof initialValue.locked === \"boolean\";\n    if (!isReadableStream) {\n        return createStreamableValueImpl(initialValue);\n    }\n    const streamableValue = createStreamableValueImpl();\n    streamableValue[STREAMABLE_VALUE_INTERNAL_LOCK] = true;\n    (async ()=>{\n        try {\n            const reader = initialValue.getReader();\n            while(true){\n                const { value, done } = await reader.read();\n                if (done) {\n                    break;\n                }\n                streamableValue[STREAMABLE_VALUE_INTERNAL_LOCK] = false;\n                if (typeof value === \"string\") {\n                    streamableValue.append(value);\n                } else {\n                    streamableValue.update(value);\n                }\n                streamableValue[STREAMABLE_VALUE_INTERNAL_LOCK] = true;\n            }\n            streamableValue[STREAMABLE_VALUE_INTERNAL_LOCK] = false;\n            streamableValue.done();\n        } catch (e) {\n            streamableValue[STREAMABLE_VALUE_INTERNAL_LOCK] = false;\n            streamableValue.error(e);\n        }\n    })();\n    return streamableValue;\n}\nfunction createStreamableValueImpl(initialValue) {\n    let closed = false;\n    let locked = false;\n    let resolvable = createResolvablePromise();\n    let currentValue = initialValue;\n    let currentError;\n    let currentPromise = resolvable.promise;\n    let currentPatchValue;\n    function assertStream(method) {\n        if (closed) {\n            throw new Error(method + \": Value stream is already closed.\");\n        }\n        if (locked) {\n            throw new Error(method + \": Value stream is locked and cannot be updated.\");\n        }\n    }\n    let warningTimeout;\n    function warnUnclosedStream() {\n        if (true) {\n            if (warningTimeout) {\n                clearTimeout(warningTimeout);\n            }\n            warningTimeout = setTimeout(()=>{\n                console.warn(\"The streamable value has been slow to update. This may be a bug or a performance issue or you forgot to call `.done()`.\");\n            }, HANGING_STREAM_WARNING_TIME_MS);\n        }\n    }\n    warnUnclosedStream();\n    function createWrapped(initialChunk) {\n        let init;\n        if (currentError !== void 0) {\n            init = {\n                error: currentError\n            };\n        } else {\n            if (currentPatchValue && !initialChunk) {\n                init = {\n                    diff: currentPatchValue\n                };\n            } else {\n                init = {\n                    curr: currentValue\n                };\n            }\n        }\n        if (currentPromise) {\n            init.next = currentPromise;\n        }\n        if (initialChunk) {\n            init.type = STREAMABLE_VALUE_TYPE;\n        }\n        return init;\n    }\n    function updateValueStates(value) {\n        currentPatchValue = void 0;\n        if (typeof value === \"string\") {\n            if (typeof currentValue === \"string\") {\n                if (value.startsWith(currentValue)) {\n                    currentPatchValue = [\n                        0,\n                        value.slice(currentValue.length)\n                    ];\n                }\n            }\n        }\n        currentValue = value;\n    }\n    const streamable2 = {\n        set [STREAMABLE_VALUE_INTERNAL_LOCK] (state){\n            locked = state;\n        },\n        get value () {\n            return createWrapped(true);\n        },\n        update (value) {\n            assertStream(\".update()\");\n            const resolvePrevious = resolvable.resolve;\n            resolvable = createResolvablePromise();\n            updateValueStates(value);\n            currentPromise = resolvable.promise;\n            resolvePrevious(createWrapped());\n            warnUnclosedStream();\n            return streamable2;\n        },\n        append (value) {\n            assertStream(\".append()\");\n            if (typeof currentValue !== \"string\" && typeof currentValue !== \"undefined\") {\n                throw new Error(`.append(): The current value is not a string. Received: ${typeof currentValue}`);\n            }\n            if (typeof value !== \"string\") {\n                throw new Error(`.append(): The value is not a string. Received: ${typeof value}`);\n            }\n            const resolvePrevious = resolvable.resolve;\n            resolvable = createResolvablePromise();\n            if (typeof currentValue === \"string\") {\n                currentPatchValue = [\n                    0,\n                    value\n                ];\n                currentValue = currentValue + value;\n            } else {\n                currentPatchValue = void 0;\n                currentValue = value;\n            }\n            currentPromise = resolvable.promise;\n            resolvePrevious(createWrapped());\n            warnUnclosedStream();\n            return streamable2;\n        },\n        error (error) {\n            assertStream(\".error()\");\n            if (warningTimeout) {\n                clearTimeout(warningTimeout);\n            }\n            closed = true;\n            currentError = error;\n            currentPromise = void 0;\n            resolvable.resolve({\n                error\n            });\n            return streamable2;\n        },\n        done (...args) {\n            assertStream(\".done()\");\n            if (warningTimeout) {\n                clearTimeout(warningTimeout);\n            }\n            closed = true;\n            currentPromise = void 0;\n            if (args.length) {\n                updateValueStates(args[0]);\n                resolvable.resolve(createWrapped());\n                return streamable2;\n            }\n            resolvable.resolve({});\n            return streamable2;\n        }\n    };\n    return streamable2;\n}\n //# sourceMappingURL=rsc-server.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvLnBucG0vYWlAMy40LjMzX29wZW5haUA0Ljc5LjFfd3NAOC4xOC4wX3pvZEAzLjI0LjFfX3JlYWN0QDE4LjMuMV9zc3dyQDIuMS4wX3N2ZWx0ZUA1LjE5LjBfX3N2ZWx0ZUA1X3BkY2c3bmxhYmJqdXg0a2o1cmp5aGxreTJpL25vZGVfbW9kdWxlcy9haS9yc2MvZGlzdC9yc2Mtc2VydmVyLm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQStCO0FBQ0c7O0FDUTNCLFNBQVNFO0lBS2QsSUFBSUM7SUFDSixJQUFJQztJQUVKLE1BQU1DLFVBQVUsSUFBSUMsUUFBVyxDQUFDQyxLQUFLQztRQUNuQ0wsVUFBVUk7UUFDVkgsU0FBU0k7SUFDWDtJQUVBLE9BQU87UUFDTEg7UUFDQUY7UUFDQUM7SUFDRjtBQUNGOztBQ3JCTyxJQUFNSyxhQUFhLENBQUNDLFFBQ3pCLE9BQU9BLFVBQVU7O0FGT25CLElBQU1DLHNCQUFzQixJQUFJViwwREFBaUJBO0FBU2pELFNBQVNXLHVCQUF1QkMsT0FBQTtJQUM5QixNQUFNQyxRQUFRSCxvQkFBb0JJLFFBQUE7SUFDbEMsSUFBSSxDQUFDRCxPQUFPO1FBQ1YsTUFBTSxJQUFJRSxNQUFNSDtJQUNsQjtJQUNBLE9BQU9DO0FBQ1Q7QUFFTyxTQUFTRyxZQUNkLEVBQUVDLE9BQUFBLE1BQUEsRUFBT0MsT0FBQSxFQUFRLEVBQ2pCQyxFQUFBO0lBRUEsT0FBT1Qsb0JBQW9CVSxHQUFBLENBQ3pCO1FBQ0VDLGNBQWNDLEtBQUtDLEtBQUEsQ0FBTUQsS0FBS0UsU0FBQSxDQUFVUDtRQUFNO1FBQzlDUSxlQUFlUjtRQUNmUyxRQUFRO1FBQ1JSO0lBQ0YsR0FDQUM7QUFFSjtBQUVPLFNBQVNRO0lBQ2QsTUFBTWQsUUFBUUYsdUJBQXVCO0lBQ3JDLE9BQU9FLE1BQU1lLG9CQUFBO0FBQ2Y7QUFLTyxTQUFTQztJQUNkLE1BQU1oQixRQUFRRix1QkFBdUI7SUFDckNFLE1BQU1hLE1BQUEsR0FBUztBQUNqQjtBQWdCQSxTQUFTSSxXQUFBLEdBQ0pDLElBQUE7SUFFSCxNQUFNbEIsUUFBUUYsdUJBQ1o7SUFHRixJQUFJb0IsS0FBS0MsTUFBQSxHQUFTLEdBQUc7UUFDbkIsTUFBTUMsTUFBTUYsSUFBQSxDQUFLLEVBQUM7UUFDbEIsSUFBSSxPQUFPbEIsTUFBTVEsWUFBQSxLQUFpQixVQUFVO1lBQzFDLE1BQU0sSUFBSU4sTUFDUixzQkFBc0JtQixPQUNwQkQsS0FDRDtRQUVMO1FBQ0EsT0FBT3BCLE1BQU1RLFlBQUEsQ0FBYVksSUFBc0M7SUFDbEU7SUFFQSxPQUFPcEIsTUFBTVEsWUFBQTtBQUNmO0FBMEJBLFNBQVNjLGtCQUFBLEdBQ0pKLElBQUE7SUFRSCxNQUFNbEIsUUFBUUYsdUJBQ1o7SUFHRixJQUFJRSxNQUFNYSxNQUFBLEVBQVE7UUFDaEIsTUFBTSxJQUFJWCxNQUNSO0lBRUo7SUFFQSxJQUFJLENBQUNGLE1BQU1lLG9CQUFBLEVBQXNCO1FBQy9CLE1BQU0sRUFBRXhCLE9BQUEsRUFBU0YsT0FBQSxFQUFRLEdBQUlEO1FBQzdCWSxNQUFNZSxvQkFBQSxHQUF1QnhCO1FBQzdCUyxNQUFNdUIsb0JBQUEsR0FBdUJsQztJQUMvQjtJQUVBLFNBQVNtQyxTQUFTQyxRQUFBLEVBQTZCQyxJQUFBO1FBaEpqRCxJQUFBQyxLQUFBQztRQWlKSSxJQUFJVixLQUFLQyxNQUFBLEdBQVMsR0FBRztZQUNuQixJQUFJLE9BQU9uQixNQUFNUSxZQUFBLEtBQWlCLFVBQVU7Z0JBQzFDLE1BQU1ZLE1BQU1GLElBQUEsQ0FBSyxFQUFDO2dCQUNsQixNQUFNLElBQUloQixNQUNSLHlCQUF5Qm1CLE9BQ3ZCRCxLQUNEO1lBRUw7UUFDRjtRQUVBLElBQUl6QixXQUFXOEIsV0FBVztZQUN4QixJQUFJUCxLQUFLQyxNQUFBLEdBQVMsR0FBRztnQkFDbkJuQixNQUFNUSxZQUFBLENBQWFVLElBQUEsQ0FBSyxFQUFFLElBQUlPLFNBQVN6QixNQUFNUSxZQUFBLENBQWFVLElBQUEsQ0FBSyxFQUFFLENBQUM7WUFDcEUsT0FBTztnQkFDTGxCLE1BQU1RLFlBQUEsR0FBZWlCLFNBQVN6QixNQUFNUSxZQUFZO1lBQ2xEO1FBQ0YsT0FBTztZQUNMLElBQUlVLEtBQUtDLE1BQUEsR0FBUyxHQUFHO2dCQUNuQm5CLE1BQU1RLFlBQUEsQ0FBYVUsSUFBQSxDQUFLLEVBQUUsSUFBSU87WUFDaEMsT0FBTztnQkFDTHpCLE1BQU1RLFlBQUEsR0FBZWlCO1lBQ3ZCO1FBQ0Y7UUFFQUcsQ0FBQUEsS0FBQSxDQUFBRCxNQUFBM0IsTUFBTUssT0FBQSxFQUFRd0IsWUFBQSxLQUFkLGdCQUFBRCxHQUFBRSxJQUFBLENBQUFILEtBQTZCO1lBQzNCUCxLQUFLRixLQUFLQyxNQUFBLEdBQVMsSUFBSUQsSUFBQSxDQUFLLEVBQUMsR0FBSTtZQUNqQ2QsT0FBT0osTUFBTVEsWUFBQTtZQUNia0I7UUFDRjtJQUNGO0lBRUEsTUFBTUssZUFBZTtRQUNuQkMsS0FBSztZQUNILElBQUlkLEtBQUtDLE1BQUEsR0FBUyxHQUFHO2dCQUNuQixNQUFNQyxNQUFNRixJQUFBLENBQUssRUFBQztnQkFDbEIsSUFBSSxPQUFPbEIsTUFBTVEsWUFBQSxLQUFpQixVQUFVO29CQUMxQyxNQUFNLElBQUlOLE1BQ1Isc0JBQXNCbUIsT0FDcEJELEtBQ0Q7Z0JBRUw7Z0JBQ0EsT0FBT3BCLE1BQU1RLFlBQUEsQ0FBYVksSUFBRztZQUMvQjtZQUVBLE9BQU9wQixNQUFNUSxZQUFBO1FBQ2Y7UUFDQXlCLFFBQVEsU0FBU0EsT0FBT0MsVUFBQTtZQUN0QlYsU0FBU1UsWUFBWTtRQUN2QjtRQUNBUixNQUFNLFNBQVNBLEtBQUEsR0FBUVMsUUFBQTtZQUNyQixJQUFJQSxTQUFTaEIsTUFBQSxHQUFTLEdBQUc7Z0JBQ3ZCSyxTQUFTVyxRQUFBLENBQVMsRUFBQyxFQUF3QjtZQUM3QztZQUVBLE1BQU1DLFFBQXNCbEQsK0NBQUEsQ0FBS2MsTUFBTVksYUFBQSxFQUFlWixNQUFNUSxZQUFZO1lBQ3hFUixNQUFNdUIsb0JBQUEsQ0FBc0JhO1FBQzlCO0lBQ0Y7SUFFQSxPQUFPTDtBQUNUOztBRzdNdUI7QUFDWTtBQW9JN0I7SUFwSFNVLGNBQUFBLDBGQUFBQTtBQUFmLDBCQUNFLEVBQ0VDLE1BQUEsRUFDQXJDLE9BQUEsRUFDRixFQUNBRCxNQUFBLEtBQ0djLElBQUE7SUFHSCxPQUFPLE1BQU1mLFlBQ1g7UUFDRUMsT0FBQUE7UUFDQUM7SUFDRixHQUNBO1FBQ0UsTUFBTXNDLFNBQVMsTUFBTUQsVUFBVXhCO1FBQy9CRjtRQUNBLE9BQU87WUFBQ0Y7WUFBd0M2QjtTQUFNO0lBQ3hEO0FBRUo7QUFFQSxTQUFTQyxXQUNQRixNQUFBLEVBQ0FyQyxPQUFBO0lBRUEsT0FBT29DLFlBQVlJLElBQUEsQ0FBSyxNQUFNO1FBQUVIO1FBQVFyQztJQUFRO0FBQ2xEO0FBRU8sU0FBU3lDLFNBSWQsRUFDQUMsT0FBQSxFQUNBQyxjQUFBLEVBQ0FDLGNBQUEsRUFFQXBCLFlBQUEsRUFDQXFCLFlBQUEsRUFDRjtJQTBDRSxNQUFNQyxpQkFBdUMsQ0FBQztJQUM5QyxVQUFXQyxTQUFRTCxRQUFTO1FBQzFCSSxjQUFBLENBQWVDLE1BQUksR0FBSVIsV0FBV0csT0FBQSxDQUFRSyxNQUFJLEVBQUc7WUFDL0N2QjtRQUNGO0lBQ0Y7SUFFQSxNQUFNd0IscUJBQXFCSCxlQUN2Qk4sV0FBV00sY0FBYyxDQUFDLEtBQzFCO0lBRUosTUFBTUksS0FBNEMsT0FBTUM7UUFoSDFELElBQUE1QixLQUFBQztRQWlISSxJQUFJLHVNQUFtQlUsRUFBRTtZQUl2QixNQUFNLElBQUlwQyxNQUNSO1FBRUo7UUFFQSxJQUFJc0QsVUFBQSxDQUFVN0IsTUFBQTRCLE1BQU1OLGNBQUEsS0FBTixPQUFBdEIsTUFBd0JzQjtRQUN0QyxJQUFJUSxVQUFBLENBQVU3QixLQUFBMkIsTUFBTVAsY0FBQSxLQUFOLE9BQUFwQixLQUF3Qm9CO1FBQ3RDLElBQUlVLGVBQWU7UUFFbkIsSUFBSUwsb0JBQW9CO1lBQ3RCLE1BQU0sQ0FBQ00saUJBQWlCQyxXQUFVLEdBQUksTUFBTVAsbUJBQW1CSTtZQUMvRCxJQUFJRyxlQUFlLFFBQVc7Z0JBQzVCRixlQUFlQztnQkFDZkgsVUFBVUk7WUFDWjtRQUNGO1FBRUEsT0FDRSxnQkFBQXBCLHNEQUFBQSxDQUFDRCwrREFBa0JBLEVBQWxCO1lBQ0NZO1lBQ0FFO1lBQ0FKLGdCQUFnQk87WUFDaEJSLGdCQUFnQlM7WUFDaEJJLHFCQUFxQkg7WUFFcEJJLFVBQUFQLE1BQU1PLFFBQUE7UUFBQTtJQUdiO0lBRUEsT0FBT1I7QUFDVDs7QUNuSjhCOztBQ0RIO0FBRTNCLElBQU1GLE9BQU87QUFDYixJQUFNYSxTQUFTLG1CQUFtQmIsS0FBSTtBQUN0QyxJQUFNYyxTQUFTQyxPQUFPQyxHQUFBLENBQUlIO0FBSjFCLElBQUF0QztBQU1PLElBQU0wQyxnQkFBTixjQUE0Qkwsd0RBQVVBO0lBTzNDTSxZQUFZLEVBQ1ZDLEdBQUEsRUFDQUMsVUFBQSxFQUNBQyxVQUFBLEVBQ0FDLEtBQUEsRUFDQTNFLFVBQVUyRSxTQUFTLE9BQ2Ysc0JBQXNCSCxJQUFHLElBQUtDLFdBQVUsR0FBSUMsV0FBVSxJQUN0RCxzQkFBc0JGLElBQUcsSUFBS0csTUFBSyxHQUN6QyxDQU1HO1FBQ0QsTUFBTTtZQUFFdEI7WUFBTXJEO1lBQVMyRTtRQUFNO1FBckIvQixLQUFrQi9DLEdBQUEsR0FBVTtRQXVCMUIsS0FBSzRDLEdBQUEsR0FBTUE7UUFDWCxLQUFLQyxVQUFBLEdBQWFBO1FBQ2xCLEtBQUtDLFVBQUEsR0FBYUE7SUFDcEI7SUFFQSxPQUFPRSxXQUFXQyxLQUFBLEVBQXdDO1FBQ3hELE9BQU9aLHdEQUFVQSxDQUFDYSxTQUFBLENBQVVELE9BQU9YO0lBQ3JDO0lBQUE7O0dBQUEsR0FLQSxPQUFPYSxnQkFBZ0JGLEtBQUEsRUFBd0M7UUFDN0QsT0FDRUEsaUJBQWlCMUUsU0FDakIwRSxNQUFNeEIsSUFBQSxLQUFTQSxRQUNmLE9BQVF3QixNQUF3QkwsR0FBQSxLQUFRLFlBQ3RDSyxDQUFBQSxNQUF3QkosVUFBQSxJQUFjLFFBQ3RDLE9BQVFJLE1BQXdCSixVQUFBLEtBQWUsYUFDL0NJLENBQUFBLE1BQXdCSCxVQUFBLElBQWMsUUFDdEMsT0FBUUcsTUFBd0JILFVBQUEsS0FBZTtJQUVyRDtJQUFBOztHQUFBLEdBS0FNLFNBQVM7UUFDUCxPQUFPO1lBQ0wzQixNQUFNLEtBQUtBLElBQUE7WUFDWHJELFNBQVMsS0FBS0EsT0FBQTtZQUNkd0UsS0FBSyxLQUFLQSxHQUFBO1lBQ1ZDLFlBQVksS0FBS0EsVUFBQTtZQUNqQkMsWUFBWSxLQUFLQSxVQUFBO1lBQ2pCQyxPQUFPLEtBQUtBLEtBQUE7UUFDZDtJQUNGO0FBQ0Y7QUE1RG9CL0MsS0FBQXVDOztBQ0xwQixlQUFzQmMsU0FBUyxFQUM3QlQsR0FBQSxFQUNBVSxzQkFBc0JDLEtBQUEsRUFDeEI7SUFMQSxJQUFBdkQ7SUFZRSxNQUFNd0QsVUFBVVosSUFBSWEsUUFBQTtJQUNwQixJQUFJO1FBQ0YsTUFBTUMsV0FBVyxNQUFNSixvQkFBb0JFO1FBRTNDLElBQUksQ0FBQ0UsU0FBU0MsRUFBQSxFQUFJO1lBQ2hCLE1BQU0sSUFBSWpCLGNBQWM7Z0JBQ3RCRSxLQUFLWTtnQkFDTFgsWUFBWWEsU0FBU0UsTUFBQTtnQkFDckJkLFlBQVlZLFNBQVNaLFVBQUE7WUFDdkI7UUFDRjtRQUVBLE9BQU87WUFDTGUsTUFBTSxJQUFJQyxXQUFXLE1BQU1KLFNBQVNLLFdBQUE7WUFDcENDLFVBQUEsQ0FBVWhFLE1BQUEwRCxTQUFTTyxPQUFBLENBQVE1RCxHQUFBLENBQUksZUFBYyxLQUFuQyxPQUFBTCxNQUF3QztRQUNwRDtJQUNGLFNBQVNpRCxPQUFPO1FBQ2QsSUFBSVAsY0FBY00sVUFBQSxDQUFXQyxRQUFRO1lBQ25DLE1BQU1BO1FBQ1I7UUFFQSxNQUFNLElBQUlQLGNBQWM7WUFBRUUsS0FBS1k7WUFBU1QsT0FBT0U7UUFBTTtJQUN2RDtBQUNGOztBQ25DQSxJQUFNaUIscUJBQXFCO0lBQ3pCO1FBQUVGLFVBQVU7UUFBc0JHLE9BQU87WUFBQztZQUFNO1lBQU07U0FBSTtJQUFFO0lBQzVEO1FBQUVILFVBQVU7UUFBc0JHLE9BQU87WUFBQztZQUFNO1lBQU07WUFBTTtTQUFJO0lBQUU7SUFDbEU7UUFBRUgsVUFBVTtRQUF1QkcsT0FBTztZQUFDO1lBQU07U0FBSTtJQUFFO0lBQ3ZEO1FBQUVILFVBQVU7UUFBdUJHLE9BQU87WUFBQztZQUFNO1lBQU07WUFBTTtTQUFJO0lBQUU7Q0FDckU7QUFFTyxTQUFTQyxvQkFDZEMsS0FBQTtJQUVBLFdBQVcsRUFBRUYsS0FBQSxFQUFPSCxRQUFBLEVBQVMsSUFBS0UsbUJBQW9CO1FBQ3BELElBQ0VHLE1BQU03RSxNQUFBLElBQVUyRSxNQUFNM0UsTUFBQSxJQUN0QjJFLE1BQU1HLEtBQUEsQ0FBTSxDQUFDQyxNQUFNQyxRQUFVSCxLQUFBLENBQU1HLE1BQUssS0FBTUQsT0FDOUM7WUFDQSxPQUFPUDtRQUNUO0lBQ0Y7SUFFQSxPQUFPO0FBQ1Q7O0FDakJPOztBQ0hvQjtBQUUzQixJQUFNdkMsUUFBTztBQUNiLElBQU1hLFVBQVMsbUJBQW1CYixNQUFJO0FBQ3RDLElBQU1jLFVBQVNDLE9BQU9DLEdBQUEsQ0FBSUg7QUFKMUIsSUFBQXRDO0FBTU8sSUFBTTJFLDBCQUFOLGNBQXNDdEMsd0RBQUFBO0lBSzNDTSxZQUFZLEVBQ1ZpQyxPQUFBLEVBQ0E3QixLQUFBLEVBQ0EzRSxVQUFVLCtGQUErRixPQUFPd0csUUFBTyxJQUN6SCxDQUlHO1FBQ0QsTUFBTTtZQUFFbkQsTUFBQUE7WUFBTXJEO1lBQVMyRTtRQUFNO1FBYi9CLEtBQWtCL0MsSUFBQUEsR0FBVTtRQWUxQixLQUFLNEUsT0FBQSxHQUFVQTtJQUNqQjtJQUVBLE9BQU81QixXQUFXQyxLQUFBLEVBQWtEO1FBQ2xFLE9BQU9aLHdEQUFBQSxDQUFXYSxTQUFBLENBQVVELE9BQU9YO0lBQ3JDO0lBQUE7O0dBQUEsR0FLQSxPQUFPdUMsMEJBQ0w1QixLQUFBLEVBQ2tDO1FBQ2xDLE9BQ0VBLGlCQUFpQjFFLFNBQ2pCMEUsTUFBTXhCLElBQUEsS0FBU0EsU0FDZHdCLE1BQWtDMkIsT0FBQSxJQUFXO0lBRWxEO0lBQUE7O0dBQUEsR0FLQXhCLFNBQVM7UUFDUCxPQUFPO1lBQ0wzQixNQUFNLEtBQUtBLElBQUE7WUFDWHJELFNBQVMsS0FBS0EsT0FBQTtZQUNkMEcsT0FBTyxLQUFLQSxLQUFBO1lBQ1ovQixPQUFPLEtBQUtBLEtBQUE7WUFDWjZCLFNBQVMsS0FBS0EsT0FBQTtRQUNoQjtJQUNGO0FBQ0Y7QUEvQ29CNUUsTUFBQXVDOztBREZGO0FBVVgsSUFBTXlDLG9CQUE0Q0Qsa0NBQUNBLENBQUNFLEtBQUEsQ0FBTTtJQUMvREYsa0NBQUNBLENBQUNHLE1BQUE7SUFDRkgsa0NBQUNBLENBQUNJLFVBQUEsQ0FBV3JCO0lBQ2JpQixrQ0FBQ0EsQ0FBQ0ksVUFBQSxDQUFXQztJQUNiTCxrQ0FBQ0EsQ0FBQ00sTUFBQTtJQUVBLENBQUNwSDtRQXJCTCxJQUFBK0IsS0FBQUM7UUFzQk0sUUFBQUEsS0FBQSxDQUFBRCxNQUFBc0YsV0FBV0MsTUFBQSxLQUFYLGdCQUFBdkYsSUFBbUJ3RixRQUFBLENBQVN2SCxNQUFBLEtBQTVCLE9BQUFnQyxLQUFzQztJQUFBLEdBQ3hDO1FBQUU3QixTQUFTO0lBQW1CO0NBRWpDO0FBUU0sU0FBU3FILGlDQUFpQ2IsT0FBQTtJQUMvQyxJQUFJLE9BQU9BLFlBQVksVUFBVTtRQUMvQixPQUFPQTtJQUNUO0lBRUEsSUFBSUEsbUJBQW1CUSxhQUFhO1FBQ2xDLE9BQU9WLGlGQUF5QkEsQ0FBQyxJQUFJWixXQUFXYztJQUNsRDtJQUVBLE9BQU9GLGlGQUF5QkEsQ0FBQ0U7QUFDbkM7QUFRTyxTQUFTYywrQkFDZGQsT0FBQTtJQUVBLElBQUlBLG1CQUFtQmQsWUFBWTtRQUNqQyxPQUFPYztJQUNUO0lBRUEsSUFBSSxPQUFPQSxZQUFZLFVBQVU7UUFDL0IsSUFBSTtZQUNGLE9BQU9ILGlGQUF5QkEsQ0FBQ0c7UUFDbkMsU0FBUzNCLE9BQU87WUFDZCxNQUFNLElBQUkwQix3QkFBd0I7Z0JBQ2hDdkcsU0FDRTtnQkFDRndHO2dCQUNBN0IsT0FBT0U7WUFDVDtRQUNGO0lBQ0Y7SUFFQSxJQUFJMkIsbUJBQW1CUSxhQUFhO1FBQ2xDLE9BQU8sSUFBSXRCLFdBQVdjO0lBQ3hCO0lBRUEsTUFBTSxJQUFJRCx3QkFBd0I7UUFBRUM7SUFBUTtBQUM5QztBQVFPLFNBQVNlLHdCQUF3QkMsVUFBQTtJQUN0QyxJQUFJO1FBQ0YsT0FBTyxJQUFJQyxjQUFjQyxNQUFBLENBQU9GO0lBQ2xDLFNBQVMzQyxPQUFPO1FBQ2QsTUFBTSxJQUFJMUUsTUFBTTtJQUNsQjtBQUNGOztBRTFGMkI7QUFFM0IsSUFBTWtELFFBQU87QUFDYixJQUFNYSxVQUFTLG1CQUFtQmIsTUFBSTtBQUN0QyxJQUFNYyxVQUFTQyxPQUFPQyxHQUFBLENBQUlIO0FBSjFCLElBQUF0QztBQU1PLElBQU0rRiwwQkFBTixjQUFzQzFELHdEQUFBQTtJQUszQ00sWUFBWSxFQUNWcUQsSUFBQSxFQUNBNUgsVUFBVSwwQkFBMEI0SCxLQUFJLDREQUMxQyxDQUdHO1FBQ0QsTUFBTTtZQUFFdkUsTUFBQUE7WUFBTXJEO1FBQVE7UUFYeEIsS0FBa0I0QixJQUFBQSxHQUFVO1FBYTFCLEtBQUtnRyxJQUFBLEdBQU9BO0lBQ2Q7SUFFQSxPQUFPaEQsV0FBV0MsS0FBQSxFQUFrRDtRQUNsRSxPQUFPWix3REFBQUEsQ0FBV2EsU0FBQSxDQUFVRCxPQUFPWDtJQUNyQztJQUFBOztHQUFBLEdBS0EsT0FBTzJELDBCQUNMaEQsS0FBQSxFQUNrQztRQUNsQyxPQUNFQSxpQkFBaUIxRSxTQUNqQjBFLE1BQU14QixJQUFBLEtBQVNBLFNBQ2YsT0FBUXdCLE1BQWtDK0MsSUFBQSxLQUFTO0lBRXZEO0lBQUE7O0dBQUEsR0FLQTVDLFNBQVM7UUFDUCxPQUFPO1lBQ0wzQixNQUFNLEtBQUtBLElBQUE7WUFDWHJELFNBQVMsS0FBS0EsT0FBQTtZQUNkMEcsT0FBTyxLQUFLQSxLQUFBO1lBRVprQixNQUFNLEtBQUtBLElBQUE7UUFDYjtJQUNGO0FBQ0Y7QUE3Q29CaEcsTUFBQXVDOztBQ1BiLFNBQVMyRCxhQUFhQyxPQUFBO0lBSTNCLElBQUk7UUFDRixNQUFNLENBQUNDLFFBQVFDLGNBQWEsR0FBSUYsUUFBUUcsS0FBQSxDQUFNO1FBQzlDLE9BQU87WUFDTHRDLFVBQVVvQyxPQUFPRSxLQUFBLENBQU0sSUFBRyxDQUFFLEVBQUMsQ0FBRUEsS0FBQSxDQUFNLElBQUcsQ0FBRSxFQUFDO1lBQzNDRDtRQUNGO0lBQ0YsU0FBU3BELE9BQU87UUFDZCxPQUFPO1lBQ0xlLFVBQVU7WUFDVnFDLGVBQWU7UUFDakI7SUFDRjtBQUNGOztBQ0lBLGVBQXNCRSw2QkFBNkIsRUFDakRDLE1BQUEsRUFDQUMseUJBQXlCLE1BQ3pCQyxtQkFBbUIsSUFBTSxPQUN6QkMseUJBQXlCdEQsUUFBQSxFQUMzQjtJQU1FLE1BQU11RCxtQkFBbUIsTUFBTUMsZUFDN0JMLE9BQU9NLFFBQUEsRUFDUEgsd0JBQ0FGLHdCQUNBQztJQUdGLE9BQU87V0FDREYsT0FBT08sTUFBQSxJQUFVLE9BQ2pCO1lBQUM7Z0JBQUVmLE1BQU07Z0JBQW1CcEIsU0FBUzRCLE9BQU9PLE1BQUE7WUFBTztTQUFDLEdBQ3BELEVBQUM7V0FDRlAsT0FBT00sUUFBQSxDQUFTRSxHQUFBLENBQUksQ0FBQTVJLFVBQ3JCNkksOEJBQThCN0ksU0FBU3dJO0tBRTNDO0FBQ0Y7QUFTTyxTQUFTSyw4QkFDZDdJLE9BQUEsRUFDQXdJLGdCQUFBO0lBS0EsTUFBTVosT0FBTzVILFFBQVE0SCxJQUFBO0lBQ3JCLE9BQVFBO1FBQ04sS0FBSztZQUFVO2dCQUNiLE9BQU87b0JBQ0xBLE1BQU07b0JBQ05wQixTQUFTeEcsUUFBUXdHLE9BQUE7b0JBQ2pCc0Msa0JBQWtCOUksUUFBUStJLDZCQUFBO2dCQUM1QjtZQUNGO1FBRUEsS0FBSztZQUFRO2dCQUNYLElBQUksT0FBTy9JLFFBQVF3RyxPQUFBLEtBQVksVUFBVTtvQkFDdkMsT0FBTzt3QkFDTG9CLE1BQU07d0JBQ05wQixTQUFTOzRCQUFDO2dDQUFFd0MsTUFBTTtnQ0FBUUMsTUFBTWpKLFFBQVF3RyxPQUFBOzRCQUFRO3lCQUFDO3dCQUNqRHNDLGtCQUFrQjlJLFFBQVErSSw2QkFBQTtvQkFDNUI7Z0JBQ0Y7Z0JBRUEsT0FBTztvQkFDTG5CLE1BQU07b0JBQ05wQixTQUFTeEcsUUFBUXdHLE9BQUEsQ0FDZG9DLEdBQUEsQ0FBSSxDQUFBTSxPQUFRQywrQkFBK0JELE1BQU1WLG1CQUVqRFksTUFBQSxDQUFPLENBQUFGLE9BQVFBLEtBQUtGLElBQUEsS0FBUyxVQUFVRSxLQUFLRCxJQUFBLEtBQVM7b0JBQ3hESCxrQkFBa0I5SSxRQUFRK0ksNkJBQUE7Z0JBQzVCO1lBQ0Y7UUFFQSxLQUFLO1lBQWE7Z0JBQ2hCLElBQUksT0FBTy9JLFFBQVF3RyxPQUFBLEtBQVksVUFBVTtvQkFDdkMsT0FBTzt3QkFDTG9CLE1BQU07d0JBQ05wQixTQUFTOzRCQUFDO2dDQUFFd0MsTUFBTTtnQ0FBUUMsTUFBTWpKLFFBQVF3RyxPQUFBOzRCQUFRO3lCQUFDO3dCQUNqRHNDLGtCQUFrQjlJLFFBQVErSSw2QkFBQTtvQkFDNUI7Z0JBQ0Y7Z0JBRUEsT0FBTztvQkFDTG5CLE1BQU07b0JBQ05wQixTQUFTeEcsUUFBUXdHLE9BQUEsQ0FDZDRDLE1BQUE7b0JBRUMsQ0FBQUYsT0FBUUEsS0FBS0YsSUFBQSxLQUFTLFVBQVVFLEtBQUtELElBQUEsS0FBUyxJQUUvQ0wsR0FBQSxDQUFJLENBQUFNO3dCQUNILE1BQU0sRUFBRUgsNkJBQUEsRUFBK0IsR0FBR00sTUFBSyxHQUFJSDt3QkFDbkQsT0FBTzs0QkFDTCxHQUFHRyxJQUFBOzRCQUNIUCxrQkFBa0JDO3dCQUNwQjtvQkFDRjtvQkFDRkQsa0JBQWtCOUksUUFBUStJLDZCQUFBO2dCQUM1QjtZQUNGO1FBRUEsS0FBSztZQUFRO2dCQUNYLE9BQU87b0JBQ0xuQixNQUFNO29CQUNOcEIsU0FBU3hHLFFBQVF3RyxPQUFBLENBQVFvQyxHQUFBLENBQUksQ0FBQU0sT0FBUzs0QkFDcENGLE1BQU07NEJBQ05NLFlBQVlKLEtBQUtJLFVBQUE7NEJBQ2pCQyxVQUFVTCxLQUFLSyxRQUFBOzRCQUNmM0csUUFBUXNHLEtBQUt0RyxNQUFBOzRCQUNiNEQsU0FBUzBDLEtBQUtNLG9CQUFBOzRCQUNkQyxTQUFTUCxLQUFLTyxPQUFBOzRCQUNkWCxrQkFBa0JJLEtBQUtILDZCQUFBO3dCQUN6QjtvQkFDQUQsa0JBQWtCOUksUUFBUStJLDZCQUFBO2dCQUM1QjtZQUNGO1FBRUE7WUFBUztnQkFDUCxNQUFNVyxtQkFBMEI5QjtnQkFDaEMsTUFBTSxJQUFJRCx3QkFBd0I7b0JBQUVDLE1BQU04QjtnQkFBaUI7WUFDN0Q7SUFDRjtBQUNGO0FBS0EsZUFBZWpCLGVBQ2JDLFFBQUEsRUFDQUgsc0JBQUEsRUFDQUYsc0JBQUEsRUFDQUMsZ0JBQUE7SUFFQSxNQUFNcUIsT0FBT2pCLFNBQ1ZVLE1BQUEsQ0FBTyxDQUFBcEosVUFBV0EsUUFBUTRILElBQUEsS0FBUyxRQUNuQ2dCLEdBQUEsQ0FBSSxDQUFBNUksVUFBV0EsUUFBUXdHLE9BQU8sRUFDOUI0QyxNQUFBLENBQU8sQ0FBQzVDLFVBQ1BvRCxNQUFNQyxPQUFBLENBQVFyRCxVQUVmc0QsSUFBQSxHQUNBVixNQUFBLENBQ0MsQ0FBQ0YsT0FDQ0EsS0FBS0YsSUFBQSxLQUFTLFdBQVdFLEtBQUtGLElBQUEsS0FBUyxRQU0xQ0ksTUFBQSxDQUNDLENBQUNGLE9BQ0MsQ0FBRUEsQ0FBQUEsS0FBS0YsSUFBQSxLQUFTLFdBQVdYLDJCQUEyQixPQUV6RE8sR0FBQSxDQUFJLENBQUFNLE9BQVNBLEtBQUtGLElBQUEsS0FBUyxVQUFVRSxLQUFLakQsS0FBQSxHQUFRaUQsS0FBS3pELElBQUssRUFDNURtRCxHQUFBLENBQUksQ0FBQU0sT0FBQTtRQUVILE9BQU9BLFNBQVMsWUFDZkEsQ0FBQUEsS0FBS2EsVUFBQSxDQUFXLFlBQVliLEtBQUthLFVBQUEsQ0FBVyxTQUFRLElBQ2pELElBQUlDLElBQUlkLFFBQ1JBLE1BRUxFLE1BQUEsQ0FBTyxDQUFDbkQsUUFBd0JBLGlCQUFpQitELEtBSWpEWixNQUFBLENBQU8sQ0FBQTVFLE1BQU8sQ0FBQzhELGlCQUFpQjlEO0lBR25DLE1BQU15RixtQkFBbUIsTUFBTXhLLFFBQVF5SyxHQUFBLENBQ3JDUCxLQUFLZixHQUFBLENBQUksT0FBTXBFLE1BQVE7WUFDckJBO1lBQ0FpQixNQUFNLE1BQU04Qyx1QkFBdUI7Z0JBQUUvRDtZQUFJO1FBQzNDO0lBR0YsT0FBTzJGLE9BQU9DLFdBQUEsQ0FDWkgsaUJBQWlCckIsR0FBQSxDQUFJLENBQUMsRUFBRXBFLEdBQUEsRUFBS2lCLElBQUEsRUFBSyxHQUFNO1lBQUNqQixJQUFJYSxRQUFBO1lBQVlJO1NBQUs7QUFFbEU7QUFVQSxTQUFTMEQsK0JBQ1BELElBQUEsRUFDQVYsZ0JBQUE7SUFRQSxJQUFJVSxLQUFLRixJQUFBLEtBQVMsUUFBUTtRQUN4QixPQUFPO1lBQ0xBLE1BQU07WUFDTkMsTUFBTUMsS0FBS0QsSUFBQTtZQUNYSCxrQkFBa0JJLEtBQUtILDZCQUFBO1FBQ3pCO0lBQ0Y7SUFFQSxJQUFJbkQsV0FBK0JzRCxLQUFLdEQsUUFBQTtJQUN4QyxJQUFJSDtJQUNKLElBQUllO0lBQ0osSUFBSTZEO0lBRUosTUFBTXJCLE9BQU9FLEtBQUtGLElBQUE7SUFDbEIsT0FBUUE7UUFDTixLQUFLO1lBQ0h2RCxPQUFPeUQsS0FBS2pELEtBQUE7WUFDWjtRQUNGLEtBQUs7WUFDSFIsT0FBT3lELEtBQUt6RCxJQUFBO1lBQ1o7UUFDRjtZQUNFLE1BQU0sSUFBSXRGLE1BQU0sMEJBQTBCNkksS0FBSSxDQUFFO0lBQ3BEO0lBSUEsSUFBSTtRQUNGeEMsVUFBVSxPQUFPZixTQUFTLFdBQVcsSUFBSXVFLElBQUl2RSxRQUFRQTtJQUN2RCxTQUFTWixPQUFPO1FBQ2QyQixVQUFVZjtJQUNaO0lBS0EsSUFBSWUsbUJBQW1Cd0QsS0FBSztRQUUxQixJQUFJeEQsUUFBUThELFFBQUEsS0FBYSxTQUFTO1lBQ2hDLE1BQU0sRUFBRTFFLFVBQVUyRSxlQUFBLEVBQWlCdEMsYUFBQSxFQUFjLEdBQUlILGFBQ25EdEIsUUFBUW5CLFFBQUE7WUFHVixJQUFJa0YsbUJBQW1CLFFBQVF0QyxpQkFBaUIsTUFBTTtnQkFDcEQsTUFBTSxJQUFJOUgsTUFBTSxtQ0FBbUM2SSxLQUFJLENBQUU7WUFDM0Q7WUFFQXBELFdBQVcyRTtZQUNYRixpQkFBaUIvQywrQkFBK0JXO1FBQ2xELE9BQU87WUFNTCxNQUFNdUMsaUJBQWlCaEMsZ0JBQUEsQ0FBaUJoQyxRQUFRbkIsUUFBQSxHQUFVO1lBQzFELElBQUltRixnQkFBZ0I7Z0JBQ2xCSCxpQkFBaUJHLGVBQWUvRSxJQUFBO2dCQUNoQ0csWUFBQSxPQUFBQSxXQUFBQSxXQUFhNEUsZUFBZTVFLFFBQUE7WUFDOUIsT0FBTztnQkFDTHlFLGlCQUFpQjdEO1lBQ25CO1FBQ0Y7SUFDRixPQUFPO1FBR0w2RCxpQkFBaUIvQywrQkFBK0JkO0lBQ2xEO0lBSUEsT0FBUXdDO1FBQ04sS0FBSztZQUdILElBQUlwRCxZQUFZLFFBQVF5RSwwQkFBMEIzRSxZQUFZO2dCQUM1REUsV0FBV0ksb0JBQW9CcUU7WUFDakM7WUFFQSxPQUFPO2dCQUNMckIsTUFBTTtnQkFDTi9DLE9BQU9vRTtnQkFDUHpFO2dCQUNBa0Qsa0JBQWtCSSxLQUFLSCw2QkFBQTtZQUN6QjtRQUNGLEtBQUs7WUFFSCxJQUFJbkQsWUFBWSxNQUFNO2dCQUNwQixNQUFNLElBQUl6RixNQUFNLG9DQUFvQztZQUN0RDtZQUVBLE9BQU87Z0JBQ0w2SSxNQUFNO2dCQUNOdkQsTUFDRTRFLDBCQUEwQjNFLGFBQ3RCMkIsaUNBQWlDZ0Qsa0JBQ2pDQTtnQkFDTnpFO2dCQUNBa0Qsa0JBQWtCSSxLQUFLSCw2QkFBQTtZQUN6QjtJQUNKO0FBQ0Y7O0FDM1QyQjtBQUUzQixJQUFNMUYsUUFBTztBQUNiLElBQU1hLFVBQVMsbUJBQW1CYixNQUFJO0FBQ3RDLElBQU1jLFVBQVNDLE9BQU9DLEdBQUEsQ0FBSUg7QUFKMUIsSUFBQXRDO0FBTU8sSUFBTTZJLHVCQUFOLGNBQW1DeEcsd0RBQUFBO0lBTXhDTSxZQUFZLEVBQ1ZtRyxTQUFBLEVBQ0E3SyxLQUFBLEVBQ0FHLE9BQUEsRUFDRixDQUlHO1FBQ0QsTUFBTTtZQUNKcUQsTUFBQUE7WUFDQXJELFNBQVMsa0NBQWtDMEssVUFBUyxJQUFLMUssUUFBTztRQUNsRTtRQWpCRixLQUFrQjRCLElBQUFBLEdBQVU7UUFtQjFCLEtBQUs4SSxTQUFBLEdBQVlBO1FBQ2pCLEtBQUs3SyxLQUFBLEdBQVFBO0lBQ2Y7SUFFQSxPQUFPK0UsV0FBV0MsS0FBQSxFQUErQztRQUMvRCxPQUFPWix3REFBQUEsQ0FBV2EsU0FBQSxDQUFVRCxPQUFPWDtJQUNyQztJQUFBOztHQUFBLEdBS0EsT0FBT3lHLHVCQUF1QjlGLEtBQUEsRUFBK0M7UUFDM0UsT0FDRUEsaUJBQWlCMUUsU0FDakIwRSxNQUFNeEIsSUFBQSxLQUFTQSxTQUNmLE9BQVF3QixNQUErQjZGLFNBQUEsS0FBYyxZQUNyRCxPQUFRN0YsTUFBK0JoRixLQUFBLEtBQVU7SUFFckQ7SUFFQW1GLFNBQVM7UUFDUCxPQUFPO1lBQ0wzQixNQUFNLEtBQUtBLElBQUE7WUFDWHJELFNBQVMsS0FBS0EsT0FBQTtZQUNkMEcsT0FBTyxLQUFLQSxLQUFBO1lBRVpnRSxXQUFXLEtBQUtBLFNBQUE7WUFDaEI3SyxPQUFPLEtBQUtBLEtBQUE7UUFDZDtJQUNGO0FBQ0Y7QUFqRG9CK0IsTUFBQXVDOztBQ0RiLFNBQVN5RyxvQkFBb0IsRUFDbENDLFNBQUEsRUFDQUMsV0FBQSxFQUNBQyxJQUFBLEVBQ0FDLElBQUEsRUFDQUMsZUFBQSxFQUNBQyxnQkFBQSxFQUNBQyxhQUFBLEVBQ0FDLElBQUEsRUFDQUMsVUFBQSxFQUNGO0lBSUUsSUFBSVIsYUFBYSxNQUFNO1FBQ3JCLElBQUksQ0FBQ1MsT0FBT0MsU0FBQSxDQUFVVixZQUFZO1lBQ2hDLE1BQU0sSUFBSUoscUJBQXFCO2dCQUM3QkMsV0FBVztnQkFDWDdLLE9BQU9nTDtnQkFDUDdLLFNBQVM7WUFDWDtRQUNGO1FBRUEsSUFBSTZLLFlBQVksR0FBRztZQUNqQixNQUFNLElBQUlKLHFCQUFxQjtnQkFDN0JDLFdBQVc7Z0JBQ1g3SyxPQUFPZ0w7Z0JBQ1A3SyxTQUFTO1lBQ1g7UUFDRjtJQUNGO0lBRUEsSUFBSThLLGVBQWUsTUFBTTtRQUN2QixJQUFJLE9BQU9BLGdCQUFnQixVQUFVO1lBQ25DLE1BQU0sSUFBSUwscUJBQXFCO2dCQUM3QkMsV0FBVztnQkFDWDdLLE9BQU9pTDtnQkFDUDlLLFNBQVM7WUFDWDtRQUNGO0lBQ0Y7SUFFQSxJQUFJK0ssUUFBUSxNQUFNO1FBQ2hCLElBQUksT0FBT0EsU0FBUyxVQUFVO1lBQzVCLE1BQU0sSUFBSU4scUJBQXFCO2dCQUM3QkMsV0FBVztnQkFDWDdLLE9BQU9rTDtnQkFDUC9LLFNBQVM7WUFDWDtRQUNGO0lBQ0Y7SUFFQSxJQUFJZ0wsUUFBUSxNQUFNO1FBQ2hCLElBQUksT0FBT0EsU0FBUyxVQUFVO1lBQzVCLE1BQU0sSUFBSVAscUJBQXFCO2dCQUM3QkMsV0FBVztnQkFDWDdLLE9BQU9tTDtnQkFDUGhMLFNBQVM7WUFDWDtRQUNGO0lBQ0Y7SUFFQSxJQUFJaUwsbUJBQW1CLE1BQU07UUFDM0IsSUFBSSxPQUFPQSxvQkFBb0IsVUFBVTtZQUN2QyxNQUFNLElBQUlSLHFCQUFxQjtnQkFDN0JDLFdBQVc7Z0JBQ1g3SyxPQUFPb0w7Z0JBQ1BqTCxTQUFTO1lBQ1g7UUFDRjtJQUNGO0lBRUEsSUFBSWtMLG9CQUFvQixNQUFNO1FBQzVCLElBQUksT0FBT0EscUJBQXFCLFVBQVU7WUFDeEMsTUFBTSxJQUFJVCxxQkFBcUI7Z0JBQzdCQyxXQUFXO2dCQUNYN0ssT0FBT3FMO2dCQUNQbEwsU0FBUztZQUNYO1FBQ0Y7SUFDRjtJQUVBLElBQUlvTCxRQUFRLE1BQU07UUFDaEIsSUFBSSxDQUFDRSxPQUFPQyxTQUFBLENBQVVILE9BQU87WUFDM0IsTUFBTSxJQUFJWCxxQkFBcUI7Z0JBQzdCQyxXQUFXO2dCQUNYN0ssT0FBT3VMO2dCQUNQcEwsU0FBUztZQUNYO1FBQ0Y7SUFDRjtJQUVBLElBQUlxTCxjQUFjLE1BQU07UUFDdEIsSUFBSSxDQUFDQyxPQUFPQyxTQUFBLENBQVVGLGFBQWE7WUFDakMsTUFBTSxJQUFJWixxQkFBcUI7Z0JBQzdCQyxXQUFXO2dCQUNYN0ssT0FBT3dMO2dCQUNQckwsU0FBUztZQUNYO1FBQ0Y7UUFFQSxJQUFJcUwsYUFBYSxHQUFHO1lBQ2xCLE1BQU0sSUFBSVoscUJBQXFCO2dCQUM3QkMsV0FBVztnQkFDWDdLLE9BQU93TDtnQkFDUHJMLFNBQVM7WUFDWDtRQUNGO0lBQ0Y7SUFFQSxPQUFPO1FBQ0w2SztRQUNBQyxhQUFhQSxlQUFBLE9BQUFBLGNBQWU7UUFDNUJDO1FBQ0FDO1FBQ0FDO1FBQ0FDO1FBQ0FDLGVBQ0VBLGlCQUFpQixRQUFRQSxjQUFjL0osTUFBQSxHQUFTLElBQzVDK0osZ0JBQ0E7UUFDTkM7UUFDQUMsWUFBWUEsY0FBQSxPQUFBQSxhQUFjO0lBQzVCO0FBQ0Y7O0FDN0h5Qjs7QUNMbEIsU0FBU0ksaUJBQ2RDLE1BQUE7SUFFQSxPQUFPQSxVQUFVLFFBQVF2QixPQUFPd0IsSUFBQSxDQUFLRCxRQUFRdEssTUFBQSxHQUFTO0FBQ3hEOztBRE1PLFNBQVN3SywwQkFFZCxFQUNBQyxLQUFBLEVBQ0FDLFVBQUEsRUFDQUMsV0FBQSxFQUNGO0lBVUUsSUFBSSxDQUFDTixpQkFBaUJJLFFBQVE7UUFDNUIsT0FBTztZQUNMQSxPQUFPO1lBQ1BDLFlBQVk7UUFDZDtJQUNGO0lBR0EsTUFBTUUsZ0JBQ0pELGVBQWUsT0FDWDVCLE9BQU84QixPQUFBLENBQVFKLE9BQU96QyxNQUFBLENBQU8sQ0FBQyxDQUFDL0YsTUFBSSxHQUNqQzBJLFlBQVlHLFFBQUEsQ0FBUzdJLFVBRXZCOEcsT0FBTzhCLE9BQUEsQ0FBUUo7SUFFckIsT0FBTztRQUNMQSxPQUFPRyxjQUFjcEQsR0FBQSxDQUFJLENBQUMsQ0FBQ3ZGLE9BQU04SSxLQUFJO1lBQ25DLE1BQU1DLFdBQVdELEtBQUtuRCxJQUFBO1lBQ3RCLE9BQVFvRDtnQkFDTixLQUFLO2dCQUNMLEtBQUs7b0JBQ0gsT0FBTzt3QkFDTHBELE1BQU07d0JBQ04zRixNQUFBQTt3QkFDQWdKLGFBQWFGLEtBQUtFLFdBQUE7d0JBQ2xCQyxZQUFZZCwyREFBUUEsQ0FBQ1csS0FBS0csVUFBVSxFQUFFQyxVQUFBO29CQUN4QztnQkFDRixLQUFLO29CQUNILE9BQU87d0JBQ0x2RCxNQUFNO3dCQUNOM0YsTUFBQUE7d0JBQ0FtSixJQUFJTCxLQUFLSyxFQUFBO3dCQUNUckwsTUFBTWdMLEtBQUtoTCxJQUFBO29CQUNiO2dCQUNGO29CQUFTO3dCQUNQLE1BQU1zTCxrQkFBeUJMO3dCQUMvQixNQUFNLElBQUlqTSxNQUFNLDBCQUEwQnNNLGdCQUFlLENBQUU7b0JBQzdEO1lBQ0Y7UUFDRjtRQUNBWCxZQUNFQSxjQUFjLE9BQ1Y7WUFBRTlDLE1BQU07UUFBTyxJQUNmLE9BQU84QyxlQUFlLFdBQ3RCO1lBQUU5QyxNQUFNOEM7UUFBVyxJQUNuQjtZQUFFOUMsTUFBTTtZQUFpQk8sVUFBVXVDLFdBQVd2QyxRQUFBO1FBQW1CO0lBQ3pFO0FBQ0Y7O0FFekVtQztBQUNEO0FBQ2hCOztBQ0ZBOztBQ0NBOztBQ0FBO0FBRVgsSUFBTXFELGtCQUF3Q2pHLGtDQUFBQSxDQUFFa0csSUFBQSxDQUFLLElBQzFEbEcsa0NBQUFBLENBQUVFLEtBQUEsQ0FBTTtRQUNORixrQ0FBQUEsQ0FBRW1HLElBQUE7UUFDRm5HLGtDQUFBQSxDQUFFRyxNQUFBO1FBQ0ZILGtDQUFBQSxDQUFFb0csTUFBQTtRQUNGcEcsa0NBQUFBLENBQUVxRyxPQUFBO1FBQ0ZyRyxrQ0FBQUEsQ0FBRXNHLE1BQUEsQ0FBT3RHLGtDQUFBQSxDQUFFRyxNQUFBLElBQVU4RjtRQUNyQmpHLGtDQUFBQSxDQUFFdUcsS0FBQSxDQUFNTjtLQUNUOztBREFJLElBQU1PLHlCQUFzRHhHLGtDQUFBQSxDQUFFc0csTUFBQSxDQUNuRXRHLGtDQUFBQSxDQUFFRyxNQUFBLElBQ0ZILGtDQUFBQSxDQUFFc0csTUFBQSxDQUFPdEcsa0NBQUFBLENBQUVHLE1BQUEsSUFBVThGOztBRWJMOztBQ0FBO0FBY1gsSUFBTVEsMEJBQXdEekcsa0NBQUFBLENBQUV1RyxLQUFBLENBQ3JFdkcsa0NBQUFBLENBQUVFLEtBQUEsQ0FBTTtJQUNORixrQ0FBQUEsQ0FBRStFLE1BQUEsQ0FBTztRQUFFMUMsTUFBTXJDLGtDQUFBQSxDQUFFMEcsT0FBQSxDQUFRO1FBQVNwRSxNQUFNdEMsa0NBQUFBLENBQUVHLE1BQUE7SUFBUztJQUNyREgsa0NBQUFBLENBQUUrRSxNQUFBLENBQU87UUFDUDFDLE1BQU1yQyxrQ0FBQUEsQ0FBRTBHLE9BQUEsQ0FBUTtRQUNoQjVILE1BQU1rQixrQ0FBQUEsQ0FBRUcsTUFBQTtRQUNSbEIsVUFBVWUsa0NBQUFBLENBQUVHLE1BQUEsR0FBU3dHLFFBQUE7SUFDdkI7Q0FDRDs7QURRSSxJQUFNQyxpQkFBc0M1RyxrQ0FBQUEsQ0FBRStFLE1BQUEsQ0FBTztJQUMxRDFDLE1BQU1yQyxrQ0FBQUEsQ0FBRTBHLE9BQUEsQ0FBUTtJQUNoQnBFLE1BQU10QyxrQ0FBQUEsQ0FBRUcsTUFBQTtJQUNSaUMsK0JBQStCb0UsdUJBQXVCRyxRQUFBO0FBQ3hEO0FBNkJPLElBQU1FLGtCQUF3QzdHLGtDQUFBQSxDQUFFK0UsTUFBQSxDQUFPO0lBQzVEMUMsTUFBTXJDLGtDQUFBQSxDQUFFMEcsT0FBQSxDQUFRO0lBQ2hCcEgsT0FBT1Usa0NBQUFBLENBQUVFLEtBQUEsQ0FBTTtRQUFDRDtRQUFtQkQsa0NBQUFBLENBQUVJLFVBQUEsQ0FBV2lEO0tBQUs7SUFDckRwRSxVQUFVZSxrQ0FBQUEsQ0FBRUcsTUFBQSxHQUFTd0csUUFBQTtJQUNyQnZFLCtCQUErQm9FLHVCQUF1QkcsUUFBQTtBQUN4RDtBQTZCTyxJQUFNRyxpQkFBc0M5RyxrQ0FBQUEsQ0FBRStFLE1BQUEsQ0FBTztJQUMxRDFDLE1BQU1yQyxrQ0FBQUEsQ0FBRTBHLE9BQUEsQ0FBUTtJQUNoQjVILE1BQU1rQixrQ0FBQUEsQ0FBRUUsS0FBQSxDQUFNO1FBQUNEO1FBQW1CRCxrQ0FBQUEsQ0FBRUksVUFBQSxDQUFXaUQ7S0FBSztJQUNwRHBFLFVBQVVlLGtDQUFBQSxDQUFFRyxNQUFBO0lBQ1ppQywrQkFBK0JvRSx1QkFBdUJHLFFBQUE7QUFDeEQ7QUErQk8sSUFBTUkscUJBQThDL0csa0NBQUFBLENBQUUrRSxNQUFBLENBQU87SUFDbEUxQyxNQUFNckMsa0NBQUFBLENBQUUwRyxPQUFBLENBQVE7SUFDaEIvRCxZQUFZM0Msa0NBQUFBLENBQUVHLE1BQUE7SUFDZHlDLFVBQVU1QyxrQ0FBQUEsQ0FBRUcsTUFBQTtJQUNaM0YsTUFBTXdGLGtDQUFBQSxDQUFFZ0gsT0FBQTtBQUNWO0FBeUNPLElBQU1DLHVCQUFrRGpILGtDQUFBQSxDQUFFK0UsTUFBQSxDQUFPO0lBQ3RFMUMsTUFBTXJDLGtDQUFBQSxDQUFFMEcsT0FBQSxDQUFRO0lBQ2hCL0QsWUFBWTNDLGtDQUFBQSxDQUFFRyxNQUFBO0lBQ2R5QyxVQUFVNUMsa0NBQUFBLENBQUVHLE1BQUE7SUFDWmxFLFFBQVErRCxrQ0FBQUEsQ0FBRWdILE9BQUE7SUFDVm5ILFNBQVM0Ryx3QkFBd0JFLFFBQUE7SUFDakM3RCxTQUFTOUMsa0NBQUFBLENBQUVxRyxPQUFBLEdBQVVNLFFBQUE7SUFDckJ2RSwrQkFBK0JvRSx1QkFBdUJHLFFBQUE7QUFDeEQ7O0FIeEpPLElBQU1PLDBCQUF3RGxILGtDQUFBQSxDQUFFK0UsTUFBQSxDQUFPO0lBQzVFOUQsTUFBTWpCLGtDQUFBQSxDQUFFMEcsT0FBQSxDQUFRO0lBQ2hCN0csU0FBU0csa0NBQUFBLENBQUVHLE1BQUE7SUFDWGlDLCtCQUErQm9FLHVCQUF1QkcsUUFBQTtBQUN4RDtBQXNCTyxJQUFNUSx3QkFBb0RuSCxrQ0FBQUEsQ0FBRStFLE1BQUEsQ0FBTztJQUN4RTlELE1BQU1qQixrQ0FBQUEsQ0FBRTBHLE9BQUEsQ0FBUTtJQUNoQjdHLFNBQVNHLGtDQUFBQSxDQUFFRSxLQUFBLENBQU07UUFDZkYsa0NBQUFBLENBQUVHLE1BQUE7UUFDRkgsa0NBQUFBLENBQUV1RyxLQUFBLENBQU12RyxrQ0FBQUEsQ0FBRUUsS0FBQSxDQUFNO1lBQUMwRztZQUFnQkM7WUFBaUJDO1NBQWU7S0FDbEU7SUFDRDFFLCtCQUErQm9FLHVCQUF1QkcsUUFBQTtBQUN4RDtBQTJCTyxJQUFNUyw2QkFDWHBILGtDQUFBQSxDQUFFK0UsTUFBQSxDQUFPO0lBQ1A5RCxNQUFNakIsa0NBQUFBLENBQUUwRyxPQUFBLENBQVE7SUFDaEI3RyxTQUFTRyxrQ0FBQUEsQ0FBRUUsS0FBQSxDQUFNO1FBQ2ZGLGtDQUFBQSxDQUFFRyxNQUFBO1FBQ0ZILGtDQUFBQSxDQUFFdUcsS0FBQSxDQUFNdkcsa0NBQUFBLENBQUVFLEtBQUEsQ0FBTTtZQUFDMEc7WUFBZ0JHO1NBQW1CO0tBQ3JEO0lBQ0QzRSwrQkFBK0JvRSx1QkFBdUJHLFFBQUE7QUFDeEQ7QUEyQkssSUFBTVUsd0JBQW9Eckgsa0NBQUFBLENBQUUrRSxNQUFBLENBQU87SUFDeEU5RCxNQUFNakIsa0NBQUFBLENBQUUwRyxPQUFBLENBQVE7SUFDaEI3RyxTQUFTRyxrQ0FBQUEsQ0FBRXVHLEtBQUEsQ0FBTVU7SUFDakI3RSwrQkFBK0JvRSx1QkFBdUJHLFFBQUE7QUFDeEQ7QUFzQk8sSUFBTVcsb0JBQTRDdEgsa0NBQUFBLENBQUVFLEtBQUEsQ0FBTTtJQUMvRGdIO0lBQ0FDO0lBQ0FDO0lBQ0FDO0NBQ0Q7O0FLaktNLFNBQVNFLGlCQUNkOUYsTUFBQTtJQUVBLElBQUksQ0FBQ3dCLE1BQU1DLE9BQUEsQ0FBUXpCLFNBQVM7UUFDMUIsT0FBTztJQUNUO0lBRUEsSUFBSUEsT0FBT2hILE1BQUEsS0FBVyxHQUFHO1FBQ3ZCLE9BQU87SUFDVDtJQUVBLE1BQU0rTSxrQkFBa0IvRixPQUFPUSxHQUFBLENBQUl3RjtJQUVuQyxJQUFJRCxnQkFBZ0JFLElBQUEsQ0FBSyxDQUFBQyxJQUFLQSxNQUFNLDBCQUEwQjtRQUM1RCxPQUFPO0lBQ1QsV0FDRUgsZ0JBQWdCakksS0FBQSxDQUNkLENBQUFvSSxJQUFLQSxNQUFNLDZCQUE2QkEsTUFBTSxZQUVoRDtRQUNBLE9BQU87SUFDVCxPQUFPO1FBQ0wsT0FBTztJQUNUO0FBQ0Y7QUFFQSxTQUFTRixtQ0FDUHBPLE9BQUE7SUFFQSxJQUNFLE9BQU9BLFlBQVksWUFDbkJBLFlBQVksUUFDWEEsQ0FBQUEsUUFBUTRILElBQUEsS0FBUztJQUNoQjVILFFBQVE0SCxJQUFBLEtBQVM7SUFDakIscUJBQXFCNUgsV0FBQTtJQUNyQiw4QkFBOEJBLE9BQUEsR0FDaEM7UUFDQSxPQUFPO0lBQ1QsV0FDRSxPQUFPQSxZQUFZLFlBQ25CQSxZQUFZLFFBQ1osYUFBYUEsV0FDWjRKLENBQUFBLE1BQU1DLE9BQUEsQ0FBUTdKLFFBQVF3RyxPQUFPO0lBQzVCLG1DQUFtQ3hHLE9BQUEsR0FDckM7UUFDQSxPQUFPO0lBQ1QsV0FDRSxPQUFPQSxZQUFZLFlBQ25CQSxZQUFZLFFBQ1osVUFBVUEsV0FDVixhQUFhQSxXQUNiLE9BQU9BLFFBQVF3RyxPQUFBLEtBQVksWUFDM0I7UUFBQztRQUFVO1FBQVE7UUFBYTtLQUFNLENBQUUwRixRQUFBLENBQVNsTSxRQUFRNEgsSUFBSSxHQUM3RDtRQUNBLE9BQU87SUFDVCxPQUFPO1FBQ0wsT0FBTztJQUNUO0FBQ0Y7O0FDNUNPLFNBQVMyRyxtQkFBbUJDLFdBQUE7SUFkbkMsSUFBQTVNLEtBQUFDLElBQUE0TTtJQWVFLE1BQU1DLFFBQXVCLEVBQUM7SUFFOUIsV0FBV0MsY0FBY0gsWUFBYTtRQUNwQyxJQUFJaEs7UUFFSixJQUFJO1lBQ0ZBLE1BQU0sSUFBSXdGLElBQUkyRSxXQUFXbkssR0FBRztRQUM5QixTQUFTSyxPQUFPO1lBQ2QsTUFBTSxJQUFJMUUsTUFBTSxnQkFBZ0J3TyxXQUFXbkssR0FBRyxFQUFFO1FBQ2xEO1FBRUEsT0FBUUEsSUFBSThGLFFBQUE7WUFDVixLQUFLO1lBQ0wsS0FBSztnQkFBVTtvQkFDYixLQUFJMUksTUFBQStNLFdBQVdDLFdBQUEsS0FBWCxnQkFBQWhOLElBQXdCbUksVUFBQSxDQUFXLFdBQVc7d0JBQ2hEMkUsTUFBTUcsSUFBQSxDQUFLOzRCQUFFN0YsTUFBTTs0QkFBUy9DLE9BQU96Qjt3QkFBSTtvQkFDekMsT0FBTzt3QkFDTCxJQUFJLENBQUNtSyxXQUFXQyxXQUFBLEVBQWE7NEJBQzNCLE1BQU0sSUFBSXpPLE1BQ1I7d0JBRUo7d0JBRUF1TyxNQUFNRyxJQUFBLENBQUs7NEJBQ1Q3RixNQUFNOzRCQUNOdkQsTUFBTWpCOzRCQUNOb0IsVUFBVStJLFdBQVdDLFdBQUE7d0JBQ3ZCO29CQUNGO29CQUNBO2dCQUNGO1lBRUEsS0FBSztnQkFBUztvQkFDWixJQUFJNUc7b0JBQ0osSUFBSUM7b0JBQ0osSUFBSXJDO29CQUVKLElBQUk7d0JBQ0YsQ0FBQ29DLFFBQVFDLGNBQWEsR0FBSTBHLFdBQVduSyxHQUFBLENBQUkwRCxLQUFBLENBQU07d0JBQy9DdEMsV0FBV29DLE9BQU9FLEtBQUEsQ0FBTSxJQUFHLENBQUUsRUFBQyxDQUFFQSxLQUFBLENBQU0sSUFBRyxDQUFFLEVBQUM7b0JBQzlDLFNBQVNyRCxPQUFPO3dCQUNkLE1BQU0sSUFBSTFFLE1BQU0sOEJBQThCd08sV0FBV25LLEdBQUcsRUFBRTtvQkFDaEU7b0JBRUEsSUFBSW9CLFlBQVksUUFBUXFDLGlCQUFpQixNQUFNO3dCQUM3QyxNQUFNLElBQUk5SCxNQUFNLDRCQUE0QndPLFdBQVduSyxHQUFHLEVBQUU7b0JBQzlEO29CQUVBLEtBQUkzQyxLQUFBOE0sV0FBV0MsV0FBQSxLQUFYLGdCQUFBL00sR0FBd0JrSSxVQUFBLENBQVcsV0FBVzt3QkFDaEQyRSxNQUFNRyxJQUFBLENBQUs7NEJBQ1Q3RixNQUFNOzRCQUNOL0MsT0FBT3FCLCtCQUErQlc7d0JBQ3hDO29CQUNGLFlBQVd3RyxLQUFBRSxXQUFXQyxXQUFBLEtBQVgsZ0JBQUFILEdBQXdCMUUsVUFBQSxDQUFXLFVBQVU7d0JBQ3REMkUsTUFBTUcsSUFBQSxDQUFLOzRCQUNUN0YsTUFBTTs0QkFDTkMsTUFBTTFCLHdCQUNKRCwrQkFBK0JXO3dCQUVuQztvQkFDRixPQUFPO3dCQUNMLElBQUksQ0FBQzBHLFdBQVdDLFdBQUEsRUFBYTs0QkFDM0IsTUFBTSxJQUFJek8sTUFDUjt3QkFFSjt3QkFFQXVPLE1BQU1HLElBQUEsQ0FBSzs0QkFDVDdGLE1BQU07NEJBQ052RCxNQUFNd0M7NEJBQ05yQyxVQUFVK0ksV0FBV0MsV0FBQTt3QkFDdkI7b0JBQ0Y7b0JBRUE7Z0JBQ0Y7WUFFQTtnQkFBUztvQkFDUCxNQUFNLElBQUl6TyxNQUFNLDZCQUE2QnFFLElBQUk4RixRQUFRLEVBQUU7Z0JBQzdEO1FBQ0Y7SUFDRjtJQUVBLE9BQU9vRTtBQUNUOztBQ25HMkI7QUFHM0IsSUFBTXJMLFFBQU87QUFDYixJQUFNYSxVQUFTLG1CQUFtQmIsTUFBSTtBQUN0QyxJQUFNYyxVQUFTQyxPQUFPQyxHQUFBLENBQUlIO0FBTDFCLElBQUF0QztBQU9PLElBQU1rTix5QkFBTixjQUFxQzdLLHdEQUFBQTtJQUsxQ00sWUFBWSxFQUNWd0ssZUFBQSxFQUNBL08sT0FBQSxFQUNGLENBR0c7UUFDRCxNQUFNO1lBQUVxRCxNQUFBQTtZQUFNckQ7UUFBUTtRQVh4QixLQUFrQjRCLElBQUFBLEdBQVU7UUFhMUIsS0FBS21OLGVBQUEsR0FBa0JBO0lBQ3pCO0lBRUEsT0FBT25LLFdBQVdDLEtBQUEsRUFBaUQ7UUFDakUsT0FBT1osd0RBQUFBLENBQVdhLFNBQUEsQ0FBVUQsT0FBT1g7SUFDckM7QUFDRjtBQW5Cb0J0QyxNQUFBdUM7O0FDRWIsU0FBUzZLLHNCQUVkdEcsUUFBQSxFQUE0QnBJLE9BQUE7SUFaOUIsSUFBQXNCO0lBYUUsTUFBTWlLLFFBQUEsQ0FBUWpLLE1BQUF0QixXQUFBLGdCQUFBQSxRQUFTdUwsS0FBQSxLQUFULE9BQUFqSyxNQUFtQixDQUFDO0lBQ2xDLE1BQU1xTixlQUE4QixFQUFDO0lBRXJDLFdBQVdqUCxXQUFXMEksU0FBVTtRQUM5QixNQUFNLEVBQUVkLElBQUEsRUFBTXBCLE9BQUEsRUFBUzBJLGVBQUEsRUFBaUJDLHdCQUFBLEVBQXlCLEdBQy9EblA7UUFFRixPQUFRNEg7WUFDTixLQUFLO2dCQUFVO29CQUNicUgsYUFBYUosSUFBQSxDQUFLO3dCQUNoQmpILE1BQU07d0JBQ05wQjtvQkFDRjtvQkFDQTtnQkFDRjtZQUVBLEtBQUs7Z0JBQVE7b0JBQ1h5SSxhQUFhSixJQUFBLENBQUs7d0JBQ2hCakgsTUFBTTt3QkFDTnBCLFNBQVMySSwyQkFDTDs0QkFDRTtnQ0FBRW5HLE1BQU07Z0NBQVFDLE1BQU16Qzs0QkFBUTsrQkFDM0IrSCxtQkFBbUJZO3lCQUN4QixHQUNBM0k7b0JBQ047b0JBQ0E7Z0JBQ0Y7WUFFQSxLQUFLO2dCQUFhO29CQUNoQixJQUFJMEksbUJBQW1CLE1BQU07d0JBQzNCRCxhQUFhSixJQUFBLENBQUs7NEJBQUVqSCxNQUFNOzRCQUFhcEI7d0JBQVE7d0JBQy9DO29CQUNGO29CQUdBeUksYUFBYUosSUFBQSxDQUFLO3dCQUNoQmpILE1BQU07d0JBQ05wQixTQUFTOzRCQUNQO2dDQUFFd0MsTUFBTTtnQ0FBUUMsTUFBTXpDOzRCQUFROytCQUMzQjBJLGdCQUFnQnRHLEdBQUEsQ0FDakIsQ0FBQyxFQUFFVSxVQUFBLEVBQVlDLFFBQUEsRUFBVXBJLElBQUEsRUFBSyxHQUFxQjtvQ0FDakQ2SCxNQUFNO29DQUNOTTtvQ0FDQUM7b0NBQ0FwSTtnQ0FDRjt5QkFFSjtvQkFDRjtvQkFHQThOLGFBQWFKLElBQUEsQ0FBSzt3QkFDaEJqSCxNQUFNO3dCQUNOcEIsU0FBUzBJLGdCQUFnQnRHLEdBQUEsQ0FBSSxDQUFDd0c7NEJBQzVCLElBQUksQ0FBRSxhQUFZQSxjQUFBLEdBQWlCO2dDQUNqQyxNQUFNLElBQUlOLHVCQUF1QjtvQ0FDL0JDLGlCQUFpQi9PO29DQUNqQkEsU0FDRSx3Q0FDQVUsS0FBS0UsU0FBQSxDQUFVd087Z0NBQ25COzRCQUNGOzRCQUVBLE1BQU0sRUFBRTlGLFVBQUEsRUFBWUMsUUFBQSxFQUFVM0csTUFBQSxFQUFPLEdBQUl3TTs0QkFFekMsTUFBTWpELE9BQU9OLEtBQUEsQ0FBTXRDLFNBQVE7NEJBQzNCLFFBQU80QyxRQUFBLGdCQUFBQSxLQUFNa0QsZ0NBQUEsS0FBb0MsT0FDN0M7Z0NBQ0VyRyxNQUFNO2dDQUNOTTtnQ0FDQUM7Z0NBQ0EzRyxRQUFRdUosS0FBS2tELGdDQUFBLENBQWlDek07Z0NBQzlDNEcsc0JBQ0UyQyxLQUFLa0QsZ0NBQUEsQ0FBaUN6TTs0QkFDMUMsSUFDQTtnQ0FDRW9HLE1BQU07Z0NBQ05NO2dDQUNBQztnQ0FDQTNHOzRCQUNGO3dCQUNOO29CQUNGO29CQUVBO2dCQUNGO1lBRUEsS0FBSztZQUNMLEtBQUs7WUFDTCxLQUFLO2dCQUFRO29CQUVYO2dCQUNGO1lBRUE7Z0JBQVM7b0JBQ1AsTUFBTThHLG1CQUEwQjlCO29CQUNoQyxNQUFNLElBQUlrSCx1QkFBdUI7d0JBQy9CQyxpQkFBaUIvTzt3QkFDakJBLFNBQVMscUJBQXFCMEosaUJBQWdCO29CQUNoRDtnQkFDRjtRQUNGO0lBQ0Y7SUFFQSxPQUFPdUY7QUFDVDs7QVQzRk8sU0FBU0ssa0JBQTBELEVBQ3hFbEgsTUFBQSxFQUNBeUQsS0FBQSxFQUNGO0lBSUUsSUFBSXpELE9BQU9BLE1BQUEsSUFBVSxRQUFRQSxPQUFPTSxRQUFBLElBQVksTUFBTTtRQUNwRCxNQUFNLElBQUlnRSxnRUFBa0JBLENBQUM7WUFDM0J0RTtZQUNBcEksU0FBUztRQUNYO0lBQ0Y7SUFFQSxJQUFJb0ksT0FBT0EsTUFBQSxJQUFVLFFBQVFBLE9BQU9NLFFBQUEsSUFBWSxNQUFNO1FBQ3BELE1BQU0sSUFBSWdFLGdFQUFrQkEsQ0FBQztZQUMzQnRFO1lBQ0FwSSxTQUFTO1FBQ1g7SUFDRjtJQUdBLElBQUlvSSxPQUFPTyxNQUFBLElBQVUsUUFBUSxPQUFPUCxPQUFPTyxNQUFBLEtBQVcsVUFBVTtRQUM5RCxNQUFNLElBQUkrRCxnRUFBa0JBLENBQUM7WUFDM0J0RTtZQUNBcEksU0FBUztRQUNYO0lBQ0Y7SUFHQSxJQUFJb0ksT0FBT0EsTUFBQSxJQUFVLE1BQU07UUFFekIsSUFBSSxPQUFPQSxPQUFPQSxNQUFBLEtBQVcsVUFBVTtZQUNyQyxNQUFNLElBQUlzRSxnRUFBa0JBLENBQUM7Z0JBQzNCdEU7Z0JBQ0FwSSxTQUFTO1lBQ1g7UUFDRjtRQUVBLE9BQU87WUFDTGdKLE1BQU07WUFDTkwsUUFBUVAsT0FBT08sTUFBQTtZQUNmRCxVQUFVO2dCQUNSO29CQUNFZCxNQUFNO29CQUNOcEIsU0FBUzRCLE9BQU9BLE1BQUE7Z0JBQ2xCO2FBQ0Y7UUFDRjtJQUNGO0lBR0EsSUFBSUEsT0FBT00sUUFBQSxJQUFZLE1BQU07UUFDM0IsTUFBTTZHLGFBQWFyQixpQkFBaUI5RixPQUFPTSxRQUFRO1FBRW5ELElBQUk2RyxlQUFlLFNBQVM7WUFDMUIsTUFBTSxJQUFJN0MsZ0VBQWtCQSxDQUFDO2dCQUMzQnRFO2dCQUNBcEksU0FBUztZQUNYO1FBQ0Y7UUFFQSxNQUFNMEksV0FDSjZHLGVBQWUsZ0JBQ1hQLHNCQUFzQjVHLE9BQU9NLFFBQUEsRUFBeUI7WUFDcERtRDtRQUNGLEtBQ0N6RCxPQUFPTSxRQUFBO1FBRWQsTUFBTThHLG1CQUFtQjdDLHlFQUFpQkEsQ0FBQztZQUN6QzlNLE9BQU82STtZQUNQK0csUUFBUTlJLGtDQUFBQSxDQUFFdUcsS0FBQSxDQUFNZTtRQUNsQjtRQUVBLElBQUksQ0FBQ3VCLGlCQUFpQkUsT0FBQSxFQUFTO1lBQzdCLE1BQU0sSUFBSWhELGdFQUFrQkEsQ0FBQztnQkFDM0J0RTtnQkFDQXBJLFNBQVM7Z0JBQ1QyRSxPQUFPNkssaUJBQWlCM0ssS0FBQTtZQUMxQjtRQUNGO1FBRUEsT0FBTztZQUNMbUUsTUFBTTtZQUNOTjtZQUNBQyxRQUFRUCxPQUFPTyxNQUFBO1FBQ2pCO0lBQ0Y7SUFFQSxNQUFNLElBQUl4SSxNQUFNO0FBQ2xCOztBVTFFTyxTQUFTd1AsNEJBQTRCQyxLQUFBO0lBSTFDLE9BQU87UUFDTEMsY0FBY0QsTUFBTUMsWUFBQTtRQUNwQkMsa0JBQWtCRixNQUFNRSxnQkFBQTtRQUN4QkMsYUFBYUgsTUFBTUMsWUFBQSxHQUFlRCxNQUFNRSxnQkFBQTtJQUMxQztBQUNGOztBQ3JENEM7QUFFNUMsSUFBTXpNLFFBQU87QUFDYixJQUFNYSxVQUFTLG1CQUFtQmIsTUFBSTtBQUN0QyxJQUFNYyxVQUFTQyxPQUFPQyxHQUFBLENBQUlIO0FBSjFCLElBQUF0QztBQU1PLElBQU1xTyw0QkFBTixjQUF3Q2hNLHdEQUFBQTtJQU03Q00sWUFBWSxFQUNWMkwsUUFBQSxFQUNBM0csUUFBQSxFQUNBNUUsS0FBQSxFQUNBM0UsVUFBVSw4QkFBOEJ1SixTQUFRLElBQUt5RyxpRUFBZUEsQ0FDbEVyTCxPQUNELEdBQ0gsQ0FLRztRQUNELE1BQU07WUFBRXRCLE1BQUFBO1lBQU1yRDtZQUFTMkU7UUFBTTtRQWxCL0IsS0FBa0IvQyxJQUFBQSxHQUFVO1FBb0IxQixLQUFLc08sUUFBQSxHQUFXQTtRQUNoQixLQUFLM0csUUFBQSxHQUFXQTtJQUNsQjtJQUVBLE9BQU8zRSxXQUFXQyxLQUFBLEVBQW9EO1FBQ3BFLE9BQU9aLHdEQUFBQSxDQUFXYSxTQUFBLENBQVVELE9BQU9YO0lBQ3JDO0lBQUE7O0dBQUEsR0FLQSxPQUFPaU0sNEJBQ0x0TCxLQUFBLEVBQ29DO1FBQ3BDLE9BQ0VBLGlCQUFpQjFFLFNBQ2pCMEUsTUFBTXhCLElBQUEsS0FBU0EsU0FDZixPQUFRd0IsTUFBb0MwRSxRQUFBLEtBQWEsWUFDekQsT0FBUTFFLE1BQW9DcUwsUUFBQSxLQUFhO0lBRTdEO0lBQUE7O0dBQUEsR0FLQWxMLFNBQVM7UUFDUCxPQUFPO1lBQ0wzQixNQUFNLEtBQUtBLElBQUE7WUFDWHJELFNBQVMsS0FBS0EsT0FBQTtZQUNkMkUsT0FBTyxLQUFLQSxLQUFBO1lBQ1orQixPQUFPLEtBQUtBLEtBQUE7WUFFWjZDLFVBQVUsS0FBS0EsUUFBQTtZQUNmMkcsVUFBVSxLQUFLQSxRQUFBO1FBQ2pCO0lBQ0Y7QUFDRjtBQXhEb0J0TyxNQUFBdUM7O0FDUE87QUFFM0IsSUFBTWQsUUFBTztBQUNiLElBQU1hLFVBQVMsbUJBQW1CYixNQUFJO0FBQ3RDLElBQU1jLFVBQVNDLE9BQU9DLEdBQUEsQ0FBSUg7QUFKMUIsSUFBQXRDO0FBTU8sSUFBTXdPLGtCQUFOLGNBQThCbk0sd0RBQUFBO0lBTW5DTSxZQUFZLEVBQ1ZnRixRQUFBLEVBQ0E4RyxpQkFBaUIsUUFDakJyUSxVQUFVLHlDQUF5Q3VKLFNBQVEsS0FDekQ4RyxtQkFBbUIsU0FDZiw0QkFDQSxvQkFBb0JBLGVBQWVDLElBQUEsQ0FBSyxNQUFLLEVBQ25ELElBQ0YsQ0FJRztRQUNELE1BQU07WUFBRWpOLE1BQUFBO1lBQU1yRDtRQUFRO1FBbEJ4QixLQUFrQjRCLElBQUFBLEdBQVU7UUFvQjFCLEtBQUsySCxRQUFBLEdBQVdBO1FBQ2hCLEtBQUs4RyxjQUFBLEdBQWlCQTtJQUN4QjtJQUVBLE9BQU96TCxXQUFXQyxLQUFBLEVBQTBDO1FBQzFELE9BQU9aLHdEQUFBQSxDQUFXYSxTQUFBLENBQVVELE9BQU9YO0lBQ3JDO0lBQUE7O0dBQUEsR0FLQSxPQUFPcU0sa0JBQWtCMUwsS0FBQSxFQUEwQztRQUNqRSxPQUNFQSxpQkFBaUIxRSxTQUNqQjBFLE1BQU14QixJQUFBLEtBQVNBLFNBQ2YsY0FBY3dCLFNBQ2RBLE1BQU0wRSxRQUFBLElBQVksVUFDbEIsT0FBTzFFLE1BQU14QixJQUFBLEtBQVM7SUFFMUI7SUFBQTs7R0FBQSxHQUtBMkIsU0FBUztRQUNQLE9BQU87WUFDTDNCLE1BQU0sS0FBS0EsSUFBQTtZQUNYckQsU0FBUyxLQUFLQSxPQUFBO1lBQ2QwRyxPQUFPLEtBQUtBLEtBQUE7WUFFWjZDLFVBQVUsS0FBS0EsUUFBQTtZQUNmOEcsZ0JBQWdCLEtBQUtBLGNBQUE7UUFDdkI7SUFDRjtBQUNGO0FBdERvQnpPLE1BQUF1Qzs7QUNQYixTQUFTcU0saUJBQ2QzUSxLQUFBO0lBRUEsT0FDRUEsU0FBUyxRQUFRLE9BQU9BLFVBQVUsWUFBWXVFLE9BQU9xTSxhQUFBLElBQWlCNVE7QUFFMUU7O0FDTk8sU0FBUzZRLFlBQ2Q3USxLQUFBO0lBRUEsT0FBT0EsU0FBUyxRQUFRLE9BQU9BLFVBQVUsWUFBWXVFLE9BQU91TSxRQUFBLElBQVk5UTtBQUMxRTs7QUNKNkI7QUFDaUI7O0FDRDlDLGVBQXNCaVIsTUFBTUMsU0FBQTtJQUMxQixPQUFPQSxjQUFjLFNBQ2pCdFIsUUFBUUgsT0FBQSxLQUNSLElBQUlHLFFBQVEsQ0FBQUgsVUFBVzBSLFdBQVcxUixTQUFTeVI7QUFDakQ7O0FDSjJCO0FBRTNCLElBQU0xTixRQUFPO0FBQ2IsSUFBTWEsVUFBUyxtQkFBbUJiLE1BQUk7QUFDdEMsSUFBTWMsVUFBU0MsT0FBT0MsR0FBQSxDQUFJSDtBQUoxQixJQUFBdEM7QUFXTyxJQUFNcVAsYUFBTixjQUF5QmhOLHdEQUFBQTtJQVE5Qk0sWUFBWSxFQUNWdkUsT0FBQSxFQUNBa1IsTUFBQSxFQUNBQyxNQUFBLEVBQ0YsQ0FJRztRQUNELE1BQU07WUFBRTlOLE1BQUFBO1lBQU1yRDtRQUFRO1FBaEJ4QixLQUFrQjRCLElBQUFBLEdBQVU7UUFrQjFCLEtBQUtzUCxNQUFBLEdBQVNBO1FBQ2QsS0FBS0MsTUFBQSxHQUFTQTtRQUdkLEtBQUtDLFNBQUEsR0FBWUQsTUFBQSxDQUFPQSxPQUFPL1AsTUFBQSxHQUFTLEVBQUM7SUFDM0M7SUFFQSxPQUFPd0QsV0FBV0MsS0FBQSxFQUFxQztRQUNyRCxPQUFPWix3REFBQUEsQ0FBV2EsU0FBQSxDQUFVRCxPQUFPWDtJQUNyQztJQUFBOztHQUFBLEdBS0EsT0FBT21OLGFBQWF4TSxLQUFBLEVBQXFDO1FBQ3ZELE9BQ0VBLGlCQUFpQjFFLFNBQ2pCMEUsTUFBTXhCLElBQUEsS0FBU0EsU0FDZixPQUFRd0IsTUFBcUJxTSxNQUFBLEtBQVcsWUFDeEN0SCxNQUFNQyxPQUFBLENBQVNoRixNQUFxQnNNLE1BQU07SUFFOUM7SUFBQTs7R0FBQSxHQUtBbk0sU0FBUztRQUNQLE9BQU87WUFDTDNCLE1BQU0sS0FBS0EsSUFBQTtZQUNYckQsU0FBUyxLQUFLQSxPQUFBO1lBQ2RrUixRQUFRLEtBQUtBLE1BQUE7WUFDYkUsV0FBVyxLQUFLQSxTQUFBO1lBQ2hCRCxRQUFRLEtBQUtBLE1BQUE7UUFDZjtJQUNGO0FBQ0Y7QUFyRG9CdlAsTUFBQXVDOztBRkNiLElBQU1tTiw4QkFDWCxDQUFDLEVBQ0NqRyxhQUFhLEdBQ2JrRyxtQkFBbUIsS0FDbkJDLGdCQUFnQixHQUNsQixHQUFJLENBQUMsSUFDTCxPQUFlQyxJQUNiQyw2QkFBNkJELEdBQUc7WUFDOUJwRztZQUNBMEYsV0FBV1E7WUFDWEM7UUFDRjtBQUVKLGVBQWVFLDZCQUNiRCxDQUFBLEVBQ0EsRUFDRXBHLFVBQUEsRUFDQTBGLFNBQUEsRUFDQVMsYUFBQSxFQUNGLEVBQ0FMLFNBQW9CLEVBQUM7SUFFckIsSUFBSTtRQUNGLE9BQU8sTUFBTU07SUFDZixTQUFTNU0sT0FBTztRQUNkLElBQUlnTSxvRUFBWUEsQ0FBQ2hNLFFBQVE7WUFDdkIsTUFBTUE7UUFDUjtRQUVBLElBQUl3RyxlQUFlLEdBQUc7WUFDcEIsTUFBTXhHO1FBQ1I7UUFFQSxNQUFNOE0sZUFBZTNCLHVFQUFBQSxDQUFnQm5MO1FBQ3JDLE1BQU0rTSxZQUFZO2VBQUlUO1lBQVF0TTtTQUFLO1FBQ25DLE1BQU1nTixZQUFZRCxVQUFVeFEsTUFBQTtRQUU1QixJQUFJeVEsWUFBWXhHLFlBQVk7WUFDMUIsTUFBTSxJQUFJNEYsV0FBVztnQkFDbkJqUixTQUFTLGdCQUFnQjZSLFVBQVMseUJBQTBCRixhQUFZO2dCQUN4RVQsUUFBUTtnQkFDUkMsUUFBUVM7WUFDVjtRQUNGO1FBRUEsSUFDRS9NLGlCQUFpQjFFLFNBQ2pCeVEsMERBQVlBLENBQUNrQixjQUFBLENBQWVqTixVQUM1QkEsTUFBTWtOLFdBQUEsS0FBZ0IsUUFDdEJGLGFBQWF4RyxZQUNiO1lBQ0EsTUFBTXlGLE1BQU1DO1lBQ1osT0FBT1csNkJBQ0xELEdBQ0E7Z0JBQUVwRztnQkFBWTBGLFdBQVdTLGdCQUFnQlQ7Z0JBQVdTO1lBQWMsR0FDbEVJO1FBRUo7UUFFQSxJQUFJQyxjQUFjLEdBQUc7WUFDbkIsTUFBTWhOO1FBQ1I7UUFFQSxNQUFNLElBQUlvTSxXQUFXO1lBQ25CalIsU0FBUyxnQkFBZ0I2UixVQUFTLHVDQUF3Q0YsYUFBWTtZQUN0RlQsUUFBUTtZQUNSQyxRQUFRUztRQUNWO0lBQ0Y7QUFDRjs7QUc5RU8sSUFBTUksaUNBQWlDLEtBQUs7O0FDSm5CO0FBbUN4QjtBQWhCUixJQUFNSSxJQUFJO0lBQ1AsT0FBTyxFQUNOOUQsR0FBRytELE9BQUEsRUFDSEMsR0FBR0MsSUFBQSxFQUNMO1FBSUUsTUFBTUMsUUFBUSxNQUFNRDtRQUVwQixJQUFJQyxNQUFNN1EsSUFBQSxFQUFNO1lBQ2QsT0FBTzZRLE1BQU0zUyxLQUFBO1FBQ2Y7UUFFQSxJQUFJMlMsTUFBTUMsTUFBQSxFQUFRO1lBQ2hCLE9BQ0UsZ0JBQUFOLHVEQUFBQSxDQUFBRCx1REFBQUEsRUFBQTtnQkFDR25PLFVBQUE7b0JBQUFzTztvQkFDRCxnQkFBQTVQLHNEQUFBQSxDQUFDd1AsMkNBQVFBLEVBQVI7d0JBQVNTLFVBQVVGLE1BQU0zUyxLQUFBO3dCQUN4QmtFLFVBQUEsZ0JBQUF0QixzREFBQUEsQ0FBQzJQLEdBQUE7NEJBQUU5RCxHQUFHa0UsTUFBTTNTLEtBQUE7NEJBQU95UyxHQUFHRSxNQUFNRCxJQUFBO3dCQUFBO29CQUFNO2lCQUNwQztZQUFBO1FBR047UUFFQSxPQUNFLGdCQUFBOVAsc0RBQUFBLENBQUN3UCwyQ0FBUUEsRUFBUjtZQUFTUyxVQUFVRixNQUFNM1MsS0FBQTtZQUN4QmtFLFVBQUEsZ0JBQUF0QixzREFBQUEsQ0FBQzJQLEdBQUE7Z0JBQUU5RCxHQUFHa0UsTUFBTTNTLEtBQUE7Z0JBQU95UyxHQUFHRSxNQUFNRCxJQUFBO1lBQUE7UUFBTTtJQUd4QztDQUlGLENBQUUsRUFBQztBQWNJLFNBQVNJLHFCQUFxQkMsWUFBQTtJQUtuQyxNQUFNLEVBQUVwVCxPQUFBLEVBQVNGLE9BQUEsRUFBU0MsTUFBQSxFQUFPLEdBQUlGO0lBRXJDLE9BQU87UUFDTHdULEtBQ0UsZ0JBQUFwUSxzREFBQUEsQ0FBQ3dQLDJDQUFRQSxFQUFSO1lBQVNTLFVBQVVFO1lBQ2xCN08sVUFBQSxnQkFBQXRCLHNEQUFBQSxDQUFDMlAsR0FBQTtnQkFBRTlELEdBQUdzRTtnQkFBY04sR0FBRzlTO1lBQUE7UUFBUztRQUdwQ0Y7UUFDQUM7SUFDRjtBQUNGOztBQzdCQSxTQUFTdVQsbUJBQW1CRixZQUFBO0lBQzFCLElBQUlHLGVBQWVIO0lBQ25CLElBQUlJLFNBQVM7SUFDYixJQUFJLEVBQUVILEdBQUEsRUFBS3ZULE9BQUEsRUFBU0MsTUFBQSxFQUFPLEdBQUlvVCxxQkFBcUJDO0lBRXBELFNBQVNLLGFBQWFDLE1BQUE7UUFDcEIsSUFBSUYsUUFBUTtZQUNWLE1BQU0sSUFBSTdTLE1BQU0rUyxTQUFTO1FBQzNCO0lBQ0Y7SUFFQSxJQUFJQztJQUNKLFNBQVNDO1FBQ1AsSUFBSUMsSUFBeUIsRUFBZTtZQUMxQyxJQUFJRixnQkFBZ0I7Z0JBQ2xCRyxhQUFhSDtZQUNmO1lBQ0FBLGlCQUFpQm5DLFdBQVc7Z0JBQzFCdUMsUUFBUUMsSUFBQSxDQUNOO1lBRUosR0FBR3hCO1FBQ0w7SUFDRjtJQUNBb0I7SUFFQSxNQUFNSyxjQUFrQztRQUN0QzVULE9BQU9nVDtRQUNQM1EsUUFBT3JDLEtBQUE7WUFDTG9ULGFBQWE7WUFHYixJQUFJcFQsVUFBVWtULGNBQWM7Z0JBQzFCSztnQkFDQSxPQUFPSztZQUNUO1lBRUEsTUFBTUMsYUFBYXJVO1lBQ25CMFQsZUFBZWxUO1lBRWZQLFFBQVE7Z0JBQUVPLE9BQU9rVDtnQkFBY3BSLE1BQU07Z0JBQU80USxNQUFNbUIsV0FBV2xVLE9BQUE7WUFBUTtZQUNyRUYsVUFBVW9VLFdBQVdwVSxPQUFBO1lBQ3JCQyxTQUFTbVUsV0FBV25VLE1BQUE7WUFFcEI2VDtZQUVBLE9BQU9LO1FBQ1Q7UUFDQWhCLFFBQU81UyxLQUFBO1lBQ0xvVCxhQUFhO1lBRWIsTUFBTVMsYUFBYXJVO1lBQ25CMFQsZUFBZWxUO1lBRWZQLFFBQVE7Z0JBQUVPO2dCQUFPOEIsTUFBTTtnQkFBTzhRLFFBQVE7Z0JBQU1GLE1BQU1tQixXQUFXbFUsT0FBQTtZQUFRO1lBQ3JFRixVQUFVb1UsV0FBV3BVLE9BQUE7WUFDckJDLFNBQVNtVSxXQUFXblUsTUFBQTtZQUVwQjZUO1lBRUEsT0FBT0s7UUFDVDtRQUNBNU8sT0FBTUEsS0FBQTtZQUNKb08sYUFBYTtZQUViLElBQUlFLGdCQUFnQjtnQkFDbEJHLGFBQWFIO1lBQ2Y7WUFDQUgsU0FBUztZQUNUelQsT0FBT3NGO1lBRVAsT0FBTzRPO1FBQ1Q7UUFDQTlSLE1BQUEsR0FBUVIsSUFBQTtZQUNOOFIsYUFBYTtZQUViLElBQUlFLGdCQUFnQjtnQkFDbEJHLGFBQWFIO1lBQ2Y7WUFDQUgsU0FBUztZQUNULElBQUk3UixLQUFLQyxNQUFBLEVBQVE7Z0JBQ2Y5QixRQUFRO29CQUFFTyxPQUFPc0IsSUFBQSxDQUFLLEVBQUM7b0JBQUdRLE1BQU07Z0JBQUs7Z0JBQ3JDLE9BQU84UjtZQUNUO1lBQ0FuVSxRQUFRO2dCQUFFTyxPQUFPa1Q7Z0JBQWNwUixNQUFNO1lBQUs7WUFFMUMsT0FBTzhSO1FBQ1Q7SUFDRjtJQUVBLE9BQU9BO0FBQ1Q7O0FqQ3BFQSxJQUFNRSxzQkFBa0MsQ0FBQyxFQUFFbk4sT0FBQSxFQUFRLEdBQ2pEQTtBQUtGLGVBQXNCb04sU0FFcEIsRUFDQUMsS0FBQSxFQUNBaEksS0FBQSxFQUNBQyxVQUFBLEVBQ0FuRCxNQUFBLEVBQ0FQLE1BQUEsRUFDQU0sUUFBQSxFQUNBMkMsVUFBQSxFQUNBeUksV0FBQSxFQUNBak8sT0FBQSxFQUNBa08sT0FBQSxFQUNBOUssSUFBQSxFQUNBRiwrQkFBK0JELGdCQUFBLEVBQy9Ca0wsUUFBQSxFQUNBLEdBQUdDLFVBQ0w7SUE2REUsSUFBSSxPQUFPSixVQUFVLFVBQVU7UUFDN0IsTUFBTSxJQUFJMVQsTUFDUjtJQUVKO0lBQ0EsSUFBSSxlQUFlOFQsVUFBVTtRQUMzQixNQUFNLElBQUk5VCxNQUNSO0lBRUo7SUFDQSxJQUFJLGNBQWM4VCxVQUFVO1FBQzFCLE1BQU0sSUFBSTlULE1BQ1I7SUFFSjtJQUNBLElBQUkwTCxPQUFPO1FBQ1QsV0FBVyxDQUFDeEksT0FBTThJLEtBQUksSUFBS2hDLE9BQU84QixPQUFBLENBQVFKLE9BQVE7WUFDaEQsSUFBSSxZQUFZTSxNQUFNO2dCQUNwQixNQUFNLElBQUloTSxNQUNSLDZHQUNFa0Q7WUFFTjtRQUNGO0lBQ0Y7SUFFQSxNQUFNNlEsS0FBS3BCLG1CQUFtQmlCO0lBRzlCLE1BQU1JLGFBQWFsTCxRQUFRMEs7SUFFM0IsSUFBSVM7SUFFSixJQUFJQyxjQU9PO0lBRVgsZUFBZUMsUUFBTyxFQUNwQm5ULElBQUEsRUFDQW9ULFFBQUEsRUFDQUMsWUFBQSxFQUNBQyxhQUFhLE9BQ2Y7UUFNRSxJQUFJLENBQUNGLFVBQVU7UUFLZixNQUFNRyxpQkFBaUJyVjtRQUN2QitVLFdBQVdBLFdBQ1BBLFNBQVNPLElBQUEsQ0FBSyxJQUFNRCxlQUFlbFYsT0FBTyxJQUMxQ2tWLGVBQWVsVixPQUFBO1FBRW5CLE1BQU1vVixpQkFBaUJMLFlBQVlwVDtRQUVuQyxJQUFJcVAsaUJBQWlCb0UsbUJBQW1CbEUsWUFBWWtFLGlCQUFpQjtZQUNuRSxNQUFPLEtBQU07Z0JBQ1gsTUFBTSxFQUFFalQsSUFBQSxFQUFNOUIsS0FBQSxFQUFNLEdBQUksTUFBTStVLGVBQWVyQyxJQUFBO2dCQUM3QyxNQUFNc0MsT0FBTyxNQUFNaFY7Z0JBRW5CLElBQUk0VSxjQUFjOVMsTUFBTTtvQkFDdEI2UyxhQUFhN1MsSUFBQSxDQUFLa1Q7Z0JBQ3BCLE9BQU87b0JBQ0xMLGFBQWF0UyxNQUFBLENBQU8yUztnQkFDdEI7Z0JBRUEsSUFBSWxULE1BQU07WUFDWjtRQUNGLE9BQU87WUFDTCxNQUFNa1QsT0FBTyxNQUFNRDtZQUVuQixJQUFJSCxZQUFZO2dCQUNkRCxhQUFhN1MsSUFBQSxDQUFLa1Q7WUFDcEIsT0FBTztnQkFDTEwsYUFBYXRTLE1BQUEsQ0FBTzJTO1lBQ3RCO1FBQ0Y7UUFHQUgsZUFBZXBWLE9BQUEsQ0FBUTtJQUN6QjtJQUVBLE1BQU13VixRQUFReEQsNEJBQTRCO1FBQUVqRztJQUFXO0lBQ3ZELE1BQU0wSixrQkFBa0J6RixrQkFBa0I7UUFDeENsSCxRQUFRO1lBQUVPO1lBQVFQO1lBQVFNO1FBQVM7UUFDbkNtRCxPQUFPO0lBQ1Q7SUFDQSxNQUFNakosU0FBUyxNQUFNa1MsTUFBTSxVQUN6QmpCLE1BQU1tQixRQUFBLENBQVM7WUFDYkMsTUFBTTtnQkFDSmpNLE1BQU07Z0JBQ04sR0FBRzRDLDBCQUEwQjtvQkFDM0JDO29CQUNBQztvQkFDQUMsYUFBYTtnQkFDZixFQUFDO1lBQ0g7WUFDQSxHQUFHbkIsb0JBQW9CcUosU0FBUTtZQUMvQmlCLGFBQWFILGdCQUFnQi9MLElBQUE7WUFDN0JaLFFBQVEsTUFBTUQsNkJBQTZCO2dCQUN6Q0MsUUFBUTJNO2dCQUNSMU0sd0JBQXdCd0wsTUFBTXNCLGlCQUFBO2dCQUM5QjdNLGtCQUFrQnVMLE1BQU11QixXQUFBO1lBQzFCO1lBQ0F0TTtZQUNBZ0w7WUFDQWpPO1FBQ0Y7SUFJRixNQUFNLENBQUN3UCxRQUFRQyxhQUFZLEdBQUkxUyxPQUFPeVMsTUFBQSxDQUFPRSxHQUFBO0lBQzVDO1FBQ0MsSUFBSTtZQUNGLElBQUkvTyxVQUFVO1lBQ2QsSUFBSWdQLGNBQWM7WUFFbEIsTUFBTUMsU0FBU0gsYUFBYUksU0FBQTtZQUM1QixNQUFPLEtBQU07Z0JBQ1gsTUFBTSxFQUFFL1QsSUFBQSxFQUFNOUIsS0FBQSxFQUFNLEdBQUksTUFBTTRWLE9BQU9FLElBQUE7Z0JBQ3JDLElBQUloVSxNQUFNO2dCQUVWLE9BQVE5QixNQUFNbUosSUFBQTtvQkFDWixLQUFLO3dCQUFjOzRCQUNqQnhDLFdBQVczRyxNQUFNK1YsU0FBQTs0QkFDakJ0QixRQUFPO2dDQUNMQyxVQUFVSjtnQ0FDVmhULE1BQU07b0NBQUM7d0NBQUVxRjt3Q0FBUzdFLE1BQU07d0NBQU9VLE9BQU94QyxNQUFNK1YsU0FBQTtvQ0FBVTtpQ0FBQztnQ0FDdkRwQixjQUFjTjs0QkFDaEI7NEJBQ0E7d0JBQ0Y7b0JBRUEsS0FBSzt3QkFBbUI7NEJBQ3RCc0IsY0FBYzs0QkFDZDt3QkFDRjtvQkFFQSxLQUFLO3dCQUFhOzRCQUNoQixNQUFNak0sV0FBVzFKLE1BQU0wSixRQUFBOzRCQUV2QixJQUFJLENBQUNzQyxPQUFPO2dDQUNWLE1BQU0sSUFBSXVFLGdCQUFnQjtvQ0FBRTdHO2dDQUFTOzRCQUN2Qzs0QkFFQSxNQUFNNEMsT0FBT04sS0FBQSxDQUFNdEMsU0FBUTs0QkFDM0IsSUFBSSxDQUFDNEMsTUFBTTtnQ0FDVCxNQUFNLElBQUlpRSxnQkFBZ0I7b0NBQ3hCN0c7b0NBQ0E4RyxnQkFBZ0JsRyxPQUFPd0IsSUFBQSxDQUFLRTtnQ0FDOUI7NEJBQ0Y7NEJBRUEySixjQUFjOzRCQUNkLE1BQU1LLGNBQWM3UixxRUFBYUEsQ0FBQztnQ0FDaENpRixNQUFNcEosTUFBTXNCLElBQUE7Z0NBQ1pzTyxRQUFRdEQsS0FBS0csVUFBQTs0QkFDZjs0QkFFQSxJQUFJdUosWUFBWW5HLE9BQUEsS0FBWSxPQUFPO2dDQUNqQyxNQUFNLElBQUlPLDBCQUEwQjtvQ0FDbEMxRztvQ0FDQTJHLFVBQVVyUSxNQUFNc0IsSUFBQTtvQ0FDaEJ3RCxPQUFPa1IsWUFBWWhSLEtBQUE7Z0NBQ3JCOzRCQUNGOzRCQUVBeVAsUUFBTztnQ0FDTEMsVUFBVXBJLEtBQUsySixRQUFBO2dDQUNmM1UsTUFBTTtvQ0FDSjBVLFlBQVloVyxLQUFBO29DQUNaO3dDQUNFMEo7d0NBQ0FELFlBQVl6SixNQUFNeUosVUFBQTtvQ0FDcEI7aUNBQ0Y7Z0NBQ0FrTCxjQUFjTjtnQ0FDZE8sWUFBWTs0QkFDZDs0QkFFQTt3QkFDRjtvQkFFQSxLQUFLO3dCQUFTOzRCQUNaLE1BQU01VSxNQUFNZ0YsS0FBQTt3QkFDZDtvQkFFQSxLQUFLO3dCQUFVOzRCQUNid1AsY0FBYztnQ0FDWjBCLGNBQWNsVyxNQUFNa1csWUFBQTtnQ0FDcEJuRyxPQUFPRCw0QkFBNEI5UCxNQUFNK1AsS0FBSztnQ0FDOUNvRyxVQUFVcFQsT0FBT29ULFFBQUE7Z0NBQ2pCQyxhQUFhclQsT0FBT3FULFdBQUE7NEJBQ3RCOzRCQUNBO3dCQUNGO2dCQUNGO1lBQ0Y7WUFFQSxJQUFJLENBQUNULGFBQWE7Z0JBQ2hCbEIsUUFBTztvQkFDTEMsVUFBVUo7b0JBQ1ZoVCxNQUFNO3dCQUFDOzRCQUFFcUY7NEJBQVM3RSxNQUFNO3dCQUFLO3FCQUFDO29CQUM5QjZTLGNBQWNOO29CQUNkTyxZQUFZO2dCQUNkO1lBQ0Y7WUFFQSxNQUFNTDtZQUVOLElBQUlDLGVBQWVMLFVBQVU7Z0JBQzNCLE1BQU1BLFNBQVM7b0JBQ2IsR0FBR0ssV0FBQTtvQkFDSHhVLE9BQU9xVSxHQUFHclUsS0FBQTtnQkFDWjtZQUNGO1FBQ0YsU0FBU2dGLE9BQU87WUFHZHFQLEdBQUdyUCxLQUFBLENBQU1BO1FBQ1g7SUFDRjtJQUVBLE9BQU87UUFDTCxHQUFHakMsTUFBQTtRQUNIeVM7UUFDQXhWLE9BQU9xVSxHQUFHclUsS0FBQTtJQUNaO0FBQ0Y7O0FrQzVZNEI7O0FDRXJCO0FBb0VBLFNBQVN1Vyw2QkFDZEMsWUFBQTtJQUVBLE1BQU1DLGNBQWMsSUFBSTdPO0lBQ3hCLElBQUk4TztJQUVKLE9BQU8sSUFBSUMsZ0JBQWdCO1FBQ3pCLE1BQU1DLE9BQU1DLFVBQUE7WUFDVkgsb0JBQW9CSixpRUFBWUEsQ0FDOUIsQ0FBQ1E7Z0JBQ0MsSUFDRyxVQUFVQSxTQUNUQSxNQUFNM04sSUFBQSxLQUFTLFdBQ2YyTixNQUFNbFIsSUFBQSxLQUFTO2dCQUFBO2dCQUdoQmtSLE1BQWNBLEtBQUEsS0FBVSxRQUN6QjtvQkFDQUQsV0FBV0UsU0FBQTtvQkFDWDtnQkFDRjtnQkFFQSxJQUFJLFVBQVVELE9BQU87b0JBQ25CLE1BQU1FLGdCQUFnQlIsZUFDbEJBLGFBQWFNLE1BQU1sUixJQUFBLEVBQU07d0JBQ3ZCa1IsT0FBT0EsTUFBTUEsS0FBQTtvQkFDZixLQUNBQSxNQUFNbFIsSUFBQTtvQkFDVixJQUFJb1IsZUFBZUgsV0FBV0ksT0FBQSxDQUFRRDtnQkFDeEM7WUFDRjtRQUVKO1FBRUFFLFdBQVV2RSxLQUFBO1lBQ1IrRCxrQkFBa0JTLElBQUEsQ0FBS1YsWUFBWTVPLE1BQUEsQ0FBTzhLO1FBQzVDO0lBQ0Y7QUFDRjtBQXdCTyxTQUFTeUUsMkJBQ2RDLEVBQUE7SUFFQSxNQUFNQyxjQUFjLElBQUlDO0lBQ3hCLElBQUlDLHFCQUFxQjtJQUN6QixNQUFNQyxZQUFZSixNQUFNLENBQUM7SUFFekIsT0FBTyxJQUFJVixnQkFBZ0I7UUFDekIsTUFBTUM7WUFDSixJQUFJYSxVQUFVQyxPQUFBLEVBQVMsTUFBTUQsVUFBVUMsT0FBQTtRQUN6QztRQUVBLE1BQU1SLFdBQVUvVyxPQUFBLEVBQVMwVyxVQUFBO1lBQ3ZCLE1BQU1sUSxVQUFVLE9BQU94RyxZQUFZLFdBQVdBLFVBQVVBLFFBQVF3RyxPQUFBO1lBRWhFa1EsV0FBV0ksT0FBQSxDQUFRSyxZQUFZSyxNQUFBLENBQU9oUjtZQUV0QzZRLHNCQUFzQjdRO1lBRXRCLElBQUk4USxVQUFVRyxPQUFBLEVBQVMsTUFBTUgsVUFBVUcsT0FBQSxDQUFRalI7WUFDL0MsSUFBSThRLFVBQVVJLE1BQUEsSUFBVSxPQUFPMVgsWUFBWSxVQUFVO2dCQUNuRCxNQUFNc1gsVUFBVUksTUFBQSxDQUFPMVg7WUFDekI7UUFDRjtRQUVBLE1BQU0yWDtZQUNKLE1BQU1DLG9CQUFvQkMsOEJBQThCUDtZQUd4RCxJQUFJQSxVQUFVUSxZQUFBLEVBQWM7Z0JBQzFCLE1BQU1SLFVBQVVRLFlBQUEsQ0FBYVQ7WUFDL0I7WUFFQSxJQUFJQyxVQUFVUyxPQUFBLElBQVcsQ0FBQ0gsbUJBQW1CO2dCQUMzQyxNQUFNTixVQUFVUyxPQUFBLENBQVFWO1lBQzFCO1FBQ0Y7SUFDRjtBQUNGO0FBRUEsU0FBU1EsOEJBQ1BQLFNBQUE7SUFFQSxPQUFPLGlDQUFpQ0E7QUFDMUM7QUFnQk8sU0FBU1U7SUFDZCxJQUFJQyxnQkFBZ0I7SUFFcEIsT0FBTyxDQUFDaFA7UUFDTixJQUFJZ1AsZUFBZTtZQUNqQmhQLE9BQU9BLEtBQUtpUCxTQUFBO1lBQ1osSUFBSWpQLE1BQU1nUCxnQkFBZ0I7UUFDNUI7UUFDQSxPQUFPaFA7SUFDVDtBQUNGO0FBb0JPLFNBQVNrUCxTQUNkN1MsUUFBQSxFQUNBK1EsWUFBQSxFQUNBaUIsU0FBQTtJQUVBLElBQUksQ0FBQ2hTLFNBQVNDLEVBQUEsRUFBSTtRQUNoQixJQUFJRCxTQUFTOFMsSUFBQSxFQUFNO1lBQ2pCLE1BQU0zQyxTQUFTblEsU0FBUzhTLElBQUEsQ0FBSzFDLFNBQUE7WUFDN0IsT0FBTyxJQUFJMkMsZUFBZTtnQkFDeEIsTUFBTTVCLE9BQU1DLFVBQUE7b0JBQ1YsTUFBTSxFQUFFL1UsSUFBQSxFQUFNOUIsS0FBQSxFQUFNLEdBQUksTUFBTTRWLE9BQU9FLElBQUE7b0JBQ3JDLElBQUksQ0FBQ2hVLE1BQU07d0JBQ1QsTUFBTTJXLFlBQVksSUFBSTdRLGNBQWNDLE1BQUEsQ0FBTzdIO3dCQUMzQzZXLFdBQVc3UixLQUFBLENBQU0sSUFBSTFFLE1BQU0sbUJBQW1CbVksVUFBUyxDQUFFO29CQUMzRDtnQkFDRjtZQUNGO1FBQ0YsT0FBTztZQUNMLE9BQU8sSUFBSUQsZUFBZTtnQkFDeEI1QixPQUFNQyxVQUFBO29CQUNKQSxXQUFXN1IsS0FBQSxDQUFNLElBQUkxRSxNQUFNO2dCQUM3QjtZQUNGO1FBQ0Y7SUFDRjtJQUVBLE1BQU1vWSxxQkFBcUJqVCxTQUFTOFMsSUFBQSxJQUFRSTtJQUU1QyxPQUFPRCxtQkFDSkUsV0FBQSxDQUFZckMsNkJBQTZCQyxlQUN6Q29DLFdBQUEsQ0FBWXhCLDJCQUEyQks7QUFDNUM7QUFlQSxTQUFTa0I7SUFDUCxPQUFPLElBQUlILGVBQWU7UUFDeEI1QixPQUFNQyxVQUFBO1lBQ0pBLFdBQVdnQyxLQUFBO1FBQ2I7SUFDRjtBQUNGO0FBTU8sU0FBU0MsMEJBQTZCQyxRQUFBO0lBQzNDLElBQUlDLEtBQUtELFFBQUEsQ0FBU3hVLE9BQU9xTSxhQUFhO0lBQ3RDLE9BQU8sSUFBSTRILGVBQWtCO1FBQzNCLE1BQU1TLE1BQUtwQyxVQUFBO1lBQ1QsTUFBTSxFQUFFL1UsSUFBQSxFQUFNOUIsS0FBQSxFQUFNLEdBQUksTUFBTWdaLEdBQUd0RyxJQUFBO1lBQ2pDLElBQUk1USxNQUFNK1UsV0FBV2dDLEtBQUE7aUJBQ2hCaEMsV0FBV0ksT0FBQSxDQUFRalg7UUFDMUI7UUFFQSxNQUFNa1osUUFBTzdILE1BQUE7WUFwU2pCLElBQUF0UDtZQXFTTSxRQUFNQSxNQUFBaVgsR0FBR0csTUFBQSxLQUFILGdCQUFBcFgsSUFBQUcsSUFBQSxDQUFBOFcsSUFBWTNILE9BQUE7UUFDcEI7SUFDRjtBQUNGOztBQ3hTNEM7QUEyRnJDLFNBQVNnSTtJQUNkLE1BQU1DLFVBQVUsSUFBSS9CO0lBQ3BCLE1BQU1nQyxVQUFVLElBQUkzUjtJQUNwQixPQUFPLElBQUkrTyxnQkFBZ0I7UUFDekJPLFdBQVcsT0FBT3ZFLE9BQU9rRTtZQUN2QixNQUFNMVcsVUFBVW9aLFFBQVExUixNQUFBLENBQU84SztZQUMvQmtFLFdBQVdJLE9BQUEsQ0FBUXFDLFFBQVEzQixNQUFBLENBQU95QixtRUFBZ0JBLENBQUMsUUFBUWpaO1FBQzdEO0lBQ0Y7QUFDRjs7QUM3Rk87QUFzUVAsU0FBU3NaO0lBR1AsTUFBTUMsVUFBVUM7SUFDaEIsT0FBTyxDQUFBL1QsT0FBUThULFFBQVE3WSxLQUFLQyxLQUFBLENBQU04RTtBQUNwQztBQU9BLGdCQUFnQmdPLFdBQVc0QixNQUFBO0lBQ3pCLE1BQU1rRSxVQUFVQztJQUVoQixlQUFlaEgsU0FBUzZDLE9BQVE7UUFHOUIsSUFBSSx5QkFBeUI3QyxPQUFPO1lBQ2xDQSxRQUFRO2dCQUNOaEcsSUFBSWdHLE1BQU1oRyxFQUFBO2dCQUNWaU4sU0FBU2pILE1BQU1pSCxPQUFBLENBQVFDLE9BQUE7Z0JBQ3ZCaE8sUUFBUzhHLE1BQWM5RyxNQUFBO2dCQUFBO2dCQUN2Qm1JLE9BQVFyQixNQUFjcUIsS0FBQTtnQkFBQTtnQkFDdEI4RixTQUFTbkgsTUFBTW1ILE9BQUEsQ0FBUS9RLEdBQUEsQ0FBSSxDQUFBZ1I7b0JBclNuQyxJQUFBaFksS0FBQUMsSUFBQTRNLElBQUFvTCxJQUFBQyxJQUFBQyxJQUFBQztvQkFxUzhDO3dCQUNwQzNYLE9BQU87NEJBQ0xtRSxTQUFBLENBQVM1RSxNQUFBZ1ksT0FBT3ZYLEtBQUEsS0FBUCxnQkFBQVQsSUFBYzRFLE9BQUE7NEJBQ3ZCeVQsZUFBQSxDQUFlcFksS0FBQStYLE9BQU92WCxLQUFBLEtBQVAsZ0JBQUFSLEdBQWNxWSxZQUFBOzRCQUM3QnRTLE1BQUEsQ0FBTTZHLEtBQUFtTCxPQUFPdlgsS0FBQSxLQUFQLGdCQUFBb00sR0FBYzdHLElBQUE7NEJBQ3BCdVMsWUFBQSxFQUFZTCxLQUFBLENBQUFELEtBQUFELE9BQU92WCxLQUFBLEtBQVAsZ0JBQUF3WCxHQUFjTyxTQUFBLEtBQWQsZ0JBQUFOLEdBQXlCMVksTUFBQSxLQUNqQzRZLEtBQUEsQ0FBQUQsS0FBQUgsT0FBT3ZYLEtBQUEsS0FBUCxnQkFBQTBYLEdBQWNLLFNBQUEsS0FBZCxnQkFBQUosR0FBeUJwUixHQUFBLENBQUksQ0FBQ3lSLFVBQVVqVSxRQUFXO29DQUNqREE7b0NBQ0FvRyxJQUFJNk4sU0FBUzdOLEVBQUE7b0NBQ2I4TixVQUFVRCxTQUFTQyxRQUFBO29DQUNuQnRSLE1BQU1xUixTQUFTclIsSUFBQTtnQ0FDakIsTUFDQTt3QkFDTjt3QkFDQXVSLGVBQWVYLE9BQU83RCxZQUFBO3dCQUN0QjNQLE9BQU93VCxPQUFPeFQsS0FBQTtvQkFDaEI7Z0JBQUE7WUFDRjtRQUNGO1FBRUEsTUFBTTZDLE9BQU9zUSxRQUFRL0c7UUFFckIsSUFBSXZKLE1BQU0sTUFBTUE7SUFDbEI7QUFDRjtBQUVBLFNBQVN1UTtJQUdQLE1BQU1nQixvQkFBb0J4QztJQUMxQixJQUFJeUM7SUFDSixPQUFPLENBQUFDO1FBcFVULElBQUE5WSxLQUFBQyxJQUFBNE0sSUFBQW9MLElBQUFDLElBQUFDLElBQUFDLElBQUFXLElBQUFDLElBQUFDLElBQUFDLElBQUFDLElBQUFDLElBQUFDLElBQUFDLElBQUFDLElBQUFDLElBQUFDO1FBcVVJLElBQUlDLHNCQUFzQlosT0FBTztZQUMvQixNQUFNclksUUFBQSxDQUFRVCxNQUFBOFksS0FBS2YsT0FBQSxDQUFRLEVBQUMsS0FBZCxnQkFBQS9YLElBQWlCUyxLQUFBO1lBQy9CLEtBQUlSLEtBQUFRLE1BQU00WCxhQUFBLEtBQU4sZ0JBQUFwWSxHQUFxQndCLElBQUEsRUFBTTtnQkFDN0JvWCx3QkFBd0I7Z0JBQ3hCLE9BQU87b0JBQ0xjLFFBQVE7b0JBQ1IvVSxTQUFTLCtCQUErQm5FLE1BQU00WCxhQUFBLENBQWM1VyxJQUFJO2dCQUNsRTtZQUNGLFlBQVd5VyxLQUFBLENBQUFELEtBQUEsQ0FBQXBMLEtBQUFwTSxNQUFNOFgsVUFBQSxLQUFOLGdCQUFBMUwsRUFBQSxDQUFtQixPQUFuQixnQkFBQW9MLEdBQXVCUyxRQUFBLEtBQXZCLGdCQUFBUixHQUFpQ3pXLElBQUEsRUFBTTtnQkFDaERvWCx3QkFBd0I7Z0JBQ3hCLE1BQU1KLFdBQVdoWSxNQUFNOFgsVUFBQSxDQUFXLEVBQUM7Z0JBQ25DLElBQUlFLFNBQVNqVSxLQUFBLEtBQVUsR0FBRztvQkFDeEIsT0FBTzt3QkFDTG1WLFFBQVE7d0JBQ1IvVSxTQUFTLDJCQUEyQjZULFNBQVM3TixFQUFFLGlEQUFnRHVOLEtBQUFNLFNBQVNDLFFBQUEsS0FBVCxnQkFBQVAsR0FBbUIxVyxJQUFJO29CQUN4SDtnQkFDRixPQUFPO29CQUNMLE9BQU87d0JBQ0xrWSxRQUFRO3dCQUNSL1UsU0FBUyxnQkFBZ0I2VCxTQUFTN04sRUFBRSxpREFBZ0R3TixLQUFBSyxTQUFTQyxRQUFBLEtBQVQsZ0JBQUFOLEdBQW1CM1csSUFBSTtvQkFDN0c7Z0JBQ0Y7WUFDRixZQUFXc1gsS0FBQXRZLE1BQU00WCxhQUFBLEtBQU4sZ0JBQUFVLEdBQXFCYSxTQUFBLEVBQVc7Z0JBQ3pDLE9BQU87b0JBQ0xELFFBQVE7b0JBQ1IvVSxTQUFTaVYsaUJBQUEsQ0FBaUJiLEtBQUF2WSxNQUFNNFgsYUFBQSxLQUFOLGdCQUFBVyxHQUFxQlksU0FBUztnQkFDMUQ7WUFDRixZQUFXVCxLQUFBLENBQUFELEtBQUEsQ0FBQUQsS0FBQXhZLE1BQU04WCxVQUFBLEtBQU4sZ0JBQUFVLEVBQUEsQ0FBbUIsT0FBbkIsZ0JBQUFDLEdBQXVCUixRQUFBLEtBQXZCLGdCQUFBUyxHQUFpQ1MsU0FBQSxFQUFXO2dCQUNyRCxPQUFPO29CQUNMRCxRQUFRO29CQUNSL1UsU0FBU2lWLGlCQUFBLENBQWlCUCxLQUFBLENBQUFELEtBQUEsQ0FBQUQsS0FBQTNZLE1BQU04WCxVQUFBLEtBQU4sZ0JBQUFhLEVBQUEsQ0FBbUIsT0FBbkIsZ0JBQUFDLEdBQXVCWCxRQUFBLEtBQXZCLGdCQUFBWSxHQUFpQ00sU0FBUztnQkFDdEU7WUFDRixXQUNFZix5QkFBQSxHQUNDVSxLQUFBVCxLQUFLZixPQUFBLENBQVEsRUFBQyxLQUFkLGdCQUFBd0IsR0FBaUJaLGFBQUEsTUFBa0IscUJBQ2xDYSxLQUFBVixLQUFLZixPQUFBLENBQVEsRUFBQyxLQUFkLGdCQUFBeUIsR0FBaUJiLGFBQUEsTUFBa0IsU0FDckM7Z0JBQ0FFLHdCQUF3QjtnQkFDeEIsT0FBTztvQkFDTGMsUUFBUTtvQkFDUi9VLFNBQVM7Z0JBQ1g7WUFDRixXQUNFaVUseUJBQUEsRUFDQVksS0FBQVgsS0FBS2YsT0FBQSxDQUFRLEVBQUMsS0FBZCxnQkFBQTBCLEdBQWlCZCxhQUFBLE1BQWtCLGNBQ25DO2dCQUNBRSx3QkFBd0I7Z0JBQ3hCLE9BQU87b0JBQ0xjLFFBQVE7b0JBQ1IvVSxTQUFTO2dCQUNYO1lBQ0Y7UUFDRjtRQUVBLE1BQU15QyxPQUFPdVIsa0JBQ1hjLHNCQUFzQlosU0FBU0EsS0FBS2YsT0FBQSxDQUFRLEVBQUMsQ0FBRXRYLEtBQUEsQ0FBTW1FLE9BQUEsR0FDakRrVSxLQUFLZixPQUFBLENBQVEsRUFBQyxDQUFFdFgsS0FBQSxDQUFNbUUsT0FBQSxHQUN0QmtWLGFBQWFoQixRQUNiQSxLQUFLZixPQUFBLENBQVEsRUFBQyxDQUFFMVEsSUFBQSxHQUNoQjtRQUdOLE9BQU9BO0lBQ1Q7SUFFQSxTQUFTd1MsaUJBQWlCRSxhQUFBO1FBQ3hCLElBQUlDLHFCQUFxQkQsY0FDdEJFLE9BQUEsQ0FBUSxPQUFPLFFBQ2ZBLE9BQUEsQ0FBUSxPQUFPLE9BQ2ZBLE9BQUEsQ0FBUSxNQUFNLE9BQ2RBLE9BQUEsQ0FBUSxPQUFPLE9BQ2ZBLE9BQUEsQ0FBUSxPQUFPLE9BQ2ZBLE9BQUEsQ0FBUSxPQUFPLE9BQ2ZBLE9BQUEsQ0FBUSxPQUFPO1FBRWxCLE9BQU8sR0FBR0QsbUJBQWtCO0lBQzlCO0FBQ0Y7QUFFQSxJQUFNRSxxQ0FBcUMxWCxPQUN6QztBQWFGLFNBQVNrWCxzQkFDUDdWLElBQUE7SUFFQSxPQUNFLGFBQWFBLFFBQ2JBLEtBQUtrVSxPQUFBLElBQ0xsVSxLQUFLa1UsT0FBQSxDQUFRLEVBQUMsSUFDZCxXQUFXbFUsS0FBS2tVLE9BQUEsQ0FBUSxFQUFDO0FBRTdCO0FBRUEsU0FBUytCLGFBQWFqVyxJQUFBO0lBQ3BCLE9BQ0UsYUFBYUEsUUFDYkEsS0FBS2tVLE9BQUEsSUFDTGxVLEtBQUtrVSxPQUFBLENBQVEsRUFBQyxJQUNkLFVBQVVsVSxLQUFLa1UsT0FBQSxDQUFRLEVBQUM7QUFFNUI7QUFLTyxTQUFTb0MsYUFDZHJjLEdBQUEsRUFDQTRYLFNBQUE7SUFHQSxNQUFNSixLQUlHSTtJQUVULElBQUlqQztJQUNKLElBQUlqUixPQUFPcU0sYUFBQSxJQUFpQi9RLEtBQUs7UUFDL0IyVixTQUFTc0QsMEJBQTBCbEYsV0FBVy9ULE1BQU0rWSxXQUFBLENBQ2xEeEIsMkJBQUEsQ0FDRUMsTUFBQSxnQkFBQUEsR0FBSThFLDJCQUFBLEtBQStCOUUsQ0FBQUEsTUFBQSxnQkFBQUEsR0FBSStFLHVCQUFBLElBQ25DO1lBQ0UsR0FBRy9FLEVBQUE7WUFDSGEsU0FBUztRQUNYLElBQ0E7WUFDRSxHQUFHYixFQUFBO1FBQ0w7SUFHVixPQUFPO1FBQ0w3QixTQUFTOEMsU0FDUHpZLEtBQ0E0WixxQkFBa0IsQ0FDbEJwQyxNQUFBLGdCQUFBQSxHQUFJOEUsMkJBQUEsS0FBK0I5RSxDQUFBQSxNQUFBLGdCQUFBQSxHQUFJK0UsdUJBQUEsSUFDbkM7WUFDRSxHQUFHL0UsRUFBQTtZQUNIYSxTQUFTO1FBQ1gsSUFDQTtZQUNFLEdBQUdiLEVBQUE7UUFDTDtJQUVSO0lBRUEsSUFBSUEsTUFBT0EsQ0FBQUEsR0FBRzhFLDJCQUFBLElBQStCOUUsR0FBRytFLHVCQUFBLEdBQTBCO1FBQ3hFLE1BQU1DLDBCQUEwQkMsOEJBQThCakY7UUFDOUQsT0FBTzdCLE9BQU9vRCxXQUFBLENBQVl5RDtJQUM1QixPQUFPO1FBQ0wsT0FBTzdHLE9BQU9vRCxXQUFBLENBQVlTO0lBQzVCO0FBQ0Y7QUFFQSxTQUFTaUQsOEJBQ1A3RSxTQUFBO0lBSUEsTUFBTUgsY0FBYyxJQUFJQztJQUN4QixJQUFJZ0YsZUFBZTtJQUNuQixJQUFJL0UscUJBQXFCO0lBQ3pCLElBQUlnRixvQ0FBb0M7SUFDeEMsSUFBSTVCLHdCQUF3QjtJQUU1QixJQUFJNkIsdUJBQ0ZoRixTQUFBLENBQVV3RSxtQ0FBa0MsSUFBSyxFQUFDO0lBRXBELE1BQU1wVSxTQUFTMlIscUVBQWtCQTtJQUVqQyxPQUFPLElBQUk3QyxnQkFBZ0I7UUFDekIsTUFBTU8sV0FBVXZFLEtBQUEsRUFBT2tFLFVBQUE7WUFDckIsTUFBTTFXLFVBQVUwSCxPQUFPOEs7WUFDdkI2SixxQ0FBcUNyYztZQUVyQyxNQUFNdWMseUJBQ0pILGdCQUNDcGMsQ0FBQUEsUUFBUStKLFVBQUEsQ0FBVyx3QkFDbEIvSixRQUFRK0osVUFBQSxDQUFXLGlCQUFnQjtZQUV2QyxJQUFJd1Msd0JBQXdCO2dCQUMxQjlCLHdCQUF3QjtnQkFDeEJwRCxzQkFBc0JyWDtnQkFDdEJvYyxlQUFlO2dCQUNmO1lBQ0Y7WUFHQSxJQUFJLENBQUMzQix1QkFBdUI7Z0JBQzFCL0QsV0FBV0ksT0FBQSxDQUNUSyxZQUFZSyxNQUFBLENBQU95QixtRUFBQUEsQ0FBaUIsUUFBUWpaO2dCQUU5QztZQUNGLE9BQU87Z0JBQ0xxWCxzQkFBc0JyWDtZQUN4QjtRQUNGO1FBQ0EsTUFBTTJYLE9BQU1qQixVQUFBO1lBQ1YsSUFBSTtnQkFDRixJQUNFLENBQUMwRixnQkFDRDNCLHlCQUNDbkQsQ0FBQUEsVUFBVTBFLDJCQUFBLElBQ1QxRSxVQUFVMkUsdUJBQUEsR0FDWjtvQkFDQXhCLHdCQUF3QjtvQkFDeEIsTUFBTStCLFVBQVU5YixLQUFLQyxLQUFBLENBQU0wVztvQkFFM0IsSUFBSW9GLDBCQUEyQzsyQkFDMUNIO3FCQUNMO29CQUVBLElBQUlJLG1CQU1ZO29CQUVoQixJQUFJcEYsVUFBVTBFLDJCQUFBLEVBQTZCO3dCQUl6QyxJQUFJUSxRQUFRdkMsYUFBQSxLQUFrQixRQUFXOzRCQUN2QzFHLFFBQVFDLElBQUEsQ0FDTjt3QkFFSjt3QkFFQSxNQUFNbUosbUJBQW1CamMsS0FBS0MsS0FBQSxDQUM1QjZiLFFBQVF2QyxhQUFBLENBQWN1QixTQUFBO3dCQUd4QmtCLG1CQUFtQixNQUFNcEYsVUFBVTBFLDJCQUFBLENBQ2pDOzRCQUNFM1ksTUFBTW1aLFFBQVF2QyxhQUFBLENBQWM1VyxJQUFBOzRCQUM1Qm1ZLFdBQVdtQjt3QkFDYixHQUNBLENBQUEvWjs0QkFFRTZaLDBCQUEwQjttQ0FDckJIO2dDQUNIO29DQUNFMVUsTUFBTTtvQ0FDTnBCLFNBQVM7b0NBQ1R5VCxlQUFldUMsUUFBUXZDLGFBQUE7Z0NBQ3pCO2dDQUNBO29DQUNFclMsTUFBTTtvQ0FDTnZFLE1BQU1tWixRQUFRdkMsYUFBQSxDQUFjNVcsSUFBQTtvQ0FDNUJtRCxTQUFTOUYsS0FBS0UsU0FBQSxDQUFVZ0M7Z0NBQzFCOzZCQUNGOzRCQUVBLE9BQU82Wjt3QkFDVDtvQkFFSjtvQkFDQSxJQUFJbkYsVUFBVTJFLHVCQUFBLEVBQXlCO3dCQUNyQyxNQUFNN0IsWUFBNkI7NEJBQ2pDdk8sT0FBTyxFQUFDO3dCQUNWO3dCQUNBLFdBQVdNLFFBQVFxUSxRQUFRckMsVUFBQSxDQUFZOzRCQUNyQ0MsVUFBVXZPLEtBQUEsQ0FBTWdELElBQUEsQ0FBSztnQ0FDbkJyQyxJQUFJTCxLQUFLSyxFQUFBO2dDQUNUeEQsTUFBTTtnQ0FDTjRULE1BQU07b0NBQ0p2WixNQUFNOEksS0FBS21PLFFBQUEsQ0FBU2pYLElBQUE7b0NBQ3BCbVksV0FBVzlhLEtBQUtDLEtBQUEsQ0FBTXdMLEtBQUttTyxRQUFBLENBQVNrQixTQUFTO2dDQUMvQzs0QkFDRjt3QkFDRjt3QkFDQSxJQUFJcUIsZ0JBQWdCO3dCQUNwQixJQUFJOzRCQUNGSCxtQkFBbUIsTUFBTXBGLFVBQVUyRSx1QkFBQSxDQUNqQzdCLFdBQ0EsQ0FBQXhYO2dDQUNFLElBQUlBLFFBQVE7b0NBQ1YsTUFBTSxFQUFFa2EsWUFBQSxFQUFjQyxhQUFBLEVBQWVDLGdCQUFBLEVBQWlCLEdBQ3BEcGE7b0NBRUY2WiwwQkFBMEI7MkNBQ3JCQTt3Q0FBQTsyQ0FFQ0ksa0JBQWtCLElBQ2xCOzRDQUNFO2dEQUNFalYsTUFBTTtnREFDTnBCLFNBQVM7Z0RBQ1QyVCxZQUFZcUMsUUFBUXJDLFVBQUEsQ0FBV3ZSLEdBQUEsQ0FDN0IsQ0FBQ3FVLEtBQWtCO3dEQUNqQnpRLElBQUl5USxHQUFHelEsRUFBQTt3REFDUHhELE1BQU07d0RBQ05zUixVQUFVOzREQUNSalgsTUFBTTRaLEdBQUczQyxRQUFBLENBQVNqWCxJQUFBOzREQUFBOzREQUVsQm1ZLFdBQVc5YSxLQUFLRSxTQUFBLENBQ2RxYyxHQUFHM0MsUUFBQSxDQUFTa0IsU0FBQTt3REFFaEI7b0RBQ0Y7NENBRUo7eUNBQ0YsR0FDQSxFQUFDO3dDQUFBO3dDQUVMOzRDQUNFNVQsTUFBTTs0Q0FDTmtWOzRDQUNBelosTUFBTTBaOzRDQUNOdlcsU0FBUzlGLEtBQUtFLFNBQUEsQ0FBVW9jO3dDQUMxQjtxQ0FDRjtvQ0FDQUg7Z0NBQ0Y7Z0NBRUEsT0FBT0o7NEJBQ1Q7d0JBRUosU0FBU1MsR0FBRzs0QkFDVjNKLFFBQVExTyxLQUFBLENBQU0sMENBQTBDcVk7d0JBQzFEO29CQUNGO29CQUVBLElBQUksQ0FBQ1Isa0JBQWtCO3dCQUlyQmhHLFdBQVdJLE9BQUEsQ0FDVEssWUFBWUssTUFBQSxDQUNWeUIsbUVBQUFBLENBQ0V1RCxRQUFRdkMsYUFBQSxHQUFnQixrQkFBa0I7d0JBRTFDdlosS0FBS0MsS0FBQSxDQUFNMFc7d0JBSWpCO29CQUNGLFdBQVcsT0FBT3FGLHFCQUFxQixVQUFVO3dCQUUvQ2hHLFdBQVdJLE9BQUEsQ0FDVEssWUFBWUssTUFBQSxDQUFPeUIsbUVBQUFBLENBQWlCLFFBQVF5RDt3QkFFOUNMLG9DQUFvQ0s7d0JBQ3BDO29CQUNGO29CQU9BLE1BQU1TLG9CQUEyQzt3QkFDL0MsR0FBRzdGLFNBQUE7d0JBQ0hDLFNBQVM7b0JBQ1g7b0JBRUFELFVBQVVTLE9BQUEsR0FBVTtvQkFFcEIsTUFBTXFGLGVBQWVyQixhQUFhVyxrQkFBa0I7d0JBQ2xELEdBQUdTLGlCQUFBO3dCQUNILENBQUNyQixtQ0FBa0MsRUFBR1c7b0JBQ3hDO29CQUVBLE1BQU1oSCxTQUFTMkgsYUFBYTFILFNBQUE7b0JBRTVCLE1BQU8sS0FBTTt3QkFDWCxNQUFNLEVBQUUvVCxJQUFBLEVBQU05QixLQUFBLEVBQU0sR0FBSSxNQUFNNFYsT0FBT0UsSUFBQTt3QkFDckMsSUFBSWhVLE1BQU07NEJBQ1I7d0JBQ0Y7d0JBQ0ErVSxXQUFXSSxPQUFBLENBQVFqWDtvQkFDckI7Z0JBQ0Y7WUFDRixTQUFFO2dCQUNBLElBQUl5WCxVQUFVUyxPQUFBLElBQVdzRSxtQ0FBbUM7b0JBQzFELE1BQU0vRSxVQUFVUyxPQUFBLENBQVFzRTtnQkFDMUI7WUFDRjtRQUNGO0lBQ0Y7QUFDRjs7QUNuc0JBLGVBQXNCZ0IsY0FBY2hJLE1BQUE7SUFDbEMsTUFBTUksU0FBU0osT0FBT0ssU0FBQTtJQUN0QixNQUFPLEtBQU07UUFDWCxNQUFNLEVBQUUvVCxJQUFBLEVBQUssR0FBSSxNQUFNOFQsT0FBT0UsSUFBQTtRQUM5QixJQUFJaFUsTUFBTTtJQUNaO0FBQ0Y7O0FKU08sU0FBUzJTLE9BT2RoVSxPQUFBO0lBZ0RBLE1BQU00VCxLQUFLcEIsbUJBQW1CeFMsUUFBUXlULE9BQU87SUFHN0MsTUFBTTlLLE9BQU8zSSxRQUFRMkksSUFBQSxHQUNqQjNJLFFBQVEySSxJQUFBLEdBQ1IsQ0FBQyxFQUFFekMsT0FBQSxFQUFRLEdBQTJCQTtJQUUxQyxNQUFNOFcsWUFBWWhkLFFBQVFnZCxTQUFBLEdBQ3RCblQsT0FBTzhCLE9BQUEsQ0FBUTNMLFFBQVFnZCxTQUFTLEVBQUUxVSxHQUFBLENBQ2hDLENBQUMsQ0FBQ3ZGLE9BQU0sRUFBRWdKLFdBQUEsRUFBYUMsVUFBQSxFQUFZO1FBQ2pDLE9BQU87WUFDTGpKLE1BQUFBO1lBQ0FnSjtZQUNBQyxZQUFZNEosK0RBQWVBLENBQUM1SjtRQUM5QjtJQUNGLEtBRUY7SUFFSixNQUFNVCxRQUFRdkwsUUFBUXVMLEtBQUEsR0FDbEIxQixPQUFPOEIsT0FBQSxDQUFRM0wsUUFBUXVMLEtBQUssRUFBRWpELEdBQUEsQ0FDNUIsQ0FBQyxDQUFDdkYsT0FBTSxFQUFFZ0osV0FBQSxFQUFhQyxVQUFBLEVBQVk7UUFDakMsT0FBTztZQUNMdEQsTUFBTTtZQUNOc1IsVUFBVTtnQkFDUmpYLE1BQUFBO2dCQUNBZ0o7Z0JBQ0FDLFlBQVk0SiwrREFBZUEsQ0FBQzVKO1lBSTlCO1FBQ0Y7SUFDRixLQUVGO0lBRUosSUFBSWdSLGFBQWF6UixPQUFPO1FBQ3RCLE1BQU0sSUFBSTFMLE1BQ1I7SUFFSjtJQUVBLElBQUlpVTtJQUVKLGVBQWVtSixhQUNicGMsSUFBQSxFQUNBb1QsUUFBQSxFQUNBN1UsR0FBQTtRQUVBLElBQUksQ0FBQzZVLFVBQVU7UUFFZixNQUFNYixhQUFhclU7UUFFbkIsSUFBSStVLFVBQVU7WUFDWkEsV0FBV0EsU0FBU08sSUFBQSxDQUFLLElBQU1qQixXQUFXbFUsT0FBTztRQUNuRCxPQUFPO1lBQ0w0VSxXQUFXVixXQUFXbFUsT0FBQTtRQUN4QjtRQUVBLE1BQU1LLFFBQVEwVSxTQUFTcFQ7UUFDdkIsSUFDRXRCLGlCQUFpQkosV0FDaEJJLFNBQ0MsT0FBT0EsVUFBVSxZQUNqQixVQUFVQSxTQUNWLE9BQU9BLE1BQU04VSxJQUFBLEtBQVMsWUFDeEI7WUFDQSxNQUFNRSxPQUFPLE1BQU9oVjtZQUNwQkgsSUFBSXdDLE1BQUEsQ0FBTzJTO1lBQ1huQixXQUFXcFUsT0FBQSxDQUFRO1FBQ3JCLFdBQ0VPLFNBQ0EsT0FBT0EsVUFBVSxZQUNqQnVFLE9BQU9xTSxhQUFBLElBQWlCNVEsT0FDeEI7WUFDQSxNQUFNZ1osS0FBS2haO1lBS1gsTUFBTyxLQUFNO2dCQUNYLE1BQU0sRUFBRThCLElBQUEsRUFBTTlCLE9BQUFBLE1BQUFBLEVBQU0sR0FBSSxNQUFNZ1osR0FBR3RHLElBQUE7Z0JBQ2pDN1MsSUFBSXdDLE1BQUEsQ0FBT3JDO2dCQUNYLElBQUk4QixNQUFNO1lBQ1o7WUFDQStSLFdBQVdwVSxPQUFBLENBQVE7UUFDckIsV0FBV08sU0FBUyxPQUFPQSxVQUFVLFlBQVl1RSxPQUFPdU0sUUFBQSxJQUFZOVEsT0FBTztZQUN6RSxNQUFNZ1osS0FBS2haO1lBQ1gsTUFBTyxLQUFNO2dCQUNYLE1BQU0sRUFBRThCLElBQUEsRUFBTTlCLE9BQUFBLE1BQUFBLEVBQU0sR0FBSWdaLEdBQUd0RyxJQUFBO2dCQUMzQjdTLElBQUl3QyxNQUFBLENBQU9yQztnQkFDWCxJQUFJOEIsTUFBTTtZQUNaO1lBQ0ErUixXQUFXcFUsT0FBQSxDQUFRO1FBQ3JCLE9BQU87WUFDTEksSUFBSXdDLE1BQUEsQ0FBT3JDO1lBQ1g2VCxXQUFXcFUsT0FBQSxDQUFRO1FBQ3JCO0lBQ0Y7SUFFQztRQUNDLElBQUlrZSxjQUFjO1FBQ2xCLElBQUloWCxVQUFVO1FBRWQ2VyxjQUNFdEIsYUFDRyxNQUFNemIsUUFBUW1kLFFBQUEsQ0FBU0MsSUFBQSxDQUFLQyxXQUFBLENBQVlDLE1BQUEsQ0FBTztZQUM5Qy9KLE9BQU92VCxRQUFRdVQsS0FBQTtZQUNmbkwsVUFBVXBJLFFBQVFvSSxRQUFBO1lBQ2xCb0MsYUFBYXhLLFFBQVF3SyxXQUFBO1lBQ3JCdUssUUFBUTtZQUNSLEdBQUlpSSxZQUNBO2dCQUNFQTtZQUNGLElBQ0EsQ0FBQztZQUNMLEdBQUl6UixRQUNBO2dCQUNFQTtZQUNGLElBQ0EsQ0FBQztRQUNQLElBQ0E7WUFDRSxHQUFJeVIsWUFDQTtnQkFDRSxNQUFNdEIsNkJBQTRCNkIsbUJBQUE7b0JBOU1sRCxJQUFBamMsS0FBQUM7b0JBK01rQjJiLGNBQWM7b0JBQ2RELGFBQ0VNLG9CQUFvQnJDLFNBQUEsR0FDcEIzWixLQUFBLENBQUFELE1BQUF0QixRQUFRZ2QsU0FBQSxLQUFSLGdCQUFBMWIsR0FBQUEsQ0FBb0JpYyxvQkFBb0J4YSxJQUFBLE1BQXhDLGdCQUFBeEIsR0FDSXlTLE1BQUEsRUFDSko7Z0JBRUo7WUFDRixJQUNBLENBQUM7WUFDTCxHQUFJckksUUFDQTtnQkFDRSxNQUFNb1EseUJBQXdCNkIsZUFBQTtvQkEzTjlDLElBQUFsYyxLQUFBQztvQkE0TmtCMmIsY0FBYztvQkFHZCxXQUFXclIsUUFBUTJSLGdCQUFnQmpTLEtBQUEsQ0FBTzt3QkFDeEMwUixhQUNFcFIsS0FBS3lRLElBQUEsQ0FBS3BCLFNBQUEsR0FDVjNaLEtBQUEsQ0FBQUQsTUFBQXRCLFFBQVF1TCxLQUFBLEtBQVIsZ0JBQUFqSyxHQUFBQSxDQUFnQnVLLEtBQUt5USxJQUFBLENBQUt2WixJQUFBLE1BQTFCLGdCQUFBeEIsR0FBd0N5UyxNQUFBLEVBQ3hDSjtvQkFFSjtnQkFDRjtZQUNGLElBQ0EsQ0FBQztZQUNMd0QsUUFBT2xGLEtBQUE7Z0JBQ0xoTSxXQUFXZ007Z0JBQ1grSyxhQUFhO29CQUFFL1c7b0JBQVM3RSxNQUFNO29CQUFPVSxPQUFPbVE7Z0JBQU0sR0FBR3ZKLE1BQU1pTDtZQUM3RDtZQUNBLE1BQU02RDtnQkFDSixJQUFJeUYsYUFBYTtvQkFDZixNQUFNcEo7b0JBQ05GLEdBQUd2UyxJQUFBO29CQUNIO2dCQUNGO2dCQUVBNGIsYUFBYTtvQkFBRS9XO29CQUFTN0UsTUFBTTtnQkFBSyxHQUFHc0gsTUFBTWlMO2dCQUM1QyxNQUFNRTtnQkFDTkYsR0FBR3ZTLElBQUE7WUFDTDtRQUNGO0lBR047SUFFQSxPQUFPdVMsR0FBR3JVLEtBQUE7QUFDWjs7QUs5UE8sSUFBTWtlLHdCQUF3QjNaLE9BQU9DLEdBQUEsQ0FBSTs7QUNRaEQsSUFBTTJaLGlDQUFpQzVaLE9BQU87QUFNOUMsU0FBUzZaLHNCQUNQckwsWUFBQTtJQUVBLE1BQU1zTCxtQkFDSnRMLHdCQUF3QnlGLGtCQUN2QixPQUFPekYsaUJBQWlCLFlBQ3ZCQSxpQkFBaUIsUUFDakIsZUFBZUEsZ0JBQ2YsT0FBT0EsYUFBYThDLFNBQUEsS0FBYyxjQUNsQyxZQUFZOUMsZ0JBQ1osT0FBT0EsYUFBYXVMLE1BQUEsS0FBVztJQUVuQyxJQUFJLENBQUNELGtCQUFrQjtRQUNyQixPQUFPRSwwQkFBZ0N4TDtJQUN6QztJQUVBLE1BQU15TCxrQkFBa0JEO0lBTXhCQyxlQUFBLENBQWdCTCwrQkFBOEIsR0FBSTtJQUVqRDtRQUNDLElBQUk7WUFFRixNQUFNdkksU0FBUzdDLGFBQWE4QyxTQUFBO1lBRTVCLE1BQU8sS0FBTTtnQkFDWCxNQUFNLEVBQUU3VixLQUFBLEVBQU84QixJQUFBLEVBQUssR0FBSSxNQUFNOFQsT0FBT0UsSUFBQTtnQkFDckMsSUFBSWhVLE1BQU07b0JBQ1I7Z0JBQ0Y7Z0JBR0EwYyxlQUFBLENBQWdCTCwrQkFBOEIsR0FBSTtnQkFDbEQsSUFBSSxPQUFPbmUsVUFBVSxVQUFVO29CQUM3QndlLGdCQUFnQjVMLE1BQUEsQ0FBTzVTO2dCQUN6QixPQUFPO29CQUNMd2UsZ0JBQWdCbmMsTUFBQSxDQUFPckM7Z0JBQ3pCO2dCQUVBd2UsZUFBQSxDQUFnQkwsK0JBQThCLEdBQUk7WUFDcEQ7WUFFQUssZUFBQSxDQUFnQkwsK0JBQThCLEdBQUk7WUFDbERLLGdCQUFnQjFjLElBQUE7UUFDbEIsU0FBU3ViLEdBQUc7WUFDVm1CLGVBQUEsQ0FBZ0JMLCtCQUE4QixHQUFJO1lBQ2xESyxnQkFBZ0J4WixLQUFBLENBQU1xWTtRQUN4QjtJQUNGO0lBRUEsT0FBT21CO0FBQ1Q7QUF1REEsU0FBU0QsMEJBQTRDeEwsWUFBQTtJQUNuRCxJQUFJSSxTQUFTO0lBQ2IsSUFBSW1MLFNBQVM7SUFDYixJQUFJekssYUFBYXJVO0lBRWpCLElBQUkwVCxlQUFlSDtJQUNuQixJQUFJMEw7SUFDSixJQUFJQyxpQkFDRjdLLFdBQVdsVSxPQUFBO0lBQ2IsSUFBSWdmO0lBRUosU0FBU3ZMLGFBQWFDLE1BQUE7UUFDcEIsSUFBSUYsUUFBUTtZQUNWLE1BQU0sSUFBSTdTLE1BQU0rUyxTQUFTO1FBQzNCO1FBQ0EsSUFBSWlMLFFBQVE7WUFDVixNQUFNLElBQUloZSxNQUNSK1MsU0FBUztRQUViO0lBQ0Y7SUFFQSxJQUFJQztJQUNKLFNBQVNDO1FBQ1AsSUFBSUMsSUFBeUIsRUFBZTtZQUMxQyxJQUFJRixnQkFBZ0I7Z0JBQ2xCRyxhQUFhSDtZQUNmO1lBQ0FBLGlCQUFpQm5DLFdBQVc7Z0JBQzFCdUMsUUFBUUMsSUFBQSxDQUNOO1lBRUosR0FBR3hCO1FBQ0w7SUFDRjtJQUNBb0I7SUFFQSxTQUFTcUwsY0FBY0MsWUFBQTtRQUVyQixJQUFJQztRQUVKLElBQUlMLGlCQUFpQixRQUFXO1lBQzlCSyxPQUFPO2dCQUFFOVosT0FBT3laO1lBQWE7UUFDL0IsT0FBTztZQUNMLElBQUlFLHFCQUFxQixDQUFDRSxjQUFjO2dCQUN0Q0MsT0FBTztvQkFBRXJjLE1BQU1rYztnQkFBa0I7WUFDbkMsT0FBTztnQkFDTEcsT0FBTztvQkFBRUMsTUFBTTdMO2dCQUFhO1lBQzlCO1FBQ0Y7UUFFQSxJQUFJd0wsZ0JBQWdCO1lBQ2xCSSxLQUFLcE0sSUFBQSxHQUFPZ007UUFDZDtRQUVBLElBQUlHLGNBQWM7WUFDaEJDLEtBQUszVixJQUFBLEdBQU8rVTtRQUNkO1FBRUEsT0FBT1k7SUFDVDtJQUdBLFNBQVNFLGtCQUFrQmhmLEtBQUE7UUFFekIyZSxvQkFBb0I7UUFDcEIsSUFBSSxPQUFPM2UsVUFBVSxVQUFVO1lBQzdCLElBQUksT0FBT2tULGlCQUFpQixVQUFVO2dCQUNwQyxJQUFJbFQsTUFBTWtLLFVBQUEsQ0FBV2dKLGVBQWU7b0JBQ2xDeUwsb0JBQW9CO3dCQUFDO3dCQUFHM2UsTUFBTWlmLEtBQUEsQ0FBTS9MLGFBQWEzUixNQUFNO3FCQUFDO2dCQUMxRDtZQUNGO1FBQ0Y7UUFFQTJSLGVBQWVsVDtJQUNqQjtJQUVBLE1BQU00VCxjQUEyQztRQUMvQyxLQUFLdUssK0JBQThCLEVBQUUzZCxNQUFnQjtZQUNuRDhkLFNBQVM5ZDtRQUNYO1FBQ0EsSUFBSVIsU0FBUTtZQUNWLE9BQU80ZSxjQUFjO1FBQ3ZCO1FBQ0F2YyxRQUFPckMsS0FBQTtZQUNMb1QsYUFBYTtZQUViLE1BQU04TCxrQkFBa0JyTCxXQUFXcFUsT0FBQTtZQUNuQ29VLGFBQWFyVTtZQUVid2Ysa0JBQWtCaGY7WUFDbEIwZSxpQkFBaUI3SyxXQUFXbFUsT0FBQTtZQUM1QnVmLGdCQUFnQk47WUFFaEJyTDtZQUVBLE9BQU9LO1FBQ1Q7UUFDQWhCLFFBQU81UyxLQUFBO1lBQ0xvVCxhQUFhO1lBRWIsSUFDRSxPQUFPRixpQkFBaUIsWUFDeEIsT0FBT0EsaUJBQWlCLGFBQ3hCO2dCQUNBLE1BQU0sSUFBSTVTLE1BQ1IsMkRBQTJELE9BQU80UyxhQUFZO1lBRWxGO1lBQ0EsSUFBSSxPQUFPbFQsVUFBVSxVQUFVO2dCQUM3QixNQUFNLElBQUlNLE1BQ1IsbURBQW1ELE9BQU9OLE1BQUs7WUFFbkU7WUFFQSxNQUFNa2Ysa0JBQWtCckwsV0FBV3BVLE9BQUE7WUFDbkNvVSxhQUFhclU7WUFFYixJQUFJLE9BQU8wVCxpQkFBaUIsVUFBVTtnQkFDcEN5TCxvQkFBb0I7b0JBQUM7b0JBQUczZTtpQkFBSztnQkFDNUJrVCxlQUEwQkEsZUFBZWxUO1lBQzVDLE9BQU87Z0JBQ0wyZSxvQkFBb0I7Z0JBQ3BCekwsZUFBZWxUO1lBQ2pCO1lBRUEwZSxpQkFBaUI3SyxXQUFXbFUsT0FBQTtZQUM1QnVmLGdCQUFnQk47WUFFaEJyTDtZQUVBLE9BQU9LO1FBQ1Q7UUFDQTVPLE9BQU1BLEtBQUE7WUFDSm9PLGFBQWE7WUFFYixJQUFJRSxnQkFBZ0I7Z0JBQ2xCRyxhQUFhSDtZQUNmO1lBQ0FILFNBQVM7WUFDVHNMLGVBQWV6WjtZQUNmMFosaUJBQWlCO1lBRWpCN0ssV0FBV3BVLE9BQUEsQ0FBUTtnQkFBRXVGO1lBQU07WUFFM0IsT0FBTzRPO1FBQ1Q7UUFDQTlSLE1BQUEsR0FBUVIsSUFBQTtZQUNOOFIsYUFBYTtZQUViLElBQUlFLGdCQUFnQjtnQkFDbEJHLGFBQWFIO1lBQ2Y7WUFDQUgsU0FBUztZQUNUdUwsaUJBQWlCO1lBRWpCLElBQUlwZCxLQUFLQyxNQUFBLEVBQVE7Z0JBQ2Z5ZCxrQkFBa0IxZCxJQUFBLENBQUssRUFBRTtnQkFDekJ1UyxXQUFXcFUsT0FBQSxDQUFRbWY7Z0JBQ25CLE9BQU9oTDtZQUNUO1lBRUFDLFdBQVdwVSxPQUFBLENBQVEsQ0FBQztZQUVwQixPQUFPbVU7UUFDVDtJQUNGO0lBRUEsT0FBT0E7QUFDVCIsInNvdXJjZXMiOlsid2VicGFjazovL2xhbmdjaGFpbi1uZXh0anMtdGVtcGxhdGUvLi4vYWktc3RhdGUudHN4PzM4MDAiLCJ3ZWJwYWNrOi8vbGFuZ2NoYWluLW5leHRqcy10ZW1wbGF0ZS8uLi8uLi91dGlsL2NyZWF0ZS1yZXNvbHZhYmxlLXByb21pc2UudHM/NzUwZSIsIndlYnBhY2s6Ly9sYW5nY2hhaW4tbmV4dGpzLXRlbXBsYXRlLy4uLy4uL3V0aWwvaXMtZnVuY3Rpb24udHM/MmQ0YyIsIndlYnBhY2s6Ly9sYW5nY2hhaW4tbmV4dGpzLXRlbXBsYXRlLy4uL3Byb3ZpZGVyLnRzeD8zMGViIiwid2VicGFjazovL2xhbmdjaGFpbi1uZXh0anMtdGVtcGxhdGUvLi4vc3RyZWFtLXVpL3N0cmVhbS11aS50c3g/MWNjYSIsIndlYnBhY2s6Ly9sYW5nY2hhaW4tbmV4dGpzLXRlbXBsYXRlLy4uLy4uL3V0aWwvZG93bmxvYWQtZXJyb3IudHM/NmE3NSIsIndlYnBhY2s6Ly9sYW5nY2hhaW4tbmV4dGpzLXRlbXBsYXRlLy4uLy4uL3V0aWwvZG93bmxvYWQudHM/NjdhYyIsIndlYnBhY2s6Ly9sYW5nY2hhaW4tbmV4dGpzLXRlbXBsYXRlLy4uLy4uL2NvcmUvdXRpbC9kZXRlY3QtaW1hZ2UtbWltZXR5cGUudHM/OTU0NSIsIndlYnBhY2s6Ly9sYW5nY2hhaW4tbmV4dGpzLXRlbXBsYXRlLy4uLy4uL2NvcmUvcHJvbXB0L2RhdGEtY29udGVudC50cz9lOTJmIiwid2VicGFjazovL2xhbmdjaGFpbi1uZXh0anMtdGVtcGxhdGUvLi4vLi4vY29yZS9wcm9tcHQvaW52YWxpZC1kYXRhLWNvbnRlbnQtZXJyb3IudHM/ZjJmZSIsIndlYnBhY2s6Ly9sYW5nY2hhaW4tbmV4dGpzLXRlbXBsYXRlLy4uLy4uL2NvcmUvcHJvbXB0L2ludmFsaWQtbWVzc2FnZS1yb2xlLWVycm9yLnRzPzg5NzAiLCJ3ZWJwYWNrOi8vbGFuZ2NoYWluLW5leHRqcy10ZW1wbGF0ZS8uLi8uLi9jb3JlL3Byb21wdC9zcGxpdC1kYXRhLXVybC50cz9hODdmIiwid2VicGFjazovL2xhbmdjaGFpbi1uZXh0anMtdGVtcGxhdGUvLi4vLi4vY29yZS9wcm9tcHQvY29udmVydC10by1sYW5ndWFnZS1tb2RlbC1wcm9tcHQudHM/NzE3NCIsIndlYnBhY2s6Ly9sYW5nY2hhaW4tbmV4dGpzLXRlbXBsYXRlLy4uLy4uL2Vycm9ycy9pbnZhbGlkLWFyZ3VtZW50LWVycm9yLnRzP2Y0MjEiLCJ3ZWJwYWNrOi8vbGFuZ2NoYWluLW5leHRqcy10ZW1wbGF0ZS8uLi8uLi9jb3JlL3Byb21wdC9wcmVwYXJlLWNhbGwtc2V0dGluZ3MudHM/ZDU4YyIsIndlYnBhY2s6Ly9sYW5nY2hhaW4tbmV4dGpzLXRlbXBsYXRlLy4uLy4uL2NvcmUvcHJvbXB0L3ByZXBhcmUtdG9vbHMtYW5kLXRvb2wtY2hvaWNlLnRzPzE4YTAiLCJ3ZWJwYWNrOi8vbGFuZ2NoYWluLW5leHRqcy10ZW1wbGF0ZS8uLi8uLi9jb3JlL3V0aWwvaXMtbm9uLWVtcHR5LW9iamVjdC50cz9jYWM4Iiwid2VicGFjazovL2xhbmdjaGFpbi1uZXh0anMtdGVtcGxhdGUvLi4vLi4vY29yZS9wcm9tcHQvc3RhbmRhcmRpemUtcHJvbXB0LnRzPzQ0ZmYiLCJ3ZWJwYWNrOi8vbGFuZ2NoYWluLW5leHRqcy10ZW1wbGF0ZS8uLi8uLi9jb3JlL3Byb21wdC9tZXNzYWdlLnRzPzM3MGIiLCJ3ZWJwYWNrOi8vbGFuZ2NoYWluLW5leHRqcy10ZW1wbGF0ZS8uLi8uLi9jb3JlL3R5cGVzL3Byb3ZpZGVyLW1ldGFkYXRhLnRzPzc2MzUiLCJ3ZWJwYWNrOi8vbGFuZ2NoYWluLW5leHRqcy10ZW1wbGF0ZS8uLi8uLi9jb3JlL3R5cGVzL2pzb24tdmFsdWUudHM/N2JhMiIsIndlYnBhY2s6Ly9sYW5nY2hhaW4tbmV4dGpzLXRlbXBsYXRlLy4uLy4uL2NvcmUvcHJvbXB0L2NvbnRlbnQtcGFydC50cz80MWU0Iiwid2VicGFjazovL2xhbmdjaGFpbi1uZXh0anMtdGVtcGxhdGUvLi4vLi4vY29yZS9wcm9tcHQvdG9vbC1yZXN1bHQtY29udGVudC50cz8wYjg0Iiwid2VicGFjazovL2xhbmdjaGFpbi1uZXh0anMtdGVtcGxhdGUvLi4vLi4vY29yZS9wcm9tcHQvZGV0ZWN0LXByb21wdC10eXBlLnRzPzI5OWQiLCJ3ZWJwYWNrOi8vbGFuZ2NoYWluLW5leHRqcy10ZW1wbGF0ZS8uLi8uLi9jb3JlL3Byb21wdC9hdHRhY2htZW50cy10by1wYXJ0cy50cz9jZTdlIiwid2VicGFjazovL2xhbmdjaGFpbi1uZXh0anMtdGVtcGxhdGUvLi4vLi4vY29yZS9wcm9tcHQvbWVzc2FnZS1jb252ZXJzaW9uLWVycm9yLnRzPzFkMDQiLCJ3ZWJwYWNrOi8vbGFuZ2NoYWluLW5leHRqcy10ZW1wbGF0ZS8uLi8uLi9jb3JlL3Byb21wdC9jb252ZXJ0LXRvLWNvcmUtbWVzc2FnZXMudHM/YTVhYyIsIndlYnBhY2s6Ly9sYW5nY2hhaW4tbmV4dGpzLXRlbXBsYXRlLy4uLy4uL2NvcmUvdHlwZXMvdXNhZ2UudHM/ZDkwYSIsIndlYnBhY2s6Ly9sYW5nY2hhaW4tbmV4dGpzLXRlbXBsYXRlLy4uLy4uL2Vycm9ycy9pbnZhbGlkLXRvb2wtYXJndW1lbnRzLWVycm9yLnRzPzk2OTAiLCJ3ZWJwYWNrOi8vbGFuZ2NoYWluLW5leHRqcy10ZW1wbGF0ZS8uLi8uLi9lcnJvcnMvbm8tc3VjaC10b29sLWVycm9yLnRzPzc5MGIiLCJ3ZWJwYWNrOi8vbGFuZ2NoYWluLW5leHRqcy10ZW1wbGF0ZS8uLi8uLi91dGlsL2lzLWFzeW5jLWdlbmVyYXRvci50cz9kOTYwIiwid2VicGFjazovL2xhbmdjaGFpbi1uZXh0anMtdGVtcGxhdGUvLi4vLi4vdXRpbC9pcy1nZW5lcmF0b3IudHM/ZGZkNSIsIndlYnBhY2s6Ly9sYW5nY2hhaW4tbmV4dGpzLXRlbXBsYXRlLy4uLy4uL3V0aWwvcmV0cnktd2l0aC1leHBvbmVudGlhbC1iYWNrb2ZmLnRzPzRkMTkiLCJ3ZWJwYWNrOi8vbGFuZ2NoYWluLW5leHRqcy10ZW1wbGF0ZS8uLi8uLi91dGlsL2RlbGF5LnRzPzI4YWYiLCJ3ZWJwYWNrOi8vbGFuZ2NoYWluLW5leHRqcy10ZW1wbGF0ZS8uLi8uLi91dGlsL3JldHJ5LWVycm9yLnRzPzg3NTgiLCJ3ZWJwYWNrOi8vbGFuZ2NoYWluLW5leHRqcy10ZW1wbGF0ZS8uLi8uLi91dGlsL2NvbnN0YW50cy50cz8zZmYyIiwid2VicGFjazovL2xhbmdjaGFpbi1uZXh0anMtdGVtcGxhdGUvLi4vc3RyZWFtYWJsZS11aS9jcmVhdGUtc3VzcGVuZGVkLWNodW5rLnRzeD9lMjljIiwid2VicGFjazovL2xhbmdjaGFpbi1uZXh0anMtdGVtcGxhdGUvLi4vc3RyZWFtYWJsZS11aS9jcmVhdGUtc3RyZWFtYWJsZS11aS50c3g/YTkwMCIsIndlYnBhY2s6Ly9sYW5nY2hhaW4tbmV4dGpzLXRlbXBsYXRlLy4uL3N0cmVhbS11aS9yZW5kZXIudHM/MDllNiIsIndlYnBhY2s6Ly9sYW5nY2hhaW4tbmV4dGpzLXRlbXBsYXRlLy4uLy4uL3N0cmVhbXMvYWktc3RyZWFtLnRzPzQ4NTQiLCJ3ZWJwYWNrOi8vbGFuZ2NoYWluLW5leHRqcy10ZW1wbGF0ZS8uLi8uLi9zdHJlYW1zL3N0cmVhbS1kYXRhLnRzPzY3MzAiLCJ3ZWJwYWNrOi8vbGFuZ2NoYWluLW5leHRqcy10ZW1wbGF0ZS8uLi8uLi9zdHJlYW1zL29wZW5haS1zdHJlYW0udHM/YjJiZCIsIndlYnBhY2s6Ly9sYW5nY2hhaW4tbmV4dGpzLXRlbXBsYXRlLy4uLy4uL3V0aWwvY29uc3VtZS1zdHJlYW0udHM/NzMwOCIsIndlYnBhY2s6Ly9sYW5nY2hhaW4tbmV4dGpzLXRlbXBsYXRlLy4uL3N0cmVhbWFibGUtdmFsdWUvc3RyZWFtYWJsZS12YWx1ZS50cz9jNWUxIiwid2VicGFjazovL2xhbmdjaGFpbi1uZXh0anMtdGVtcGxhdGUvLi4vc3RyZWFtYWJsZS12YWx1ZS9jcmVhdGUtc3RyZWFtYWJsZS12YWx1ZS50cz8zMDE1Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIGpzb25kaWZmcGF0Y2ggZnJvbSAnanNvbmRpZmZwYXRjaCc7XG5pbXBvcnQgeyBBc3luY0xvY2FsU3RvcmFnZSB9IGZyb20gJ25vZGU6YXN5bmNfaG9va3MnO1xuaW1wb3J0IHsgY3JlYXRlUmVzb2x2YWJsZVByb21pc2UgfSBmcm9tICcuLi91dGlsL2NyZWF0ZS1yZXNvbHZhYmxlLXByb21pc2UnO1xuaW1wb3J0IHsgaXNGdW5jdGlvbiB9IGZyb20gJy4uL3V0aWwvaXMtZnVuY3Rpb24nO1xuaW1wb3J0IHR5cGUge1xuICBBSVByb3ZpZGVyLFxuICBJbmZlckFJU3RhdGUsXG4gIEludGVybmFsQUlTdGF0ZVN0b3JhZ2VPcHRpb25zLFxuICBNdXRhYmxlQUlTdGF0ZSxcbiAgVmFsdWVPclVwZGF0ZXIsXG59IGZyb20gJy4vdHlwZXMnO1xuXG4vLyBJdCBpcyBwb3NzaWJsZSB0aGF0IG11bHRpcGxlIEFJIHJlcXVlc3RzIGdldCBpbiBjb25jdXJyZW50bHksIGZvciBkaWZmZXJlbnRcbi8vIEFJIGluc3RhbmNlcy4gU28gQUxTIGlzIG5lY2Vzc2FyeSBoZXJlIGZvciBhIHNpbXBsZXIgQVBJLlxuY29uc3QgYXN5bmNBSVN0YXRlU3RvcmFnZSA9IG5ldyBBc3luY0xvY2FsU3RvcmFnZTx7XG4gIGN1cnJlbnRTdGF0ZTogYW55O1xuICBvcmlnaW5hbFN0YXRlOiBhbnk7XG4gIHNlYWxlZDogYm9vbGVhbjtcbiAgb3B0aW9uczogSW50ZXJuYWxBSVN0YXRlU3RvcmFnZU9wdGlvbnM7XG4gIG11dGF0aW9uRGVsdGFQcm9taXNlPzogUHJvbWlzZTxhbnk+O1xuICBtdXRhdGlvbkRlbHRhUmVzb2x2ZT86ICh2OiBhbnkpID0+IHZvaWQ7XG59PigpO1xuXG5mdW5jdGlvbiBnZXRBSVN0YXRlU3RvcmVPclRocm93KG1lc3NhZ2U6IHN0cmluZykge1xuICBjb25zdCBzdG9yZSA9IGFzeW5jQUlTdGF0ZVN0b3JhZ2UuZ2V0U3RvcmUoKTtcbiAgaWYgKCFzdG9yZSkge1xuICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgfVxuICByZXR1cm4gc3RvcmU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB3aXRoQUlTdGF0ZTxTLCBUPihcbiAgeyBzdGF0ZSwgb3B0aW9ucyB9OiB7IHN0YXRlOiBTOyBvcHRpb25zOiBJbnRlcm5hbEFJU3RhdGVTdG9yYWdlT3B0aW9ucyB9LFxuICBmbjogKCkgPT4gVCxcbik6IFQge1xuICByZXR1cm4gYXN5bmNBSVN0YXRlU3RvcmFnZS5ydW4oXG4gICAge1xuICAgICAgY3VycmVudFN0YXRlOiBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KHN0YXRlKSksIC8vIGRlZXAgY2xvbmUgb2JqZWN0XG4gICAgICBvcmlnaW5hbFN0YXRlOiBzdGF0ZSxcbiAgICAgIHNlYWxlZDogZmFsc2UsXG4gICAgICBvcHRpb25zLFxuICAgIH0sXG4gICAgZm4sXG4gICk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRBSVN0YXRlRGVsdGFQcm9taXNlKCkge1xuICBjb25zdCBzdG9yZSA9IGdldEFJU3RhdGVTdG9yZU9yVGhyb3coJ0ludGVybmFsIGVycm9yIG9jY3VycmVkLicpO1xuICByZXR1cm4gc3RvcmUubXV0YXRpb25EZWx0YVByb21pc2U7XG59XG5cbi8vIEludGVybmFsIG1ldGhvZC4gVGhpcyB3aWxsIGJlIGNhbGxlZCBhZnRlciB0aGUgQUkgQWN0aW9uIGhhcyBiZWVuIHJldHVybmVkXG4vLyBhbmQgeW91IGNhbiBubyBsb25nZXIgY2FsbCBgZ2V0TXV0YWJsZUFJU3RhdGUoKWAgaW5zaWRlIGFueSBhc3luYyBjYWxsYmFja3Ncbi8vIGNyZWF0ZWQgYnkgdGhhdCBBY3Rpb24uXG5leHBvcnQgZnVuY3Rpb24gc2VhbE11dGFibGVBSVN0YXRlKCkge1xuICBjb25zdCBzdG9yZSA9IGdldEFJU3RhdGVTdG9yZU9yVGhyb3coJ0ludGVybmFsIGVycm9yIG9jY3VycmVkLicpO1xuICBzdG9yZS5zZWFsZWQgPSB0cnVlO1xufVxuXG4vKipcbiAqIEdldCB0aGUgY3VycmVudCBBSSBzdGF0ZS5cbiAqIElmIGBrZXlgIGlzIHByb3ZpZGVkLCBpdCB3aWxsIHJldHVybiB0aGUgdmFsdWUgb2YgdGhlIHNwZWNpZmllZCBrZXkgaW4gdGhlXG4gKiBBSSBzdGF0ZSwgaWYgaXQncyBhbiBvYmplY3QuIElmIGl0J3Mgbm90IGFuIG9iamVjdCwgaXQgd2lsbCB0aHJvdyBhbiBlcnJvci5cbiAqXG4gKiBAZXhhbXBsZSBjb25zdCBzdGF0ZSA9IGdldEFJU3RhdGUoKSAvLyBHZXQgdGhlIGVudGlyZSBBSSBzdGF0ZVxuICogQGV4YW1wbGUgY29uc3QgZmllbGQgPSBnZXRBSVN0YXRlKCdrZXknKSAvLyBHZXQgdGhlIHZhbHVlIG9mIHRoZSBrZXlcbiAqL1xuZnVuY3Rpb24gZ2V0QUlTdGF0ZTxBSSBleHRlbmRzIEFJUHJvdmlkZXIgPSBhbnk+KCk6IFJlYWRvbmx5PFxuICBJbmZlckFJU3RhdGU8QUksIGFueT5cbj47XG5mdW5jdGlvbiBnZXRBSVN0YXRlPEFJIGV4dGVuZHMgQUlQcm92aWRlciA9IGFueT4oXG4gIGtleToga2V5b2YgSW5mZXJBSVN0YXRlPEFJLCBhbnk+LFxuKTogUmVhZG9ubHk8SW5mZXJBSVN0YXRlPEFJLCBhbnk+W3R5cGVvZiBrZXldPjtcbmZ1bmN0aW9uIGdldEFJU3RhdGU8QUkgZXh0ZW5kcyBBSVByb3ZpZGVyID0gYW55PihcbiAgLi4uYXJnczogW10gfCBba2V5OiBrZXlvZiBJbmZlckFJU3RhdGU8QUksIGFueT5dXG4pIHtcbiAgY29uc3Qgc3RvcmUgPSBnZXRBSVN0YXRlU3RvcmVPclRocm93KFxuICAgICdgZ2V0QUlTdGF0ZWAgbXVzdCBiZSBjYWxsZWQgd2l0aGluIGFuIEFJIEFjdGlvbi4nLFxuICApO1xuXG4gIGlmIChhcmdzLmxlbmd0aCA+IDApIHtcbiAgICBjb25zdCBrZXkgPSBhcmdzWzBdO1xuICAgIGlmICh0eXBlb2Ygc3RvcmUuY3VycmVudFN0YXRlICE9PSAnb2JqZWN0Jykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgWW91IGNhbid0IGdldCB0aGUgXCIke1N0cmluZyhcbiAgICAgICAgICBrZXksXG4gICAgICAgICl9XCIgZmllbGQgZnJvbSB0aGUgQUkgc3RhdGUgYmVjYXVzZSBpdCdzIG5vdCBhbiBvYmplY3QuYCxcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiBzdG9yZS5jdXJyZW50U3RhdGVba2V5IGFzIGtleW9mIHR5cGVvZiBzdG9yZS5jdXJyZW50U3RhdGVdO1xuICB9XG5cbiAgcmV0dXJuIHN0b3JlLmN1cnJlbnRTdGF0ZTtcbn1cblxuLyoqXG4gKiBHZXQgdGhlIG11dGFibGUgQUkgc3RhdGUuIE5vdGUgdGhhdCB5b3UgbXVzdCBjYWxsIGAuZG9uZSgpYCB3aGVuIGZpbmlzaGluZ1xuICogdXBkYXRpbmcgdGhlIEFJIHN0YXRlLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0c3hcbiAqIGNvbnN0IHN0YXRlID0gZ2V0TXV0YWJsZUFJU3RhdGUoKVxuICogc3RhdGUudXBkYXRlKHsgLi4uc3RhdGUuZ2V0KCksIGtleTogJ3ZhbHVlJyB9KVxuICogc3RhdGUudXBkYXRlKChjdXJyZW50U3RhdGUpID0+ICh7IC4uLmN1cnJlbnRTdGF0ZSwga2V5OiAndmFsdWUnIH0pKVxuICogc3RhdGUuZG9uZSgpXG4gKiBgYGBcbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHN4XG4gKiBjb25zdCBzdGF0ZSA9IGdldE11dGFibGVBSVN0YXRlKClcbiAqIHN0YXRlLmRvbmUoeyAuLi5zdGF0ZS5nZXQoKSwga2V5OiAndmFsdWUnIH0pIC8vIERvbmUgd2l0aCBhIG5ldyBzdGF0ZVxuICogYGBgXG4gKi9cbmZ1bmN0aW9uIGdldE11dGFibGVBSVN0YXRlPEFJIGV4dGVuZHMgQUlQcm92aWRlciA9IGFueT4oKTogTXV0YWJsZUFJU3RhdGU8XG4gIEluZmVyQUlTdGF0ZTxBSSwgYW55PlxuPjtcbmZ1bmN0aW9uIGdldE11dGFibGVBSVN0YXRlPEFJIGV4dGVuZHMgQUlQcm92aWRlciA9IGFueT4oXG4gIGtleToga2V5b2YgSW5mZXJBSVN0YXRlPEFJLCBhbnk+LFxuKTogTXV0YWJsZUFJU3RhdGU8SW5mZXJBSVN0YXRlPEFJLCBhbnk+W3R5cGVvZiBrZXldPjtcbmZ1bmN0aW9uIGdldE11dGFibGVBSVN0YXRlPEFJIGV4dGVuZHMgQUlQcm92aWRlciA9IGFueT4oXG4gIC4uLmFyZ3M6IFtdIHwgW2tleToga2V5b2YgSW5mZXJBSVN0YXRlPEFJLCBhbnk+XVxuKSB7XG4gIHR5cGUgQUlTdGF0ZSA9IEluZmVyQUlTdGF0ZTxBSSwgYW55PjtcbiAgdHlwZSBBSVN0YXRlV2l0aEtleSA9IHR5cGVvZiBhcmdzIGV4dGVuZHMgW2tleToga2V5b2YgQUlTdGF0ZV1cbiAgICA/IEFJU3RhdGVbKHR5cGVvZiBhcmdzKVswXV1cbiAgICA6IEFJU3RhdGU7XG4gIHR5cGUgTmV3U3RhdGVPclVwZGF0ZXIgPSBWYWx1ZU9yVXBkYXRlcjxBSVN0YXRlV2l0aEtleT47XG5cbiAgY29uc3Qgc3RvcmUgPSBnZXRBSVN0YXRlU3RvcmVPclRocm93KFxuICAgICdgZ2V0TXV0YWJsZUFJU3RhdGVgIG11c3QgYmUgY2FsbGVkIHdpdGhpbiBhbiBBSSBBY3Rpb24uJyxcbiAgKTtcblxuICBpZiAoc3RvcmUuc2VhbGVkKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgXCJgZ2V0TXV0YWJsZUFJU3RhdGVgIG11c3QgYmUgY2FsbGVkIGJlZm9yZSByZXR1cm5pbmcgZnJvbSBhbiBBSSBBY3Rpb24uIFBsZWFzZSBtb3ZlIGl0IHRvIHRoZSB0b3AgbGV2ZWwgb2YgdGhlIEFjdGlvbidzIGZ1bmN0aW9uIGJvZHkuXCIsXG4gICAgKTtcbiAgfVxuXG4gIGlmICghc3RvcmUubXV0YXRpb25EZWx0YVByb21pc2UpIHtcbiAgICBjb25zdCB7IHByb21pc2UsIHJlc29sdmUgfSA9IGNyZWF0ZVJlc29sdmFibGVQcm9taXNlKCk7XG4gICAgc3RvcmUubXV0YXRpb25EZWx0YVByb21pc2UgPSBwcm9taXNlO1xuICAgIHN0b3JlLm11dGF0aW9uRGVsdGFSZXNvbHZlID0gcmVzb2x2ZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGRvVXBkYXRlKG5ld1N0YXRlOiBOZXdTdGF0ZU9yVXBkYXRlciwgZG9uZTogYm9vbGVhbikge1xuICAgIGlmIChhcmdzLmxlbmd0aCA+IDApIHtcbiAgICAgIGlmICh0eXBlb2Ygc3RvcmUuY3VycmVudFN0YXRlICE9PSAnb2JqZWN0Jykge1xuICAgICAgICBjb25zdCBrZXkgPSBhcmdzWzBdO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgYFlvdSBjYW4ndCBtb2RpZnkgdGhlIFwiJHtTdHJpbmcoXG4gICAgICAgICAgICBrZXksXG4gICAgICAgICAgKX1cIiBmaWVsZCBvZiB0aGUgQUkgc3RhdGUgYmVjYXVzZSBpdCdzIG5vdCBhbiBvYmplY3QuYCxcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoaXNGdW5jdGlvbihuZXdTdGF0ZSkpIHtcbiAgICAgIGlmIChhcmdzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgc3RvcmUuY3VycmVudFN0YXRlW2FyZ3NbMF1dID0gbmV3U3RhdGUoc3RvcmUuY3VycmVudFN0YXRlW2FyZ3NbMF1dKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0b3JlLmN1cnJlbnRTdGF0ZSA9IG5ld1N0YXRlKHN0b3JlLmN1cnJlbnRTdGF0ZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChhcmdzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgc3RvcmUuY3VycmVudFN0YXRlW2FyZ3NbMF1dID0gbmV3U3RhdGU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdG9yZS5jdXJyZW50U3RhdGUgPSBuZXdTdGF0ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBzdG9yZS5vcHRpb25zLm9uU2V0QUlTdGF0ZT8uKHtcbiAgICAgIGtleTogYXJncy5sZW5ndGggPiAwID8gYXJnc1swXSA6IHVuZGVmaW5lZCxcbiAgICAgIHN0YXRlOiBzdG9yZS5jdXJyZW50U3RhdGUsXG4gICAgICBkb25lLFxuICAgIH0pO1xuICB9XG5cbiAgY29uc3QgbXV0YWJsZVN0YXRlID0ge1xuICAgIGdldDogKCkgPT4ge1xuICAgICAgaWYgKGFyZ3MubGVuZ3RoID4gMCkge1xuICAgICAgICBjb25zdCBrZXkgPSBhcmdzWzBdO1xuICAgICAgICBpZiAodHlwZW9mIHN0b3JlLmN1cnJlbnRTdGF0ZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICBgWW91IGNhbid0IGdldCB0aGUgXCIke1N0cmluZyhcbiAgICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgKX1cIiBmaWVsZCBmcm9tIHRoZSBBSSBzdGF0ZSBiZWNhdXNlIGl0J3Mgbm90IGFuIG9iamVjdC5gLFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN0b3JlLmN1cnJlbnRTdGF0ZVtrZXldIGFzIFJlYWRvbmx5PEFJU3RhdGVXaXRoS2V5PjtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHN0b3JlLmN1cnJlbnRTdGF0ZSBhcyBSZWFkb25seTxBSVN0YXRlPjtcbiAgICB9LFxuICAgIHVwZGF0ZTogZnVuY3Rpb24gdXBkYXRlKG5ld0FJU3RhdGU6IE5ld1N0YXRlT3JVcGRhdGVyKSB7XG4gICAgICBkb1VwZGF0ZShuZXdBSVN0YXRlLCBmYWxzZSk7XG4gICAgfSxcbiAgICBkb25lOiBmdW5jdGlvbiBkb25lKC4uLmRvbmVBcmdzOiBbXSB8IFtOZXdTdGF0ZU9yVXBkYXRlcl0pIHtcbiAgICAgIGlmIChkb25lQXJncy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGRvVXBkYXRlKGRvbmVBcmdzWzBdIGFzIE5ld1N0YXRlT3JVcGRhdGVyLCB0cnVlKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgZGVsdGEgPSBqc29uZGlmZnBhdGNoLmRpZmYoc3RvcmUub3JpZ2luYWxTdGF0ZSwgc3RvcmUuY3VycmVudFN0YXRlKTtcbiAgICAgIHN0b3JlLm11dGF0aW9uRGVsdGFSZXNvbHZlIShkZWx0YSk7XG4gICAgfSxcbiAgfTtcblxuICByZXR1cm4gbXV0YWJsZVN0YXRlO1xufVxuXG5leHBvcnQgeyBnZXRBSVN0YXRlLCBnZXRNdXRhYmxlQUlTdGF0ZSB9O1xuIiwiLyoqXG4gKiBDcmVhdGVzIGEgUHJvbWlzZSB3aXRoIGV4dGVybmFsbHkgYWNjZXNzaWJsZSByZXNvbHZlIGFuZCByZWplY3QgZnVuY3Rpb25zLlxuICpcbiAqIEB0ZW1wbGF0ZSBUIC0gVGhlIHR5cGUgb2YgdGhlIHZhbHVlIHRoYXQgdGhlIFByb21pc2Ugd2lsbCByZXNvbHZlIHRvLlxuICogQHJldHVybnMgQW4gb2JqZWN0IGNvbnRhaW5pbmc6XG4gKiAgIC0gcHJvbWlzZTogQSBQcm9taXNlIHRoYXQgY2FuIGJlIHJlc29sdmVkIG9yIHJlamVjdGVkIGV4dGVybmFsbHkuXG4gKiAgIC0gcmVzb2x2ZTogQSBmdW5jdGlvbiB0byByZXNvbHZlIHRoZSBQcm9taXNlIHdpdGggYSB2YWx1ZSBvZiB0eXBlIFQuXG4gKiAgIC0gcmVqZWN0OiBBIGZ1bmN0aW9uIHRvIHJlamVjdCB0aGUgUHJvbWlzZSB3aXRoIGFuIGVycm9yLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlUmVzb2x2YWJsZVByb21pc2U8VCA9IGFueT4oKToge1xuICBwcm9taXNlOiBQcm9taXNlPFQ+O1xuICByZXNvbHZlOiAodmFsdWU6IFQpID0+IHZvaWQ7XG4gIHJlamVjdDogKGVycm9yOiB1bmtub3duKSA9PiB2b2lkO1xufSB7XG4gIGxldCByZXNvbHZlOiAodmFsdWU6IFQpID0+IHZvaWQ7XG4gIGxldCByZWplY3Q6IChlcnJvcjogdW5rbm93bikgPT4gdm9pZDtcblxuICBjb25zdCBwcm9taXNlID0gbmV3IFByb21pc2U8VD4oKHJlcywgcmVqKSA9PiB7XG4gICAgcmVzb2x2ZSA9IHJlcztcbiAgICByZWplY3QgPSByZWo7XG4gIH0pO1xuXG4gIHJldHVybiB7XG4gICAgcHJvbWlzZSxcbiAgICByZXNvbHZlOiByZXNvbHZlISxcbiAgICByZWplY3Q6IHJlamVjdCEsXG4gIH07XG59XG4iLCIvKipcbiAqIENoZWNrcyBpZiB0aGUgZ2l2ZW4gdmFsdWUgaXMgYSBmdW5jdGlvbi5cbiAqXG4gKiBAcGFyYW0ge3Vua25vd259IHZhbHVlIC0gVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdGhlIHZhbHVlIGlzIGEgZnVuY3Rpb24sIGZhbHNlIG90aGVyd2lzZS5cbiAqL1xuZXhwb3J0IGNvbnN0IGlzRnVuY3Rpb24gPSAodmFsdWU6IHVua25vd24pOiB2YWx1ZSBpcyBGdW5jdGlvbiA9PlxuICB0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbic7XG4iLCIvLyBUaGlzIGZpbGUgcHJvdmlkZXMgdGhlIEFJIGNvbnRleHQgdG8gYWxsIEFJIEFjdGlvbnMgdmlhIEFzeW5jTG9jYWxTdG9yYWdlLlxuXG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBJbnRlcm5hbEFJUHJvdmlkZXIgfSBmcm9tICcuL3JzYy1zaGFyZWQubWpzJztcbmltcG9ydCB7XG4gIHdpdGhBSVN0YXRlLFxuICBnZXRBSVN0YXRlRGVsdGFQcm9taXNlLFxuICBzZWFsTXV0YWJsZUFJU3RhdGUsXG59IGZyb20gJy4vYWktc3RhdGUnO1xuaW1wb3J0IHR5cGUge1xuICBTZXJ2ZXJXcmFwcGVkQWN0aW9ucyxcbiAgQUlBY3Rpb24sXG4gIEFJQWN0aW9ucyxcbiAgQUlQcm92aWRlcixcbiAgSW50ZXJuYWxBSVN0YXRlU3RvcmFnZU9wdGlvbnMsXG4gIE9uU2V0QUlTdGF0ZSxcbiAgT25HZXRVSVN0YXRlLFxufSBmcm9tICcuL3R5cGVzJztcblxuYXN5bmMgZnVuY3Rpb24gaW5uZXJBY3Rpb248VD4oXG4gIHtcbiAgICBhY3Rpb24sXG4gICAgb3B0aW9ucyxcbiAgfTogeyBhY3Rpb246IEFJQWN0aW9uOyBvcHRpb25zOiBJbnRlcm5hbEFJU3RhdGVTdG9yYWdlT3B0aW9ucyB9LFxuICBzdGF0ZTogVCxcbiAgLi4uYXJnczogdW5rbm93bltdXG4pIHtcbiAgJ3VzZSBzZXJ2ZXInO1xuICByZXR1cm4gYXdhaXQgd2l0aEFJU3RhdGUoXG4gICAge1xuICAgICAgc3RhdGUsXG4gICAgICBvcHRpb25zLFxuICAgIH0sXG4gICAgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgYWN0aW9uKC4uLmFyZ3MpO1xuICAgICAgc2VhbE11dGFibGVBSVN0YXRlKCk7XG4gICAgICByZXR1cm4gW2dldEFJU3RhdGVEZWx0YVByb21pc2UoKSBhcyBQcm9taXNlPFQ+LCByZXN1bHRdO1xuICAgIH0sXG4gICk7XG59XG5cbmZ1bmN0aW9uIHdyYXBBY3Rpb248VCA9IHVua25vd24+KFxuICBhY3Rpb246IEFJQWN0aW9uLFxuICBvcHRpb25zOiBJbnRlcm5hbEFJU3RhdGVTdG9yYWdlT3B0aW9ucyxcbikge1xuICByZXR1cm4gaW5uZXJBY3Rpb24uYmluZChudWxsLCB7IGFjdGlvbiwgb3B0aW9ucyB9KSBhcyBBSUFjdGlvbjxUPjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUFJPFxuICBBSVN0YXRlID0gYW55LFxuICBVSVN0YXRlID0gYW55LFxuICBBY3Rpb25zIGV4dGVuZHMgQUlBY3Rpb25zID0ge30sXG4+KHtcbiAgYWN0aW9ucyxcbiAgaW5pdGlhbEFJU3RhdGUsXG4gIGluaXRpYWxVSVN0YXRlLFxuXG4gIG9uU2V0QUlTdGF0ZSxcbiAgb25HZXRVSVN0YXRlLFxufToge1xuICBhY3Rpb25zOiBBY3Rpb25zO1xuICBpbml0aWFsQUlTdGF0ZT86IEFJU3RhdGU7XG4gIGluaXRpYWxVSVN0YXRlPzogVUlTdGF0ZTtcblxuICAvKipcbiAgICogVGhpcyBmdW5jdGlvbiBpcyBjYWxsZWQgd2hlbmV2ZXIgdGhlIEFJIHN0YXRlIGlzIHVwZGF0ZWQgYnkgYW4gQWN0aW9uLlxuICAgKiBZb3UgY2FuIHVzZSB0aGlzIHRvIHBlcnNpc3QgdGhlIEFJIHN0YXRlIHRvIGEgZGF0YWJhc2UsIG9yIHRvIHNlbmQgaXQgdG8gYVxuICAgKiBsb2dnaW5nIHNlcnZpY2UuXG4gICAqL1xuICBvblNldEFJU3RhdGU/OiBPblNldEFJU3RhdGU8QUlTdGF0ZT47XG5cbiAgLyoqXG4gICAqIFRoaXMgZnVuY3Rpb24gaXMgdXNlZCB0byByZXRyaWV2ZSB0aGUgVUkgc3RhdGUgYmFzZWQgb24gdGhlIEFJIHN0YXRlLlxuICAgKiBGb3IgZXhhbXBsZSwgdG8gcmVuZGVyIHRoZSBpbml0aWFsIFVJIHN0YXRlIGJhc2VkIG9uIGEgZ2l2ZW4gQUkgc3RhdGUsIG9yXG4gICAqIHRvIHN5bmMgdGhlIFVJIHN0YXRlIHdoZW4gdGhlIGFwcGxpY2F0aW9uIGlzIGFscmVhZHkgbG9hZGVkLlxuICAgKlxuICAgKiBJZiByZXR1cm5pbmcgYHVuZGVmaW5lZGAsIHRoZSBjbGllbnQgc2lkZSBVSSBzdGF0ZSB3aWxsIG5vdCBiZSB1cGRhdGVkLlxuICAgKlxuICAgKiBUaGlzIGZ1bmN0aW9uIG11c3QgYmUgYW5ub3RhdGVkIHdpdGggdGhlIGBcInVzZSBzZXJ2ZXJcImAgZGlyZWN0aXZlLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGB0c3hcbiAgICogb25HZXRVSVN0YXRlOiBhc3luYyAoKSA9PiB7XG4gICAqICAgJ3VzZSBzZXJ2ZXInO1xuICAgKlxuICAgKiAgIGNvbnN0IGN1cnJlbnRBSVN0YXRlID0gZ2V0QUlTdGF0ZSgpO1xuICAgKiAgIGNvbnN0IGV4dGVybmFsQUlTdGF0ZSA9IGF3YWl0IGxvYWRBSVN0YXRlRnJvbURhdGFiYXNlKCk7XG4gICAqXG4gICAqICAgaWYgKGN1cnJlbnRBSVN0YXRlID09PSBleHRlcm5hbEFJU3RhdGUpIHJldHVybiB1bmRlZmluZWQ7XG4gICAqXG4gICAqICAgLy8gVXBkYXRlIGN1cnJlbnQgQUkgc3RhdGUgYW5kIHJldHVybiB0aGUgbmV3IFVJIHN0YXRlXG4gICAqICAgY29uc3Qgc3RhdGUgPSBnZXRNdXRhYmxlQUlTdGF0ZSgpXG4gICAqICAgc3RhdGUuZG9uZShleHRlcm5hbEFJU3RhdGUpXG4gICAqXG4gICAqICAgcmV0dXJuIDxkaXY+Li4uPC9kaXY+O1xuICAgKiB9XG4gICAqIGBgYFxuICAgKi9cbiAgb25HZXRVSVN0YXRlPzogT25HZXRVSVN0YXRlPFVJU3RhdGU+O1xufSkge1xuICAvLyBXcmFwIGFsbCBhY3Rpb25zIHdpdGggb3VyIEhvQy5cbiAgY29uc3Qgd3JhcHBlZEFjdGlvbnM6IFNlcnZlcldyYXBwZWRBY3Rpb25zID0ge307XG4gIGZvciAoY29uc3QgbmFtZSBpbiBhY3Rpb25zKSB7XG4gICAgd3JhcHBlZEFjdGlvbnNbbmFtZV0gPSB3cmFwQWN0aW9uKGFjdGlvbnNbbmFtZV0sIHtcbiAgICAgIG9uU2V0QUlTdGF0ZSxcbiAgICB9KTtcbiAgfVxuXG4gIGNvbnN0IHdyYXBwZWRTeW5jVUlTdGF0ZSA9IG9uR2V0VUlTdGF0ZVxuICAgID8gd3JhcEFjdGlvbihvbkdldFVJU3RhdGUsIHt9KVxuICAgIDogdW5kZWZpbmVkO1xuXG4gIGNvbnN0IEFJOiBBSVByb3ZpZGVyPEFJU3RhdGUsIFVJU3RhdGUsIEFjdGlvbnM+ID0gYXN5bmMgcHJvcHMgPT4ge1xuICAgIGlmICgndXNlU3RhdGUnIGluIFJlYWN0KSB7XG4gICAgICAvLyBUaGlzIGZpbGUgbXVzdCBiZSBydW5uaW5nIG9uIHRoZSBSZWFjdCBTZXJ2ZXIgbGF5ZXIuXG4gICAgICAvLyBJZGVhbGx5IHdlIHNob3VsZCBiZSB1c2luZyBgaW1wb3J0IFwic2VydmVyLW9ubHlcImAgaGVyZSBidXQgd2UgY2FuIGhhdmUgYVxuICAgICAgLy8gbW9yZSBjdXN0b21pemVkIGVycm9yIG1lc3NhZ2Ugd2l0aCB0aGlzIGltcGxlbWVudGF0aW9uLlxuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnVGhpcyBjb21wb25lbnQgY2FuIG9ubHkgYmUgdXNlZCBpbnNpZGUgU2VydmVyIENvbXBvbmVudHMuJyxcbiAgICAgICk7XG4gICAgfVxuXG4gICAgbGV0IHVpU3RhdGUgPSBwcm9wcy5pbml0aWFsVUlTdGF0ZSA/PyBpbml0aWFsVUlTdGF0ZTtcbiAgICBsZXQgYWlTdGF0ZSA9IHByb3BzLmluaXRpYWxBSVN0YXRlID8/IGluaXRpYWxBSVN0YXRlO1xuICAgIGxldCBhaVN0YXRlRGVsdGEgPSB1bmRlZmluZWQ7XG5cbiAgICBpZiAod3JhcHBlZFN5bmNVSVN0YXRlKSB7XG4gICAgICBjb25zdCBbbmV3QUlTdGF0ZURlbHRhLCBuZXdVSVN0YXRlXSA9IGF3YWl0IHdyYXBwZWRTeW5jVUlTdGF0ZShhaVN0YXRlKTtcbiAgICAgIGlmIChuZXdVSVN0YXRlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgYWlTdGF0ZURlbHRhID0gbmV3QUlTdGF0ZURlbHRhO1xuICAgICAgICB1aVN0YXRlID0gbmV3VUlTdGF0ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gKFxuICAgICAgPEludGVybmFsQUlQcm92aWRlclxuICAgICAgICB3cmFwcGVkQWN0aW9ucz17d3JhcHBlZEFjdGlvbnN9XG4gICAgICAgIHdyYXBwZWRTeW5jVUlTdGF0ZT17d3JhcHBlZFN5bmNVSVN0YXRlfVxuICAgICAgICBpbml0aWFsVUlTdGF0ZT17dWlTdGF0ZX1cbiAgICAgICAgaW5pdGlhbEFJU3RhdGU9e2FpU3RhdGV9XG4gICAgICAgIGluaXRpYWxBSVN0YXRlUGF0Y2g9e2FpU3RhdGVEZWx0YX1cbiAgICAgID5cbiAgICAgICAge3Byb3BzLmNoaWxkcmVufVxuICAgICAgPC9JbnRlcm5hbEFJUHJvdmlkZXI+XG4gICAgKTtcbiAgfTtcblxuICByZXR1cm4gQUk7XG59XG4iLCJpbXBvcnQgeyBMYW5ndWFnZU1vZGVsVjEgfSBmcm9tICdAYWktc2RrL3Byb3ZpZGVyJztcbmltcG9ydCB7IHNhZmVQYXJzZUpTT04gfSBmcm9tICdAYWktc2RrL3Byb3ZpZGVyLXV0aWxzJztcbmltcG9ydCB7IFJlYWN0Tm9kZSB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IHogfSBmcm9tICd6b2QnO1xuaW1wb3J0IHsgQ2FsbFNldHRpbmdzIH0gZnJvbSAnLi4vLi4vY29yZS9wcm9tcHQvY2FsbC1zZXR0aW5ncyc7XG5pbXBvcnQgeyBjb252ZXJ0VG9MYW5ndWFnZU1vZGVsUHJvbXB0IH0gZnJvbSAnLi4vLi4vY29yZS9wcm9tcHQvY29udmVydC10by1sYW5ndWFnZS1tb2RlbC1wcm9tcHQnO1xuaW1wb3J0IHsgcHJlcGFyZUNhbGxTZXR0aW5ncyB9IGZyb20gJy4uLy4uL2NvcmUvcHJvbXB0L3ByZXBhcmUtY2FsbC1zZXR0aW5ncyc7XG5pbXBvcnQgeyBwcmVwYXJlVG9vbHNBbmRUb29sQ2hvaWNlIH0gZnJvbSAnLi4vLi4vY29yZS9wcm9tcHQvcHJlcGFyZS10b29scy1hbmQtdG9vbC1jaG9pY2UnO1xuaW1wb3J0IHsgUHJvbXB0IH0gZnJvbSAnLi4vLi4vY29yZS9wcm9tcHQvcHJvbXB0JztcbmltcG9ydCB7IHN0YW5kYXJkaXplUHJvbXB0IH0gZnJvbSAnLi4vLi4vY29yZS9wcm9tcHQvc3RhbmRhcmRpemUtcHJvbXB0JztcbmltcG9ydCB7XG4gIENhbGxXYXJuaW5nLFxuICBDb3JlVG9vbENob2ljZSxcbiAgRmluaXNoUmVhc29uLFxuICBQcm92aWRlck1ldGFkYXRhLFxufSBmcm9tICcuLi8uLi9jb3JlL3R5cGVzJztcbmltcG9ydCB7XG4gIExhbmd1YWdlTW9kZWxVc2FnZSxcbiAgY2FsY3VsYXRlTGFuZ3VhZ2VNb2RlbFVzYWdlLFxufSBmcm9tICcuLi8uLi9jb3JlL3R5cGVzL3VzYWdlJztcbmltcG9ydCB7IEludmFsaWRUb29sQXJndW1lbnRzRXJyb3IgfSBmcm9tICcuLi8uLi9lcnJvcnMvaW52YWxpZC10b29sLWFyZ3VtZW50cy1lcnJvcic7XG5pbXBvcnQgeyBOb1N1Y2hUb29sRXJyb3IgfSBmcm9tICcuLi8uLi9lcnJvcnMvbm8tc3VjaC10b29sLWVycm9yJztcbmltcG9ydCB7IGNyZWF0ZVJlc29sdmFibGVQcm9taXNlIH0gZnJvbSAnLi4vLi4vdXRpbC9jcmVhdGUtcmVzb2x2YWJsZS1wcm9taXNlJztcbmltcG9ydCB7IGlzQXN5bmNHZW5lcmF0b3IgfSBmcm9tICcuLi8uLi91dGlsL2lzLWFzeW5jLWdlbmVyYXRvcic7XG5pbXBvcnQgeyBpc0dlbmVyYXRvciB9IGZyb20gJy4uLy4uL3V0aWwvaXMtZ2VuZXJhdG9yJztcbmltcG9ydCB7IHJldHJ5V2l0aEV4cG9uZW50aWFsQmFja29mZiB9IGZyb20gJy4uLy4uL3V0aWwvcmV0cnktd2l0aC1leHBvbmVudGlhbC1iYWNrb2ZmJztcbmltcG9ydCB7IGNyZWF0ZVN0cmVhbWFibGVVSSB9IGZyb20gJy4uL3N0cmVhbWFibGUtdWkvY3JlYXRlLXN0cmVhbWFibGUtdWknO1xuXG50eXBlIFN0cmVhbWFibGUgPSBSZWFjdE5vZGUgfCBQcm9taXNlPFJlYWN0Tm9kZT47XG5cbnR5cGUgUmVuZGVyZXI8VCBleHRlbmRzIEFycmF5PGFueT4+ID0gKFxuICAuLi5hcmdzOiBUXG4pID0+XG4gIHwgU3RyZWFtYWJsZVxuICB8IEdlbmVyYXRvcjxTdHJlYW1hYmxlLCBTdHJlYW1hYmxlLCB2b2lkPlxuICB8IEFzeW5jR2VuZXJhdG9yPFN0cmVhbWFibGUsIFN0cmVhbWFibGUsIHZvaWQ+O1xuXG50eXBlIFJlbmRlclRvb2w8UEFSQU1FVEVSUyBleHRlbmRzIHouWm9kVHlwZUFueSA9IGFueT4gPSB7XG4gIGRlc2NyaXB0aW9uPzogc3RyaW5nO1xuICBwYXJhbWV0ZXJzOiBQQVJBTUVURVJTO1xuICBnZW5lcmF0ZT86IFJlbmRlcmVyPFxuICAgIFtcbiAgICAgIHouaW5mZXI8UEFSQU1FVEVSUz4sXG4gICAgICB7XG4gICAgICAgIHRvb2xOYW1lOiBzdHJpbmc7XG4gICAgICAgIHRvb2xDYWxsSWQ6IHN0cmluZztcbiAgICAgIH0sXG4gICAgXVxuICA+O1xufTtcblxudHlwZSBSZW5kZXJUZXh0ID0gUmVuZGVyZXI8XG4gIFtcbiAgICB7XG4gICAgICAvKipcbiAgICAgICAqIFRoZSBmdWxsIHRleHQgY29udGVudCBmcm9tIHRoZSBtb2RlbCBzbyBmYXIuXG4gICAgICAgKi9cbiAgICAgIGNvbnRlbnQ6IHN0cmluZztcblxuICAgICAgLyoqXG4gICAgICAgKiBUaGUgbmV3IGFwcGVuZGVkIHRleHQgY29udGVudCBmcm9tIHRoZSBtb2RlbCBzaW5jZSB0aGUgbGFzdCBgdGV4dGAgY2FsbC5cbiAgICAgICAqL1xuICAgICAgZGVsdGE6IHN0cmluZztcblxuICAgICAgLyoqXG4gICAgICAgKiBXaGV0aGVyIHRoZSBtb2RlbCBpcyBkb25lIGdlbmVyYXRpbmcgdGV4dC5cbiAgICAgICAqIElmIGB0cnVlYCwgdGhlIGBjb250ZW50YCB3aWxsIGJlIHRoZSBmaW5hbCBvdXRwdXQgYW5kIHRoaXMgY2FsbCB3aWxsIGJlIHRoZSBsYXN0LlxuICAgICAgICovXG4gICAgICBkb25lOiBib29sZWFuO1xuICAgIH0sXG4gIF1cbj47XG5cbnR5cGUgUmVuZGVyUmVzdWx0ID0ge1xuICB2YWx1ZTogUmVhY3ROb2RlO1xufSAmIEF3YWl0ZWQ8UmV0dXJuVHlwZTxMYW5ndWFnZU1vZGVsVjFbJ2RvU3RyZWFtJ10+PjtcblxuY29uc3QgZGVmYXVsdFRleHRSZW5kZXJlcjogUmVuZGVyVGV4dCA9ICh7IGNvbnRlbnQgfTogeyBjb250ZW50OiBzdHJpbmcgfSkgPT5cbiAgY29udGVudDtcblxuLyoqXG4gKiBgc3RyZWFtVUlgIGlzIGEgaGVscGVyIGZ1bmN0aW9uIHRvIGNyZWF0ZSBhIHN0cmVhbWFibGUgVUkgZnJvbSBMTE1zLlxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gc3RyZWFtVUk8XG4gIFRPT0xTIGV4dGVuZHMgeyBbbmFtZTogc3RyaW5nXTogei5ab2RUeXBlQW55IH0gPSB7fSxcbj4oe1xuICBtb2RlbCxcbiAgdG9vbHMsXG4gIHRvb2xDaG9pY2UsXG4gIHN5c3RlbSxcbiAgcHJvbXB0LFxuICBtZXNzYWdlcyxcbiAgbWF4UmV0cmllcyxcbiAgYWJvcnRTaWduYWwsXG4gIGhlYWRlcnMsXG4gIGluaXRpYWwsXG4gIHRleHQsXG4gIGV4cGVyaW1lbnRhbF9wcm92aWRlck1ldGFkYXRhOiBwcm92aWRlck1ldGFkYXRhLFxuICBvbkZpbmlzaCxcbiAgLi4uc2V0dGluZ3Ncbn06IENhbGxTZXR0aW5ncyAmXG4gIFByb21wdCAmIHtcbiAgICAvKipcbiAgICAgKiBUaGUgbGFuZ3VhZ2UgbW9kZWwgdG8gdXNlLlxuICAgICAqL1xuICAgIG1vZGVsOiBMYW5ndWFnZU1vZGVsVjE7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgdG9vbHMgdGhhdCB0aGUgbW9kZWwgY2FuIGNhbGwuIFRoZSBtb2RlbCBuZWVkcyB0byBzdXBwb3J0IGNhbGxpbmcgdG9vbHMuXG4gICAgICovXG4gICAgdG9vbHM/OiB7XG4gICAgICBbbmFtZSBpbiBrZXlvZiBUT09MU106IFJlbmRlclRvb2w8VE9PTFNbbmFtZV0+O1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBUaGUgdG9vbCBjaG9pY2Ugc3RyYXRlZ3kuIERlZmF1bHQ6ICdhdXRvJy5cbiAgICAgKi9cbiAgICB0b29sQ2hvaWNlPzogQ29yZVRvb2xDaG9pY2U8VE9PTFM+O1xuXG4gICAgdGV4dD86IFJlbmRlclRleHQ7XG4gICAgaW5pdGlhbD86IFJlYWN0Tm9kZTtcblxuICAgIC8qKlxuQWRkaXRpb25hbCBwcm92aWRlci1zcGVjaWZpYyBtZXRhZGF0YS4gVGhleSBhcmUgcGFzc2VkIHRocm91Z2hcbnRvIHRoZSBwcm92aWRlciBmcm9tIHRoZSBBSSBTREsgYW5kIGVuYWJsZSBwcm92aWRlci1zcGVjaWZpY1xuZnVuY3Rpb25hbGl0eSB0aGF0IGNhbiBiZSBmdWxseSBlbmNhcHN1bGF0ZWQgaW4gdGhlIHByb3ZpZGVyLlxuICovXG4gICAgZXhwZXJpbWVudGFsX3Byb3ZpZGVyTWV0YWRhdGE/OiBQcm92aWRlck1ldGFkYXRhO1xuXG4gICAgLyoqXG4gICAgICogQ2FsbGJhY2sgdGhhdCBpcyBjYWxsZWQgd2hlbiB0aGUgTExNIHJlc3BvbnNlIGFuZCB0aGUgZmluYWwgb2JqZWN0IHZhbGlkYXRpb24gYXJlIGZpbmlzaGVkLlxuICAgICAqL1xuICAgIG9uRmluaXNoPzogKGV2ZW50OiB7XG4gICAgICAvKipcbiAgICAgICAqIFRoZSByZWFzb24gd2h5IHRoZSBnZW5lcmF0aW9uIGZpbmlzaGVkLlxuICAgICAgICovXG4gICAgICBmaW5pc2hSZWFzb246IEZpbmlzaFJlYXNvbjtcbiAgICAgIC8qKlxuICAgICAgICogVGhlIHRva2VuIHVzYWdlIG9mIHRoZSBnZW5lcmF0ZWQgcmVzcG9uc2UuXG4gICAgICAgKi9cbiAgICAgIHVzYWdlOiBMYW5ndWFnZU1vZGVsVXNhZ2U7XG4gICAgICAvKipcbiAgICAgICAqIFRoZSBmaW5hbCB1aSBub2RlIHRoYXQgd2FzIGdlbmVyYXRlZC5cbiAgICAgICAqL1xuICAgICAgdmFsdWU6IFJlYWN0Tm9kZTtcbiAgICAgIC8qKlxuICAgICAgICogV2FybmluZ3MgZnJvbSB0aGUgbW9kZWwgcHJvdmlkZXIgKGUuZy4gdW5zdXBwb3J0ZWQgc2V0dGluZ3MpXG4gICAgICAgKi9cbiAgICAgIHdhcm5pbmdzPzogQ2FsbFdhcm5pbmdbXTtcbiAgICAgIC8qKlxuICAgICAgICogT3B0aW9uYWwgcmF3IHJlc3BvbnNlIGRhdGEuXG4gICAgICAgKi9cbiAgICAgIHJhd1Jlc3BvbnNlPzoge1xuICAgICAgICAvKipcbiAgICAgICAgICogUmVzcG9uc2UgaGVhZGVycy5cbiAgICAgICAgICovXG4gICAgICAgIGhlYWRlcnM/OiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+O1xuICAgICAgfTtcbiAgICB9KSA9PiBQcm9taXNlPHZvaWQ+IHwgdm9pZDtcbiAgfSk6IFByb21pc2U8UmVuZGVyUmVzdWx0PiB7XG4gIC8vIFRPRE86IFJlbW92ZSB0aGVzZSBlcnJvcnMgYWZ0ZXIgdGhlIGV4cGVyaW1lbnRhbCBwaGFzZS5cbiAgaWYgKHR5cGVvZiBtb2RlbCA9PT0gJ3N0cmluZycpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAnYG1vZGVsYCBjYW5ub3QgYmUgYSBzdHJpbmcgaW4gYHN0cmVhbVVJYC4gVXNlIHRoZSBhY3R1YWwgbW9kZWwgaW5zdGFuY2UgaW5zdGVhZC4nLFxuICAgICk7XG4gIH1cbiAgaWYgKCdmdW5jdGlvbnMnIGluIHNldHRpbmdzKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgJ2BmdW5jdGlvbnNgIGlzIG5vdCBzdXBwb3J0ZWQgaW4gYHN0cmVhbVVJYCwgdXNlIGB0b29sc2AgaW5zdGVhZC4nLFxuICAgICk7XG4gIH1cbiAgaWYgKCdwcm92aWRlcicgaW4gc2V0dGluZ3MpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAnYHByb3ZpZGVyYCBpcyBubyBsb25nZXIgbmVlZGVkIGluIGBzdHJlYW1VSWAuIFVzZSBgbW9kZWxgIGluc3RlYWQuJyxcbiAgICApO1xuICB9XG4gIGlmICh0b29scykge1xuICAgIGZvciAoY29uc3QgW25hbWUsIHRvb2xdIG9mIE9iamVjdC5lbnRyaWVzKHRvb2xzKSkge1xuICAgICAgaWYgKCdyZW5kZXInIGluIHRvb2wpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICdUb29sIGRlZmluaXRpb24gaW4gYHN0cmVhbVVJYCBzaG91bGQgbm90IGhhdmUgYHJlbmRlcmAgcHJvcGVydHkuIFVzZSBgZ2VuZXJhdGVgIGluc3RlYWQuIEZvdW5kIGluIHRvb2w6ICcgK1xuICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBjb25zdCB1aSA9IGNyZWF0ZVN0cmVhbWFibGVVSShpbml0aWFsKTtcblxuICAvLyBUaGUgZGVmYXVsdCB0ZXh0IHJlbmRlcmVyIGp1c3QgcmV0dXJucyB0aGUgY29udGVudCBhcyBzdHJpbmcuXG4gIGNvbnN0IHRleHRSZW5kZXIgPSB0ZXh0IHx8IGRlZmF1bHRUZXh0UmVuZGVyZXI7XG5cbiAgbGV0IGZpbmlzaGVkOiBQcm9taXNlPHZvaWQ+IHwgdW5kZWZpbmVkO1xuXG4gIGxldCBmaW5pc2hFdmVudDoge1xuICAgIGZpbmlzaFJlYXNvbjogRmluaXNoUmVhc29uO1xuICAgIHVzYWdlOiBMYW5ndWFnZU1vZGVsVXNhZ2U7XG4gICAgd2FybmluZ3M/OiBDYWxsV2FybmluZ1tdO1xuICAgIHJhd1Jlc3BvbnNlPzoge1xuICAgICAgaGVhZGVycz86IFJlY29yZDxzdHJpbmcsIHN0cmluZz47XG4gICAgfTtcbiAgfSB8IG51bGwgPSBudWxsO1xuXG4gIGFzeW5jIGZ1bmN0aW9uIHJlbmRlcih7XG4gICAgYXJncyxcbiAgICByZW5kZXJlcixcbiAgICBzdHJlYW1hYmxlVUksXG4gICAgaXNMYXN0Q2FsbCA9IGZhbHNlLFxuICB9OiB7XG4gICAgcmVuZGVyZXI6IHVuZGVmaW5lZCB8IFJlbmRlcmVyPGFueT47XG4gICAgYXJnczogW3BheWxvYWQ6IGFueV0gfCBbcGF5bG9hZDogYW55LCBvcHRpb25zOiBhbnldO1xuICAgIHN0cmVhbWFibGVVSTogUmV0dXJuVHlwZTx0eXBlb2YgY3JlYXRlU3RyZWFtYWJsZVVJPjtcbiAgICBpc0xhc3RDYWxsPzogYm9vbGVhbjtcbiAgfSkge1xuICAgIGlmICghcmVuZGVyZXIpIHJldHVybjtcblxuICAgIC8vIGNyZWF0ZSBhIHByb21pc2UgdGhhdCB3aWxsIGJlIHJlc29sdmVkIHdoZW4gdGhlIHJlbmRlciBjYWxsIGlzIGZpbmlzaGVkLlxuICAgIC8vIGl0IGlzIGFwcGVuZGVkIHRvIHRoZSBgZmluaXNoZWRgIHByb21pc2UgY2hhaW4gdG8gZW5zdXJlIHRoZSByZW5kZXIgY2FsbFxuICAgIC8vIGlzIGZpbmlzaGVkIGJlZm9yZSB0aGUgbmV4dCByZW5kZXIgY2FsbCBzdGFydHMuXG4gICAgY29uc3QgcmVuZGVyRmluaXNoZWQgPSBjcmVhdGVSZXNvbHZhYmxlUHJvbWlzZTx2b2lkPigpO1xuICAgIGZpbmlzaGVkID0gZmluaXNoZWRcbiAgICAgID8gZmluaXNoZWQudGhlbigoKSA9PiByZW5kZXJGaW5pc2hlZC5wcm9taXNlKVxuICAgICAgOiByZW5kZXJGaW5pc2hlZC5wcm9taXNlO1xuXG4gICAgY29uc3QgcmVuZGVyZXJSZXN1bHQgPSByZW5kZXJlciguLi5hcmdzKTtcblxuICAgIGlmIChpc0FzeW5jR2VuZXJhdG9yKHJlbmRlcmVyUmVzdWx0KSB8fCBpc0dlbmVyYXRvcihyZW5kZXJlclJlc3VsdCkpIHtcbiAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIGNvbnN0IHsgZG9uZSwgdmFsdWUgfSA9IGF3YWl0IHJlbmRlcmVyUmVzdWx0Lm5leHQoKTtcbiAgICAgICAgY29uc3Qgbm9kZSA9IGF3YWl0IHZhbHVlO1xuXG4gICAgICAgIGlmIChpc0xhc3RDYWxsICYmIGRvbmUpIHtcbiAgICAgICAgICBzdHJlYW1hYmxlVUkuZG9uZShub2RlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzdHJlYW1hYmxlVUkudXBkYXRlKG5vZGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGRvbmUpIGJyZWFrO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBub2RlID0gYXdhaXQgcmVuZGVyZXJSZXN1bHQ7XG5cbiAgICAgIGlmIChpc0xhc3RDYWxsKSB7XG4gICAgICAgIHN0cmVhbWFibGVVSS5kb25lKG5vZGUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RyZWFtYWJsZVVJLnVwZGF0ZShub2RlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyByZXNvbHZlIHRoZSBwcm9taXNlIHRvIHNpZ25hbCB0aGF0IHRoZSByZW5kZXIgY2FsbCBpcyBmaW5pc2hlZFxuICAgIHJlbmRlckZpbmlzaGVkLnJlc29sdmUodW5kZWZpbmVkKTtcbiAgfVxuXG4gIGNvbnN0IHJldHJ5ID0gcmV0cnlXaXRoRXhwb25lbnRpYWxCYWNrb2ZmKHsgbWF4UmV0cmllcyB9KTtcbiAgY29uc3QgdmFsaWRhdGVkUHJvbXB0ID0gc3RhbmRhcmRpemVQcm9tcHQoe1xuICAgIHByb21wdDogeyBzeXN0ZW0sIHByb21wdCwgbWVzc2FnZXMgfSxcbiAgICB0b29sczogdW5kZWZpbmVkLCAvLyBzdHJlYW1VSSB0b29scyBkb24ndCBzdXBwb3J0IG11bHRpLW1vZGFsIHRvb2wgcmVzdWx0IGNvbnZlcnNpb25cbiAgfSk7XG4gIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJldHJ5KGFzeW5jICgpID0+XG4gICAgbW9kZWwuZG9TdHJlYW0oe1xuICAgICAgbW9kZToge1xuICAgICAgICB0eXBlOiAncmVndWxhcicsXG4gICAgICAgIC4uLnByZXBhcmVUb29sc0FuZFRvb2xDaG9pY2Uoe1xuICAgICAgICAgIHRvb2xzLFxuICAgICAgICAgIHRvb2xDaG9pY2UsXG4gICAgICAgICAgYWN0aXZlVG9vbHM6IHVuZGVmaW5lZCxcbiAgICAgICAgfSksXG4gICAgICB9LFxuICAgICAgLi4ucHJlcGFyZUNhbGxTZXR0aW5ncyhzZXR0aW5ncyksXG4gICAgICBpbnB1dEZvcm1hdDogdmFsaWRhdGVkUHJvbXB0LnR5cGUsXG4gICAgICBwcm9tcHQ6IGF3YWl0IGNvbnZlcnRUb0xhbmd1YWdlTW9kZWxQcm9tcHQoe1xuICAgICAgICBwcm9tcHQ6IHZhbGlkYXRlZFByb21wdCxcbiAgICAgICAgbW9kZWxTdXBwb3J0c0ltYWdlVXJsczogbW9kZWwuc3VwcG9ydHNJbWFnZVVybHMsXG4gICAgICAgIG1vZGVsU3VwcG9ydHNVcmw6IG1vZGVsLnN1cHBvcnRzVXJsLFxuICAgICAgfSksXG4gICAgICBwcm92aWRlck1ldGFkYXRhLFxuICAgICAgYWJvcnRTaWduYWwsXG4gICAgICBoZWFkZXJzLFxuICAgIH0pLFxuICApO1xuXG4gIC8vIEZvciB0aGUgc3RyZWFtIGFuZCBjb25zdW1lIGl0IGFzeW5jaHJvbm91c2x5OlxuICBjb25zdCBbc3RyZWFtLCBmb3JrZWRTdHJlYW1dID0gcmVzdWx0LnN0cmVhbS50ZWUoKTtcbiAgKGFzeW5jICgpID0+IHtcbiAgICB0cnkge1xuICAgICAgbGV0IGNvbnRlbnQgPSAnJztcbiAgICAgIGxldCBoYXNUb29sQ2FsbCA9IGZhbHNlO1xuXG4gICAgICBjb25zdCByZWFkZXIgPSBmb3JrZWRTdHJlYW0uZ2V0UmVhZGVyKCk7XG4gICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICBjb25zdCB7IGRvbmUsIHZhbHVlIH0gPSBhd2FpdCByZWFkZXIucmVhZCgpO1xuICAgICAgICBpZiAoZG9uZSkgYnJlYWs7XG5cbiAgICAgICAgc3dpdGNoICh2YWx1ZS50eXBlKSB7XG4gICAgICAgICAgY2FzZSAndGV4dC1kZWx0YSc6IHtcbiAgICAgICAgICAgIGNvbnRlbnQgKz0gdmFsdWUudGV4dERlbHRhO1xuICAgICAgICAgICAgcmVuZGVyKHtcbiAgICAgICAgICAgICAgcmVuZGVyZXI6IHRleHRSZW5kZXIsXG4gICAgICAgICAgICAgIGFyZ3M6IFt7IGNvbnRlbnQsIGRvbmU6IGZhbHNlLCBkZWx0YTogdmFsdWUudGV4dERlbHRhIH1dLFxuICAgICAgICAgICAgICBzdHJlYW1hYmxlVUk6IHVpLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjYXNlICd0b29sLWNhbGwtZGVsdGEnOiB7XG4gICAgICAgICAgICBoYXNUb29sQ2FsbCA9IHRydWU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjYXNlICd0b29sLWNhbGwnOiB7XG4gICAgICAgICAgICBjb25zdCB0b29sTmFtZSA9IHZhbHVlLnRvb2xOYW1lIGFzIGtleW9mIFRPT0xTICYgc3RyaW5nO1xuXG4gICAgICAgICAgICBpZiAoIXRvb2xzKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBOb1N1Y2hUb29sRXJyb3IoeyB0b29sTmFtZSB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3QgdG9vbCA9IHRvb2xzW3Rvb2xOYW1lXTtcbiAgICAgICAgICAgIGlmICghdG9vbCkge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgTm9TdWNoVG9vbEVycm9yKHtcbiAgICAgICAgICAgICAgICB0b29sTmFtZSxcbiAgICAgICAgICAgICAgICBhdmFpbGFibGVUb29sczogT2JqZWN0LmtleXModG9vbHMpLFxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaGFzVG9vbENhbGwgPSB0cnVlO1xuICAgICAgICAgICAgY29uc3QgcGFyc2VSZXN1bHQgPSBzYWZlUGFyc2VKU09OKHtcbiAgICAgICAgICAgICAgdGV4dDogdmFsdWUuYXJncyxcbiAgICAgICAgICAgICAgc2NoZW1hOiB0b29sLnBhcmFtZXRlcnMsXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgaWYgKHBhcnNlUmVzdWx0LnN1Y2Nlc3MgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBJbnZhbGlkVG9vbEFyZ3VtZW50c0Vycm9yKHtcbiAgICAgICAgICAgICAgICB0b29sTmFtZSxcbiAgICAgICAgICAgICAgICB0b29sQXJnczogdmFsdWUuYXJncyxcbiAgICAgICAgICAgICAgICBjYXVzZTogcGFyc2VSZXN1bHQuZXJyb3IsXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZW5kZXIoe1xuICAgICAgICAgICAgICByZW5kZXJlcjogdG9vbC5nZW5lcmF0ZSxcbiAgICAgICAgICAgICAgYXJnczogW1xuICAgICAgICAgICAgICAgIHBhcnNlUmVzdWx0LnZhbHVlLFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgIHRvb2xOYW1lLFxuICAgICAgICAgICAgICAgICAgdG9vbENhbGxJZDogdmFsdWUudG9vbENhbGxJZCxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICBzdHJlYW1hYmxlVUk6IHVpLFxuICAgICAgICAgICAgICBpc0xhc3RDYWxsOiB0cnVlLFxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNhc2UgJ2Vycm9yJzoge1xuICAgICAgICAgICAgdGhyb3cgdmFsdWUuZXJyb3I7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY2FzZSAnZmluaXNoJzoge1xuICAgICAgICAgICAgZmluaXNoRXZlbnQgPSB7XG4gICAgICAgICAgICAgIGZpbmlzaFJlYXNvbjogdmFsdWUuZmluaXNoUmVhc29uLFxuICAgICAgICAgICAgICB1c2FnZTogY2FsY3VsYXRlTGFuZ3VhZ2VNb2RlbFVzYWdlKHZhbHVlLnVzYWdlKSxcbiAgICAgICAgICAgICAgd2FybmluZ3M6IHJlc3VsdC53YXJuaW5ncyxcbiAgICAgICAgICAgICAgcmF3UmVzcG9uc2U6IHJlc3VsdC5yYXdSZXNwb25zZSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKCFoYXNUb29sQ2FsbCkge1xuICAgICAgICByZW5kZXIoe1xuICAgICAgICAgIHJlbmRlcmVyOiB0ZXh0UmVuZGVyLFxuICAgICAgICAgIGFyZ3M6IFt7IGNvbnRlbnQsIGRvbmU6IHRydWUgfV0sXG4gICAgICAgICAgc3RyZWFtYWJsZVVJOiB1aSxcbiAgICAgICAgICBpc0xhc3RDYWxsOiB0cnVlLFxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgYXdhaXQgZmluaXNoZWQ7XG5cbiAgICAgIGlmIChmaW5pc2hFdmVudCAmJiBvbkZpbmlzaCkge1xuICAgICAgICBhd2FpdCBvbkZpbmlzaCh7XG4gICAgICAgICAgLi4uZmluaXNoRXZlbnQsXG4gICAgICAgICAgdmFsdWU6IHVpLnZhbHVlLFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgLy8gRHVyaW5nIHRoZSBzdHJlYW0gcmVuZGVyaW5nLCB3ZSBkb24ndCB3YW50IHRvIHRocm93IHRoZSBlcnJvciB0byB0aGVcbiAgICAgIC8vIHBhcmVudCBzY29wZSBidXQgb25seSBsZXQgdGhlIFJlYWN0J3MgZXJyb3IgYm91bmRhcnkgdG8gY2F0Y2ggaXQuXG4gICAgICB1aS5lcnJvcihlcnJvcik7XG4gICAgfVxuICB9KSgpO1xuXG4gIHJldHVybiB7XG4gICAgLi4ucmVzdWx0LFxuICAgIHN0cmVhbSxcbiAgICB2YWx1ZTogdWkudmFsdWUsXG4gIH07XG59XG4iLCJpbXBvcnQgeyBBSVNES0Vycm9yIH0gZnJvbSAnQGFpLXNkay9wcm92aWRlcic7XG5cbmNvbnN0IG5hbWUgPSAnQUlfRG93bmxvYWRFcnJvcic7XG5jb25zdCBtYXJrZXIgPSBgdmVyY2VsLmFpLmVycm9yLiR7bmFtZX1gO1xuY29uc3Qgc3ltYm9sID0gU3ltYm9sLmZvcihtYXJrZXIpO1xuXG5leHBvcnQgY2xhc3MgRG93bmxvYWRFcnJvciBleHRlbmRzIEFJU0RLRXJyb3Ige1xuICBwcml2YXRlIHJlYWRvbmx5IFtzeW1ib2xdID0gdHJ1ZTsgLy8gdXNlZCBpbiBpc0luc3RhbmNlXG5cbiAgcmVhZG9ubHkgdXJsOiBzdHJpbmc7XG4gIHJlYWRvbmx5IHN0YXR1c0NvZGU/OiBudW1iZXI7XG4gIHJlYWRvbmx5IHN0YXR1c1RleHQ/OiBzdHJpbmc7XG5cbiAgY29uc3RydWN0b3Ioe1xuICAgIHVybCxcbiAgICBzdGF0dXNDb2RlLFxuICAgIHN0YXR1c1RleHQsXG4gICAgY2F1c2UsXG4gICAgbWVzc2FnZSA9IGNhdXNlID09IG51bGxcbiAgICAgID8gYEZhaWxlZCB0byBkb3dubG9hZCAke3VybH06ICR7c3RhdHVzQ29kZX0gJHtzdGF0dXNUZXh0fWBcbiAgICAgIDogYEZhaWxlZCB0byBkb3dubG9hZCAke3VybH06ICR7Y2F1c2V9YCxcbiAgfToge1xuICAgIHVybDogc3RyaW5nO1xuICAgIHN0YXR1c0NvZGU/OiBudW1iZXI7XG4gICAgc3RhdHVzVGV4dD86IHN0cmluZztcbiAgICBtZXNzYWdlPzogc3RyaW5nO1xuICAgIGNhdXNlPzogdW5rbm93bjtcbiAgfSkge1xuICAgIHN1cGVyKHsgbmFtZSwgbWVzc2FnZSwgY2F1c2UgfSk7XG5cbiAgICB0aGlzLnVybCA9IHVybDtcbiAgICB0aGlzLnN0YXR1c0NvZGUgPSBzdGF0dXNDb2RlO1xuICAgIHRoaXMuc3RhdHVzVGV4dCA9IHN0YXR1c1RleHQ7XG4gIH1cblxuICBzdGF0aWMgaXNJbnN0YW5jZShlcnJvcjogdW5rbm93bik6IGVycm9yIGlzIERvd25sb2FkRXJyb3Ige1xuICAgIHJldHVybiBBSVNES0Vycm9yLmhhc01hcmtlcihlcnJvciwgbWFya2VyKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAZGVwcmVjYXRlZCB1c2UgYGlzSW5zdGFuY2VgIGluc3RlYWRcbiAgICovXG4gIHN0YXRpYyBpc0Rvd25sb2FkRXJyb3IoZXJyb3I6IHVua25vd24pOiBlcnJvciBpcyBEb3dubG9hZEVycm9yIHtcbiAgICByZXR1cm4gKFxuICAgICAgZXJyb3IgaW5zdGFuY2VvZiBFcnJvciAmJlxuICAgICAgZXJyb3IubmFtZSA9PT0gbmFtZSAmJlxuICAgICAgdHlwZW9mIChlcnJvciBhcyBEb3dubG9hZEVycm9yKS51cmwgPT09ICdzdHJpbmcnICYmXG4gICAgICAoKGVycm9yIGFzIERvd25sb2FkRXJyb3IpLnN0YXR1c0NvZGUgPT0gbnVsbCB8fFxuICAgICAgICB0eXBlb2YgKGVycm9yIGFzIERvd25sb2FkRXJyb3IpLnN0YXR1c0NvZGUgPT09ICdudW1iZXInKSAmJlxuICAgICAgKChlcnJvciBhcyBEb3dubG9hZEVycm9yKS5zdGF0dXNUZXh0ID09IG51bGwgfHxcbiAgICAgICAgdHlwZW9mIChlcnJvciBhcyBEb3dubG9hZEVycm9yKS5zdGF0dXNUZXh0ID09PSAnc3RyaW5nJylcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkIERvIG5vdCB1c2UgdGhpcyBtZXRob2QuIEl0IHdpbGwgYmUgcmVtb3ZlZCBpbiB0aGUgbmV4dCBtYWpvciB2ZXJzaW9uLlxuICAgKi9cbiAgdG9KU09OKCkge1xuICAgIHJldHVybiB7XG4gICAgICBuYW1lOiB0aGlzLm5hbWUsXG4gICAgICBtZXNzYWdlOiB0aGlzLm1lc3NhZ2UsXG4gICAgICB1cmw6IHRoaXMudXJsLFxuICAgICAgc3RhdHVzQ29kZTogdGhpcy5zdGF0dXNDb2RlLFxuICAgICAgc3RhdHVzVGV4dDogdGhpcy5zdGF0dXNUZXh0LFxuICAgICAgY2F1c2U6IHRoaXMuY2F1c2UsXG4gICAgfTtcbiAgfVxufVxuIiwiaW1wb3J0IHsgRG93bmxvYWRFcnJvciB9IGZyb20gJy4vZG93bmxvYWQtZXJyb3InO1xuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZG93bmxvYWQoe1xuICB1cmwsXG4gIGZldGNoSW1wbGVtZW50YXRpb24gPSBmZXRjaCxcbn06IHtcbiAgdXJsOiBVUkw7XG4gIGZldGNoSW1wbGVtZW50YXRpb24/OiB0eXBlb2YgZmV0Y2g7XG59KTogUHJvbWlzZTx7XG4gIGRhdGE6IFVpbnQ4QXJyYXk7XG4gIG1pbWVUeXBlOiBzdHJpbmcgfCB1bmRlZmluZWQ7XG59PiB7XG4gIGNvbnN0IHVybFRleHQgPSB1cmwudG9TdHJpbmcoKTtcbiAgdHJ5IHtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoSW1wbGVtZW50YXRpb24odXJsVGV4dCk7XG5cbiAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICB0aHJvdyBuZXcgRG93bmxvYWRFcnJvcih7XG4gICAgICAgIHVybDogdXJsVGV4dCxcbiAgICAgICAgc3RhdHVzQ29kZTogcmVzcG9uc2Uuc3RhdHVzLFxuICAgICAgICBzdGF0dXNUZXh0OiByZXNwb25zZS5zdGF0dXNUZXh0LFxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIGRhdGE6IG5ldyBVaW50OEFycmF5KGF3YWl0IHJlc3BvbnNlLmFycmF5QnVmZmVyKCkpLFxuICAgICAgbWltZVR5cGU6IHJlc3BvbnNlLmhlYWRlcnMuZ2V0KCdjb250ZW50LXR5cGUnKSA/PyB1bmRlZmluZWQsXG4gICAgfTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBpZiAoRG93bmxvYWRFcnJvci5pc0luc3RhbmNlKGVycm9yKSkge1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuXG4gICAgdGhyb3cgbmV3IERvd25sb2FkRXJyb3IoeyB1cmw6IHVybFRleHQsIGNhdXNlOiBlcnJvciB9KTtcbiAgfVxufVxuIiwiY29uc3QgbWltZVR5cGVTaWduYXR1cmVzID0gW1xuICB7IG1pbWVUeXBlOiAnaW1hZ2UvZ2lmJyBhcyBjb25zdCwgYnl0ZXM6IFsweDQ3LCAweDQ5LCAweDQ2XSB9LFxuICB7IG1pbWVUeXBlOiAnaW1hZ2UvcG5nJyBhcyBjb25zdCwgYnl0ZXM6IFsweDg5LCAweDUwLCAweDRlLCAweDQ3XSB9LFxuICB7IG1pbWVUeXBlOiAnaW1hZ2UvanBlZycgYXMgY29uc3QsIGJ5dGVzOiBbMHhmZiwgMHhkOF0gfSxcbiAgeyBtaW1lVHlwZTogJ2ltYWdlL3dlYnAnIGFzIGNvbnN0LCBieXRlczogWzB4NTIsIDB4NDksIDB4NDYsIDB4NDZdIH0sXG5dO1xuXG5leHBvcnQgZnVuY3Rpb24gZGV0ZWN0SW1hZ2VNaW1lVHlwZShcbiAgaW1hZ2U6IFVpbnQ4QXJyYXksXG4pOiAnaW1hZ2UvanBlZycgfCAnaW1hZ2UvcG5nJyB8ICdpbWFnZS9naWYnIHwgJ2ltYWdlL3dlYnAnIHwgdW5kZWZpbmVkIHtcbiAgZm9yIChjb25zdCB7IGJ5dGVzLCBtaW1lVHlwZSB9IG9mIG1pbWVUeXBlU2lnbmF0dXJlcykge1xuICAgIGlmIChcbiAgICAgIGltYWdlLmxlbmd0aCA+PSBieXRlcy5sZW5ndGggJiZcbiAgICAgIGJ5dGVzLmV2ZXJ5KChieXRlLCBpbmRleCkgPT4gaW1hZ2VbaW5kZXhdID09PSBieXRlKVxuICAgICkge1xuICAgICAgcmV0dXJuIG1pbWVUeXBlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB1bmRlZmluZWQ7XG59XG4iLCJpbXBvcnQge1xuICBjb252ZXJ0QmFzZTY0VG9VaW50OEFycmF5LFxuICBjb252ZXJ0VWludDhBcnJheVRvQmFzZTY0LFxufSBmcm9tICdAYWktc2RrL3Byb3ZpZGVyLXV0aWxzJztcbmltcG9ydCB7IEludmFsaWREYXRhQ29udGVudEVycm9yIH0gZnJvbSAnLi9pbnZhbGlkLWRhdGEtY29udGVudC1lcnJvcic7XG5pbXBvcnQgeyB6IH0gZnJvbSAnem9kJztcblxuLyoqXG5EYXRhIGNvbnRlbnQuIENhbiBlaXRoZXIgYmUgYSBiYXNlNjQtZW5jb2RlZCBzdHJpbmcsIGEgVWludDhBcnJheSwgYW4gQXJyYXlCdWZmZXIsIG9yIGEgQnVmZmVyLlxuICovXG5leHBvcnQgdHlwZSBEYXRhQ29udGVudCA9IHN0cmluZyB8IFVpbnQ4QXJyYXkgfCBBcnJheUJ1ZmZlciB8IEJ1ZmZlcjtcblxuLyoqXG5AaW50ZXJuYWxcbiAqL1xuZXhwb3J0IGNvbnN0IGRhdGFDb250ZW50U2NoZW1hOiB6LlpvZFR5cGU8RGF0YUNvbnRlbnQ+ID0gei51bmlvbihbXG4gIHouc3RyaW5nKCksXG4gIHouaW5zdGFuY2VvZihVaW50OEFycmF5KSxcbiAgei5pbnN0YW5jZW9mKEFycmF5QnVmZmVyKSxcbiAgei5jdXN0b20oXG4gICAgLy8gQnVmZmVyIG1pZ2h0IG5vdCBiZSBhdmFpbGFibGUgaW4gc29tZSBlbnZpcm9ubWVudHMgc3VjaCBhcyBDbG91ZEZsYXJlOlxuICAgICh2YWx1ZTogdW5rbm93bik6IHZhbHVlIGlzIEJ1ZmZlciA9PlxuICAgICAgZ2xvYmFsVGhpcy5CdWZmZXI/LmlzQnVmZmVyKHZhbHVlKSA/PyBmYWxzZSxcbiAgICB7IG1lc3NhZ2U6ICdNdXN0IGJlIGEgQnVmZmVyJyB9LFxuICApLFxuXSk7XG5cbi8qKlxuQ29udmVydHMgZGF0YSBjb250ZW50IHRvIGEgYmFzZTY0LWVuY29kZWQgc3RyaW5nLlxuXG5AcGFyYW0gY29udGVudCAtIERhdGEgY29udGVudCB0byBjb252ZXJ0LlxuQHJldHVybnMgQmFzZTY0LWVuY29kZWQgc3RyaW5nLlxuKi9cbmV4cG9ydCBmdW5jdGlvbiBjb252ZXJ0RGF0YUNvbnRlbnRUb0Jhc2U2NFN0cmluZyhjb250ZW50OiBEYXRhQ29udGVudCk6IHN0cmluZyB7XG4gIGlmICh0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gY29udGVudDtcbiAgfVxuXG4gIGlmIChjb250ZW50IGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICByZXR1cm4gY29udmVydFVpbnQ4QXJyYXlUb0Jhc2U2NChuZXcgVWludDhBcnJheShjb250ZW50KSk7XG4gIH1cblxuICByZXR1cm4gY29udmVydFVpbnQ4QXJyYXlUb0Jhc2U2NChjb250ZW50KTtcbn1cblxuLyoqXG5Db252ZXJ0cyBkYXRhIGNvbnRlbnQgdG8gYSBVaW50OEFycmF5LlxuXG5AcGFyYW0gY29udGVudCAtIERhdGEgY29udGVudCB0byBjb252ZXJ0LlxuQHJldHVybnMgVWludDhBcnJheS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvbnZlcnREYXRhQ29udGVudFRvVWludDhBcnJheShcbiAgY29udGVudDogRGF0YUNvbnRlbnQsXG4pOiBVaW50OEFycmF5IHtcbiAgaWYgKGNvbnRlbnQgaW5zdGFuY2VvZiBVaW50OEFycmF5KSB7XG4gICAgcmV0dXJuIGNvbnRlbnQ7XG4gIH1cblxuICBpZiAodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBjb252ZXJ0QmFzZTY0VG9VaW50OEFycmF5KGNvbnRlbnQpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZERhdGFDb250ZW50RXJyb3Ioe1xuICAgICAgICBtZXNzYWdlOlxuICAgICAgICAgICdJbnZhbGlkIGRhdGEgY29udGVudC4gQ29udGVudCBzdHJpbmcgaXMgbm90IGEgYmFzZTY0LWVuY29kZWQgbWVkaWEuJyxcbiAgICAgICAgY29udGVudCxcbiAgICAgICAgY2F1c2U6IGVycm9yLFxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgaWYgKGNvbnRlbnQgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgIHJldHVybiBuZXcgVWludDhBcnJheShjb250ZW50KTtcbiAgfVxuXG4gIHRocm93IG5ldyBJbnZhbGlkRGF0YUNvbnRlbnRFcnJvcih7IGNvbnRlbnQgfSk7XG59XG5cbi8qKlxuICogQ29udmVydHMgYSBVaW50OEFycmF5IHRvIGEgc3RyaW5nIG9mIHRleHQuXG4gKlxuICogQHBhcmFtIHVpbnQ4QXJyYXkgLSBUaGUgVWludDhBcnJheSB0byBjb252ZXJ0LlxuICogQHJldHVybnMgVGhlIGNvbnZlcnRlZCBzdHJpbmcuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjb252ZXJ0VWludDhBcnJheVRvVGV4dCh1aW50OEFycmF5OiBVaW50OEFycmF5KTogc3RyaW5nIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gbmV3IFRleHREZWNvZGVyKCkuZGVjb2RlKHVpbnQ4QXJyYXkpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHRocm93IG5ldyBFcnJvcignRXJyb3IgZGVjb2RpbmcgVWludDhBcnJheSB0byB0ZXh0Jyk7XG4gIH1cbn1cbiIsImltcG9ydCB7IEFJU0RLRXJyb3IgfSBmcm9tICdAYWktc2RrL3Byb3ZpZGVyJztcblxuY29uc3QgbmFtZSA9ICdBSV9JbnZhbGlkRGF0YUNvbnRlbnRFcnJvcic7XG5jb25zdCBtYXJrZXIgPSBgdmVyY2VsLmFpLmVycm9yLiR7bmFtZX1gO1xuY29uc3Qgc3ltYm9sID0gU3ltYm9sLmZvcihtYXJrZXIpO1xuXG5leHBvcnQgY2xhc3MgSW52YWxpZERhdGFDb250ZW50RXJyb3IgZXh0ZW5kcyBBSVNES0Vycm9yIHtcbiAgcHJpdmF0ZSByZWFkb25seSBbc3ltYm9sXSA9IHRydWU7IC8vIHVzZWQgaW4gaXNJbnN0YW5jZVxuXG4gIHJlYWRvbmx5IGNvbnRlbnQ6IHVua25vd247XG5cbiAgY29uc3RydWN0b3Ioe1xuICAgIGNvbnRlbnQsXG4gICAgY2F1c2UsXG4gICAgbWVzc2FnZSA9IGBJbnZhbGlkIGRhdGEgY29udGVudC4gRXhwZWN0ZWQgYSBiYXNlNjQgc3RyaW5nLCBVaW50OEFycmF5LCBBcnJheUJ1ZmZlciwgb3IgQnVmZmVyLCBidXQgZ290ICR7dHlwZW9mIGNvbnRlbnR9LmAsXG4gIH06IHtcbiAgICBjb250ZW50OiB1bmtub3duO1xuICAgIGNhdXNlPzogdW5rbm93bjtcbiAgICBtZXNzYWdlPzogc3RyaW5nO1xuICB9KSB7XG4gICAgc3VwZXIoeyBuYW1lLCBtZXNzYWdlLCBjYXVzZSB9KTtcblxuICAgIHRoaXMuY29udGVudCA9IGNvbnRlbnQ7XG4gIH1cblxuICBzdGF0aWMgaXNJbnN0YW5jZShlcnJvcjogdW5rbm93bik6IGVycm9yIGlzIEludmFsaWREYXRhQ29udGVudEVycm9yIHtcbiAgICByZXR1cm4gQUlTREtFcnJvci5oYXNNYXJrZXIoZXJyb3IsIG1hcmtlcik7XG4gIH1cblxuICAvKipcbiAgICogQGRlcHJlY2F0ZWQgdXNlIGBpc0luc3RhbmNlYCBpbnN0ZWFkXG4gICAqL1xuICBzdGF0aWMgaXNJbnZhbGlkRGF0YUNvbnRlbnRFcnJvcihcbiAgICBlcnJvcjogdW5rbm93bixcbiAgKTogZXJyb3IgaXMgSW52YWxpZERhdGFDb250ZW50RXJyb3Ige1xuICAgIHJldHVybiAoXG4gICAgICBlcnJvciBpbnN0YW5jZW9mIEVycm9yICYmXG4gICAgICBlcnJvci5uYW1lID09PSBuYW1lICYmXG4gICAgICAoZXJyb3IgYXMgSW52YWxpZERhdGFDb250ZW50RXJyb3IpLmNvbnRlbnQgIT0gbnVsbFxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogQGRlcHJlY2F0ZWQgRG8gbm90IHVzZSB0aGlzIG1ldGhvZC4gSXQgd2lsbCBiZSByZW1vdmVkIGluIHRoZSBuZXh0IG1ham9yIHZlcnNpb24uXG4gICAqL1xuICB0b0pTT04oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG5hbWU6IHRoaXMubmFtZSxcbiAgICAgIG1lc3NhZ2U6IHRoaXMubWVzc2FnZSxcbiAgICAgIHN0YWNrOiB0aGlzLnN0YWNrLFxuICAgICAgY2F1c2U6IHRoaXMuY2F1c2UsXG4gICAgICBjb250ZW50OiB0aGlzLmNvbnRlbnQsXG4gICAgfTtcbiAgfVxufVxuIiwiaW1wb3J0IHsgQUlTREtFcnJvciB9IGZyb20gJ0BhaS1zZGsvcHJvdmlkZXInO1xuXG5jb25zdCBuYW1lID0gJ0FJX0ludmFsaWRNZXNzYWdlUm9sZUVycm9yJztcbmNvbnN0IG1hcmtlciA9IGB2ZXJjZWwuYWkuZXJyb3IuJHtuYW1lfWA7XG5jb25zdCBzeW1ib2wgPSBTeW1ib2wuZm9yKG1hcmtlcik7XG5cbmV4cG9ydCBjbGFzcyBJbnZhbGlkTWVzc2FnZVJvbGVFcnJvciBleHRlbmRzIEFJU0RLRXJyb3Ige1xuICBwcml2YXRlIHJlYWRvbmx5IFtzeW1ib2xdID0gdHJ1ZTsgLy8gdXNlZCBpbiBpc0luc3RhbmNlXG5cbiAgcmVhZG9ubHkgcm9sZTogc3RyaW5nO1xuXG4gIGNvbnN0cnVjdG9yKHtcbiAgICByb2xlLFxuICAgIG1lc3NhZ2UgPSBgSW52YWxpZCBtZXNzYWdlIHJvbGU6ICcke3JvbGV9Jy4gTXVzdCBiZSBvbmUgb2Y6IFwic3lzdGVtXCIsIFwidXNlclwiLCBcImFzc2lzdGFudFwiLCBcInRvb2xcIi5gLFxuICB9OiB7XG4gICAgcm9sZTogc3RyaW5nO1xuICAgIG1lc3NhZ2U/OiBzdHJpbmc7XG4gIH0pIHtcbiAgICBzdXBlcih7IG5hbWUsIG1lc3NhZ2UgfSk7XG5cbiAgICB0aGlzLnJvbGUgPSByb2xlO1xuICB9XG5cbiAgc3RhdGljIGlzSW5zdGFuY2UoZXJyb3I6IHVua25vd24pOiBlcnJvciBpcyBJbnZhbGlkTWVzc2FnZVJvbGVFcnJvciB7XG4gICAgcmV0dXJuIEFJU0RLRXJyb3IuaGFzTWFya2VyKGVycm9yLCBtYXJrZXIpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkIHVzZSBgaXNJbnN0YW5jZWAgaW5zdGVhZFxuICAgKi9cbiAgc3RhdGljIGlzSW52YWxpZE1lc3NhZ2VSb2xlRXJyb3IoXG4gICAgZXJyb3I6IHVua25vd24sXG4gICk6IGVycm9yIGlzIEludmFsaWRNZXNzYWdlUm9sZUVycm9yIHtcbiAgICByZXR1cm4gKFxuICAgICAgZXJyb3IgaW5zdGFuY2VvZiBFcnJvciAmJlxuICAgICAgZXJyb3IubmFtZSA9PT0gbmFtZSAmJlxuICAgICAgdHlwZW9mIChlcnJvciBhcyBJbnZhbGlkTWVzc2FnZVJvbGVFcnJvcikucm9sZSA9PT0gJ3N0cmluZydcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkIERvIG5vdCB1c2UgdGhpcyBtZXRob2QuIEl0IHdpbGwgYmUgcmVtb3ZlZCBpbiB0aGUgbmV4dCBtYWpvciB2ZXJzaW9uLlxuICAgKi9cbiAgdG9KU09OKCkge1xuICAgIHJldHVybiB7XG4gICAgICBuYW1lOiB0aGlzLm5hbWUsXG4gICAgICBtZXNzYWdlOiB0aGlzLm1lc3NhZ2UsXG4gICAgICBzdGFjazogdGhpcy5zdGFjayxcblxuICAgICAgcm9sZTogdGhpcy5yb2xlLFxuICAgIH07XG4gIH1cbn1cbiIsImV4cG9ydCBmdW5jdGlvbiBzcGxpdERhdGFVcmwoZGF0YVVybDogc3RyaW5nKToge1xuICBtaW1lVHlwZTogc3RyaW5nIHwgdW5kZWZpbmVkO1xuICBiYXNlNjRDb250ZW50OiBzdHJpbmcgfCB1bmRlZmluZWQ7XG59IHtcbiAgdHJ5IHtcbiAgICBjb25zdCBbaGVhZGVyLCBiYXNlNjRDb250ZW50XSA9IGRhdGFVcmwuc3BsaXQoJywnKTtcbiAgICByZXR1cm4ge1xuICAgICAgbWltZVR5cGU6IGhlYWRlci5zcGxpdCgnOycpWzBdLnNwbGl0KCc6JylbMV0sXG4gICAgICBiYXNlNjRDb250ZW50LFxuICAgIH07XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG1pbWVUeXBlOiB1bmRlZmluZWQsXG4gICAgICBiYXNlNjRDb250ZW50OiB1bmRlZmluZWQsXG4gICAgfTtcbiAgfVxufVxuIiwiaW1wb3J0IHtcbiAgTGFuZ3VhZ2VNb2RlbFYxRmlsZVBhcnQsXG4gIExhbmd1YWdlTW9kZWxWMUltYWdlUGFydCxcbiAgTGFuZ3VhZ2VNb2RlbFYxTWVzc2FnZSxcbiAgTGFuZ3VhZ2VNb2RlbFYxUHJvbXB0LFxuICBMYW5ndWFnZU1vZGVsVjFUZXh0UGFydCxcbn0gZnJvbSAnQGFpLXNkay9wcm92aWRlcic7XG5pbXBvcnQgeyBkb3dubG9hZCB9IGZyb20gJy4uLy4uL3V0aWwvZG93bmxvYWQnO1xuaW1wb3J0IHsgQ29yZU1lc3NhZ2UgfSBmcm9tICcuLi9wcm9tcHQvbWVzc2FnZSc7XG5pbXBvcnQgeyBkZXRlY3RJbWFnZU1pbWVUeXBlIH0gZnJvbSAnLi4vdXRpbC9kZXRlY3QtaW1hZ2UtbWltZXR5cGUnO1xuaW1wb3J0IHsgRmlsZVBhcnQsIEltYWdlUGFydCwgVGV4dFBhcnQgfSBmcm9tICcuL2NvbnRlbnQtcGFydCc7XG5pbXBvcnQge1xuICBjb252ZXJ0RGF0YUNvbnRlbnRUb0Jhc2U2NFN0cmluZyxcbiAgY29udmVydERhdGFDb250ZW50VG9VaW50OEFycmF5LFxuICBEYXRhQ29udGVudCxcbn0gZnJvbSAnLi9kYXRhLWNvbnRlbnQnO1xuaW1wb3J0IHsgSW52YWxpZE1lc3NhZ2VSb2xlRXJyb3IgfSBmcm9tICcuL2ludmFsaWQtbWVzc2FnZS1yb2xlLWVycm9yJztcbmltcG9ydCB7IHNwbGl0RGF0YVVybCB9IGZyb20gJy4vc3BsaXQtZGF0YS11cmwnO1xuaW1wb3J0IHsgU3RhbmRhcmRpemVkUHJvbXB0IH0gZnJvbSAnLi9zdGFuZGFyZGl6ZS1wcm9tcHQnO1xuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gY29udmVydFRvTGFuZ3VhZ2VNb2RlbFByb21wdCh7XG4gIHByb21wdCxcbiAgbW9kZWxTdXBwb3J0c0ltYWdlVXJscyA9IHRydWUsXG4gIG1vZGVsU3VwcG9ydHNVcmwgPSAoKSA9PiBmYWxzZSxcbiAgZG93bmxvYWRJbXBsZW1lbnRhdGlvbiA9IGRvd25sb2FkLFxufToge1xuICBwcm9tcHQ6IFN0YW5kYXJkaXplZFByb21wdDtcbiAgbW9kZWxTdXBwb3J0c0ltYWdlVXJsczogYm9vbGVhbiB8IHVuZGVmaW5lZDtcbiAgbW9kZWxTdXBwb3J0c1VybDogdW5kZWZpbmVkIHwgKCh1cmw6IFVSTCkgPT4gYm9vbGVhbik7XG4gIGRvd25sb2FkSW1wbGVtZW50YXRpb24/OiB0eXBlb2YgZG93bmxvYWQ7XG59KTogUHJvbWlzZTxMYW5ndWFnZU1vZGVsVjFQcm9tcHQ+IHtcbiAgY29uc3QgZG93bmxvYWRlZEFzc2V0cyA9IGF3YWl0IGRvd25sb2FkQXNzZXRzKFxuICAgIHByb21wdC5tZXNzYWdlcyxcbiAgICBkb3dubG9hZEltcGxlbWVudGF0aW9uLFxuICAgIG1vZGVsU3VwcG9ydHNJbWFnZVVybHMsXG4gICAgbW9kZWxTdXBwb3J0c1VybCxcbiAgKTtcblxuICByZXR1cm4gW1xuICAgIC4uLihwcm9tcHQuc3lzdGVtICE9IG51bGxcbiAgICAgID8gW3sgcm9sZTogJ3N5c3RlbScgYXMgY29uc3QsIGNvbnRlbnQ6IHByb21wdC5zeXN0ZW0gfV1cbiAgICAgIDogW10pLFxuICAgIC4uLnByb21wdC5tZXNzYWdlcy5tYXAobWVzc2FnZSA9PlxuICAgICAgY29udmVydFRvTGFuZ3VhZ2VNb2RlbE1lc3NhZ2UobWVzc2FnZSwgZG93bmxvYWRlZEFzc2V0cyksXG4gICAgKSxcbiAgXTtcbn1cblxuLyoqXG4gKiBDb252ZXJ0IGEgQ29yZU1lc3NhZ2UgdG8gYSBMYW5ndWFnZU1vZGVsVjFNZXNzYWdlLlxuICpcbiAqIEBwYXJhbSBtZXNzYWdlIFRoZSBDb3JlTWVzc2FnZSB0byBjb252ZXJ0LlxuICogQHBhcmFtIGRvd25sb2FkZWRBc3NldHMgQSBtYXAgb2YgVVJMcyB0byB0aGVpciBkb3dubG9hZGVkIGRhdGEuIE9ubHlcbiAqICAgYXZhaWxhYmxlIGlmIHRoZSBtb2RlbCBkb2VzIG5vdCBzdXBwb3J0IFVSTHMsIG51bGwgb3RoZXJ3aXNlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY29udmVydFRvTGFuZ3VhZ2VNb2RlbE1lc3NhZ2UoXG4gIG1lc3NhZ2U6IENvcmVNZXNzYWdlLFxuICBkb3dubG9hZGVkQXNzZXRzOiBSZWNvcmQ8XG4gICAgc3RyaW5nLFxuICAgIHsgbWltZVR5cGU6IHN0cmluZyB8IHVuZGVmaW5lZDsgZGF0YTogVWludDhBcnJheSB9XG4gID4sXG4pOiBMYW5ndWFnZU1vZGVsVjFNZXNzYWdlIHtcbiAgY29uc3Qgcm9sZSA9IG1lc3NhZ2Uucm9sZTtcbiAgc3dpdGNoIChyb2xlKSB7XG4gICAgY2FzZSAnc3lzdGVtJzoge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcm9sZTogJ3N5c3RlbScsXG4gICAgICAgIGNvbnRlbnQ6IG1lc3NhZ2UuY29udGVudCxcbiAgICAgICAgcHJvdmlkZXJNZXRhZGF0YTogbWVzc2FnZS5leHBlcmltZW50YWxfcHJvdmlkZXJNZXRhZGF0YSxcbiAgICAgIH07XG4gICAgfVxuXG4gICAgY2FzZSAndXNlcic6IHtcbiAgICAgIGlmICh0eXBlb2YgbWVzc2FnZS5jb250ZW50ID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHJvbGU6ICd1c2VyJyxcbiAgICAgICAgICBjb250ZW50OiBbeyB0eXBlOiAndGV4dCcsIHRleHQ6IG1lc3NhZ2UuY29udGVudCB9XSxcbiAgICAgICAgICBwcm92aWRlck1ldGFkYXRhOiBtZXNzYWdlLmV4cGVyaW1lbnRhbF9wcm92aWRlck1ldGFkYXRhLFxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICByb2xlOiAndXNlcicsXG4gICAgICAgIGNvbnRlbnQ6IG1lc3NhZ2UuY29udGVudFxuICAgICAgICAgIC5tYXAocGFydCA9PiBjb252ZXJ0UGFydFRvTGFuZ3VhZ2VNb2RlbFBhcnQocGFydCwgZG93bmxvYWRlZEFzc2V0cykpXG4gICAgICAgICAgLy8gcmVtb3ZlIGVtcHR5IHRleHQgcGFydHM6XG4gICAgICAgICAgLmZpbHRlcihwYXJ0ID0+IHBhcnQudHlwZSAhPT0gJ3RleHQnIHx8IHBhcnQudGV4dCAhPT0gJycpLFxuICAgICAgICBwcm92aWRlck1ldGFkYXRhOiBtZXNzYWdlLmV4cGVyaW1lbnRhbF9wcm92aWRlck1ldGFkYXRhLFxuICAgICAgfTtcbiAgICB9XG5cbiAgICBjYXNlICdhc3Npc3RhbnQnOiB7XG4gICAgICBpZiAodHlwZW9mIG1lc3NhZ2UuY29udGVudCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICByb2xlOiAnYXNzaXN0YW50JyxcbiAgICAgICAgICBjb250ZW50OiBbeyB0eXBlOiAndGV4dCcsIHRleHQ6IG1lc3NhZ2UuY29udGVudCB9XSxcbiAgICAgICAgICBwcm92aWRlck1ldGFkYXRhOiBtZXNzYWdlLmV4cGVyaW1lbnRhbF9wcm92aWRlck1ldGFkYXRhLFxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICByb2xlOiAnYXNzaXN0YW50JyxcbiAgICAgICAgY29udGVudDogbWVzc2FnZS5jb250ZW50XG4gICAgICAgICAgLmZpbHRlcihcbiAgICAgICAgICAgIC8vIHJlbW92ZSBlbXB0eSB0ZXh0IHBhcnRzOlxuICAgICAgICAgICAgcGFydCA9PiBwYXJ0LnR5cGUgIT09ICd0ZXh0JyB8fCBwYXJ0LnRleHQgIT09ICcnLFxuICAgICAgICAgIClcbiAgICAgICAgICAubWFwKHBhcnQgPT4ge1xuICAgICAgICAgICAgY29uc3QgeyBleHBlcmltZW50YWxfcHJvdmlkZXJNZXRhZGF0YSwgLi4ucmVzdCB9ID0gcGFydDtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIC4uLnJlc3QsXG4gICAgICAgICAgICAgIHByb3ZpZGVyTWV0YWRhdGE6IGV4cGVyaW1lbnRhbF9wcm92aWRlck1ldGFkYXRhLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9KSxcbiAgICAgICAgcHJvdmlkZXJNZXRhZGF0YTogbWVzc2FnZS5leHBlcmltZW50YWxfcHJvdmlkZXJNZXRhZGF0YSxcbiAgICAgIH07XG4gICAgfVxuXG4gICAgY2FzZSAndG9vbCc6IHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHJvbGU6ICd0b29sJyxcbiAgICAgICAgY29udGVudDogbWVzc2FnZS5jb250ZW50Lm1hcChwYXJ0ID0+ICh7XG4gICAgICAgICAgdHlwZTogJ3Rvb2wtcmVzdWx0JyxcbiAgICAgICAgICB0b29sQ2FsbElkOiBwYXJ0LnRvb2xDYWxsSWQsXG4gICAgICAgICAgdG9vbE5hbWU6IHBhcnQudG9vbE5hbWUsXG4gICAgICAgICAgcmVzdWx0OiBwYXJ0LnJlc3VsdCxcbiAgICAgICAgICBjb250ZW50OiBwYXJ0LmV4cGVyaW1lbnRhbF9jb250ZW50LFxuICAgICAgICAgIGlzRXJyb3I6IHBhcnQuaXNFcnJvcixcbiAgICAgICAgICBwcm92aWRlck1ldGFkYXRhOiBwYXJ0LmV4cGVyaW1lbnRhbF9wcm92aWRlck1ldGFkYXRhLFxuICAgICAgICB9KSksXG4gICAgICAgIHByb3ZpZGVyTWV0YWRhdGE6IG1lc3NhZ2UuZXhwZXJpbWVudGFsX3Byb3ZpZGVyTWV0YWRhdGEsXG4gICAgICB9O1xuICAgIH1cblxuICAgIGRlZmF1bHQ6IHtcbiAgICAgIGNvbnN0IF9leGhhdXN0aXZlQ2hlY2s6IG5ldmVyID0gcm9sZTtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkTWVzc2FnZVJvbGVFcnJvcih7IHJvbGU6IF9leGhhdXN0aXZlQ2hlY2sgfSk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogRG93bmxvYWRzIGltYWdlcyBhbmQgZmlsZXMgZnJvbSBVUkxzIGluIHRoZSBtZXNzYWdlcy5cbiAqL1xuYXN5bmMgZnVuY3Rpb24gZG93bmxvYWRBc3NldHMoXG4gIG1lc3NhZ2VzOiBDb3JlTWVzc2FnZVtdLFxuICBkb3dubG9hZEltcGxlbWVudGF0aW9uOiB0eXBlb2YgZG93bmxvYWQsXG4gIG1vZGVsU3VwcG9ydHNJbWFnZVVybHM6IGJvb2xlYW4gfCB1bmRlZmluZWQsXG4gIG1vZGVsU3VwcG9ydHNVcmw6ICh1cmw6IFVSTCkgPT4gYm9vbGVhbixcbik6IFByb21pc2U8UmVjb3JkPHN0cmluZywgeyBtaW1lVHlwZTogc3RyaW5nIHwgdW5kZWZpbmVkOyBkYXRhOiBVaW50OEFycmF5IH0+PiB7XG4gIGNvbnN0IHVybHMgPSBtZXNzYWdlc1xuICAgIC5maWx0ZXIobWVzc2FnZSA9PiBtZXNzYWdlLnJvbGUgPT09ICd1c2VyJylcbiAgICAubWFwKG1lc3NhZ2UgPT4gbWVzc2FnZS5jb250ZW50KVxuICAgIC5maWx0ZXIoKGNvbnRlbnQpOiBjb250ZW50IGlzIEFycmF5PFRleHRQYXJ0IHwgSW1hZ2VQYXJ0IHwgRmlsZVBhcnQ+ID0+XG4gICAgICBBcnJheS5pc0FycmF5KGNvbnRlbnQpLFxuICAgIClcbiAgICAuZmxhdCgpXG4gICAgLmZpbHRlcihcbiAgICAgIChwYXJ0KTogcGFydCBpcyBJbWFnZVBhcnQgfCBGaWxlUGFydCA9PlxuICAgICAgICBwYXJ0LnR5cGUgPT09ICdpbWFnZScgfHwgcGFydC50eXBlID09PSAnZmlsZScsXG4gICAgKVxuICAgIC8qKlxuICAgICAqIEZpbHRlciBvdXQgaW1hZ2UgcGFydHMgaWYgdGhlIG1vZGVsIHN1cHBvcnRzIGltYWdlIFVSTHMsIGJlZm9yZSBsZXR0aW5nIGl0XG4gICAgICogZGVjaWRlIGlmIGl0IHN1cHBvcnRzIGEgcGFydGljdWxhciBVUkwuXG4gICAgICovXG4gICAgLmZpbHRlcihcbiAgICAgIChwYXJ0KTogcGFydCBpcyBJbWFnZVBhcnQgfCBGaWxlUGFydCA9PlxuICAgICAgICAhKHBhcnQudHlwZSA9PT0gJ2ltYWdlJyAmJiBtb2RlbFN1cHBvcnRzSW1hZ2VVcmxzID09PSB0cnVlKSxcbiAgICApXG4gICAgLm1hcChwYXJ0ID0+IChwYXJ0LnR5cGUgPT09ICdpbWFnZScgPyBwYXJ0LmltYWdlIDogcGFydC5kYXRhKSlcbiAgICAubWFwKHBhcnQgPT5cbiAgICAgIC8vIHN1cHBvcnQgc3RyaW5nIHVybHM6XG4gICAgICB0eXBlb2YgcGFydCA9PT0gJ3N0cmluZycgJiZcbiAgICAgIChwYXJ0LnN0YXJ0c1dpdGgoJ2h0dHA6JykgfHwgcGFydC5zdGFydHNXaXRoKCdodHRwczonKSlcbiAgICAgICAgPyBuZXcgVVJMKHBhcnQpXG4gICAgICAgIDogcGFydCxcbiAgICApXG4gICAgLmZpbHRlcigoaW1hZ2UpOiBpbWFnZSBpcyBVUkwgPT4gaW1hZ2UgaW5zdGFuY2VvZiBVUkwpXG4gICAgLyoqXG4gICAgICogRmlsdGVyIG91dCBVUkxzIHRoYXQgdGhlIG1vZGVsIHN1cHBvcnRzIG5hdGl2ZWx5LCBzbyB3ZSBkb24ndCBkb3dubG9hZCB0aGVtLlxuICAgICAqL1xuICAgIC5maWx0ZXIodXJsID0+ICFtb2RlbFN1cHBvcnRzVXJsKHVybCkpO1xuXG4gIC8vIGRvd25sb2FkIGluIHBhcmFsbGVsOlxuICBjb25zdCBkb3dubG9hZGVkSW1hZ2VzID0gYXdhaXQgUHJvbWlzZS5hbGwoXG4gICAgdXJscy5tYXAoYXN5bmMgdXJsID0+ICh7XG4gICAgICB1cmwsXG4gICAgICBkYXRhOiBhd2FpdCBkb3dubG9hZEltcGxlbWVudGF0aW9uKHsgdXJsIH0pLFxuICAgIH0pKSxcbiAgKTtcblxuICByZXR1cm4gT2JqZWN0LmZyb21FbnRyaWVzKFxuICAgIGRvd25sb2FkZWRJbWFnZXMubWFwKCh7IHVybCwgZGF0YSB9KSA9PiBbdXJsLnRvU3RyaW5nKCksIGRhdGFdKSxcbiAgKTtcbn1cblxuLyoqXG4gKiBDb252ZXJ0IHBhcnQgb2YgYSBtZXNzYWdlIHRvIGEgTGFuZ3VhZ2VNb2RlbFYxUGFydC5cbiAqIEBwYXJhbSBwYXJ0IFRoZSBwYXJ0IHRvIGNvbnZlcnQuXG4gKiBAcGFyYW0gZG93bmxvYWRlZEFzc2V0cyBBIG1hcCBvZiBVUkxzIHRvIHRoZWlyIGRvd25sb2FkZWQgZGF0YS4gT25seVxuICogIGF2YWlsYWJsZSBpZiB0aGUgbW9kZWwgZG9lcyBub3Qgc3VwcG9ydCBVUkxzLCBudWxsIG90aGVyd2lzZS5cbiAqXG4gKiBAcmV0dXJucyBUaGUgY29udmVydGVkIHBhcnQuXG4gKi9cbmZ1bmN0aW9uIGNvbnZlcnRQYXJ0VG9MYW5ndWFnZU1vZGVsUGFydChcbiAgcGFydDogVGV4dFBhcnQgfCBJbWFnZVBhcnQgfCBGaWxlUGFydCxcbiAgZG93bmxvYWRlZEFzc2V0czogUmVjb3JkPFxuICAgIHN0cmluZyxcbiAgICB7IG1pbWVUeXBlOiBzdHJpbmcgfCB1bmRlZmluZWQ7IGRhdGE6IFVpbnQ4QXJyYXkgfVxuICA+LFxuKTpcbiAgfCBMYW5ndWFnZU1vZGVsVjFUZXh0UGFydFxuICB8IExhbmd1YWdlTW9kZWxWMUltYWdlUGFydFxuICB8IExhbmd1YWdlTW9kZWxWMUZpbGVQYXJ0IHtcbiAgaWYgKHBhcnQudHlwZSA9PT0gJ3RleHQnKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6ICd0ZXh0JyxcbiAgICAgIHRleHQ6IHBhcnQudGV4dCxcbiAgICAgIHByb3ZpZGVyTWV0YWRhdGE6IHBhcnQuZXhwZXJpbWVudGFsX3Byb3ZpZGVyTWV0YWRhdGEsXG4gICAgfTtcbiAgfVxuXG4gIGxldCBtaW1lVHlwZTogc3RyaW5nIHwgdW5kZWZpbmVkID0gcGFydC5taW1lVHlwZTtcbiAgbGV0IGRhdGE6IERhdGFDb250ZW50IHwgVVJMO1xuICBsZXQgY29udGVudDogVVJMIHwgQXJyYXlCdWZmZXIgfCBzdHJpbmc7XG4gIGxldCBub3JtYWxpemVkRGF0YTogVWludDhBcnJheSB8IFVSTDtcblxuICBjb25zdCB0eXBlID0gcGFydC50eXBlO1xuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlICdpbWFnZSc6XG4gICAgICBkYXRhID0gcGFydC5pbWFnZTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2ZpbGUnOlxuICAgICAgZGF0YSA9IHBhcnQuZGF0YTtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIHBhcnQgdHlwZTogJHt0eXBlfWApO1xuICB9XG5cbiAgLy8gQXR0ZW1wdCB0byBjcmVhdGUgYSBVUkwgZnJvbSB0aGUgZGF0YS4gSWYgaXQgZmFpbHMsIHdlIGNhbiBhc3N1bWUgdGhlIGRhdGFcbiAgLy8gaXMgbm90IGEgVVJMIGFuZCBsaWtlbHkgc29tZSBvdGhlciBzb3J0IG9mIGRhdGEuXG4gIHRyeSB7XG4gICAgY29udGVudCA9IHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJyA/IG5ldyBVUkwoZGF0YSkgOiBkYXRhO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnRlbnQgPSBkYXRhO1xuICB9XG5cbiAgLy8gSWYgd2Ugc3VjY2Vzc2Z1bGx5IGNyZWF0ZWQgYSBVUkwsIHdlIGNhbiB1c2UgdGhhdCB0byBub3JtYWxpemUgdGhlIGRhdGFcbiAgLy8gZWl0aGVyIGJ5IHBhc3NpbmcgaXQgdGhyb3VnaCBvciBjb252ZXJ0aW5nIG5vcm1hbGl6aW5nIHRoZSBiYXNlNjQgY29udGVudFxuICAvLyB0byBhIFVpbnQ4QXJyYXkuXG4gIGlmIChjb250ZW50IGluc3RhbmNlb2YgVVJMKSB7XG4gICAgLy8gSWYgdGhlIGNvbnRlbnQgaXMgYSBkYXRhIFVSTCwgd2Ugd2FudCB0byBjb252ZXJ0IHRoYXQgdG8gYSBVaW50OEFycmF5XG4gICAgaWYgKGNvbnRlbnQucHJvdG9jb2wgPT09ICdkYXRhOicpIHtcbiAgICAgIGNvbnN0IHsgbWltZVR5cGU6IGRhdGFVcmxNaW1lVHlwZSwgYmFzZTY0Q29udGVudCB9ID0gc3BsaXREYXRhVXJsKFxuICAgICAgICBjb250ZW50LnRvU3RyaW5nKCksXG4gICAgICApO1xuXG4gICAgICBpZiAoZGF0YVVybE1pbWVUeXBlID09IG51bGwgfHwgYmFzZTY0Q29udGVudCA9PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBkYXRhIFVSTCBmb3JtYXQgaW4gcGFydCAke3R5cGV9YCk7XG4gICAgICB9XG5cbiAgICAgIG1pbWVUeXBlID0gZGF0YVVybE1pbWVUeXBlO1xuICAgICAgbm9ybWFsaXplZERhdGEgPSBjb252ZXJ0RGF0YUNvbnRlbnRUb1VpbnQ4QXJyYXkoYmFzZTY0Q29udGVudCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8qKlxuICAgICAgICogSWYgdGhlIGNvbnRlbnQgaXMgYSBVUkwsIHdlIHNob3VsZCBmaXJzdCBzZWUgaWYgaXQgd2FzIGRvd25sb2FkZWQuIEFuZCBpZiBub3QsXG4gICAgICAgKiB3ZSBjYW4gbGV0IHRoZSBtb2RlbCBkZWNpZGUgaWYgaXQgd2FudHMgdG8gc3VwcG9ydCB0aGUgVVJMLiBUaGlzIGFsc28gYWxsb3dzXG4gICAgICAgKiBmb3Igbm9uLUhUVFAgVVJMcyB0byBiZSBwYXNzZWQgdGhyb3VnaCAoZS5nLiBnczovLykuXG4gICAgICAgKi9cbiAgICAgIGNvbnN0IGRvd25sb2FkZWRGaWxlID0gZG93bmxvYWRlZEFzc2V0c1tjb250ZW50LnRvU3RyaW5nKCldO1xuICAgICAgaWYgKGRvd25sb2FkZWRGaWxlKSB7XG4gICAgICAgIG5vcm1hbGl6ZWREYXRhID0gZG93bmxvYWRlZEZpbGUuZGF0YTtcbiAgICAgICAgbWltZVR5cGUgPz89IGRvd25sb2FkZWRGaWxlLm1pbWVUeXBlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbm9ybWFsaXplZERhdGEgPSBjb250ZW50O1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBTaW5jZSB3ZSBrbm93IGtub3cgdGhlIGNvbnRlbnQgaXMgbm90IGEgVVJMLCB3ZSBjYW4gYXR0ZW1wdCB0byBub3JtYWxpemUgdGhlIGRhdGFcbiAgICAvLyBhc3N1bWluZyBpdCBpcyBzb21lIHNvcnQgb2YgZGF0YS5cbiAgICBub3JtYWxpemVkRGF0YSA9IGNvbnZlcnREYXRhQ29udGVudFRvVWludDhBcnJheShjb250ZW50KTtcbiAgfVxuXG4gIC8vIE5vdyB0aGF0IHdlIGhhdmUgdGhlIG5vcm1hbGl6ZWQgZGF0YSBlaXRoZXIgYXMgYSBVUkwgb3IgYSBVaW50OEFycmF5LFxuICAvLyB3ZSBjYW4gY3JlYXRlIHRoZSBMYW5ndWFnZU1vZGVsVjFQYXJ0LlxuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlICdpbWFnZSc6XG4gICAgICAvLyBXZSBnaXZlIGEgYmVzdCBlZmZvcnQgdG8gZGV0ZWN0IHRoZSBtaW1lIHR5cGUgaWYgaXQgaXMgbm90IHByb3ZpZGVkLlxuICAgICAgLy8gb3RoZXJ3aXNlLCB3ZSB1c2UgdGhlIHByb3ZpZGVkIG1pbWUgdHlwZS5cbiAgICAgIGlmIChtaW1lVHlwZSA9PSBudWxsICYmIG5vcm1hbGl6ZWREYXRhIGluc3RhbmNlb2YgVWludDhBcnJheSkge1xuICAgICAgICBtaW1lVHlwZSA9IGRldGVjdEltYWdlTWltZVR5cGUobm9ybWFsaXplZERhdGEpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiAnaW1hZ2UnLFxuICAgICAgICBpbWFnZTogbm9ybWFsaXplZERhdGEsXG4gICAgICAgIG1pbWVUeXBlLFxuICAgICAgICBwcm92aWRlck1ldGFkYXRhOiBwYXJ0LmV4cGVyaW1lbnRhbF9wcm92aWRlck1ldGFkYXRhLFxuICAgICAgfTtcbiAgICBjYXNlICdmaWxlJzpcbiAgICAgIC8vIFdlIHNob3VsZCBoYXZlIGEgbWltZVR5cGUgYXQgdGhpcyBwb2ludCwgaWYgbm90LCB0aHJvdyBhbiBlcnJvci5cbiAgICAgIGlmIChtaW1lVHlwZSA9PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgTWltZSB0eXBlIGlzIG1pc3NpbmcgZm9yIGZpbGUgcGFydGApO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiAnZmlsZScsXG4gICAgICAgIGRhdGE6XG4gICAgICAgICAgbm9ybWFsaXplZERhdGEgaW5zdGFuY2VvZiBVaW50OEFycmF5XG4gICAgICAgICAgICA/IGNvbnZlcnREYXRhQ29udGVudFRvQmFzZTY0U3RyaW5nKG5vcm1hbGl6ZWREYXRhKVxuICAgICAgICAgICAgOiBub3JtYWxpemVkRGF0YSxcbiAgICAgICAgbWltZVR5cGUsXG4gICAgICAgIHByb3ZpZGVyTWV0YWRhdGE6IHBhcnQuZXhwZXJpbWVudGFsX3Byb3ZpZGVyTWV0YWRhdGEsXG4gICAgICB9O1xuICB9XG59XG4iLCJpbXBvcnQgeyBBSVNES0Vycm9yIH0gZnJvbSAnQGFpLXNkay9wcm92aWRlcic7XG5cbmNvbnN0IG5hbWUgPSAnQUlfSW52YWxpZEFyZ3VtZW50RXJyb3InO1xuY29uc3QgbWFya2VyID0gYHZlcmNlbC5haS5lcnJvci4ke25hbWV9YDtcbmNvbnN0IHN5bWJvbCA9IFN5bWJvbC5mb3IobWFya2VyKTtcblxuZXhwb3J0IGNsYXNzIEludmFsaWRBcmd1bWVudEVycm9yIGV4dGVuZHMgQUlTREtFcnJvciB7XG4gIHByaXZhdGUgcmVhZG9ubHkgW3N5bWJvbF0gPSB0cnVlOyAvLyB1c2VkIGluIGlzSW5zdGFuY2VcblxuICByZWFkb25seSBwYXJhbWV0ZXI6IHN0cmluZztcbiAgcmVhZG9ubHkgdmFsdWU6IHVua25vd247XG5cbiAgY29uc3RydWN0b3Ioe1xuICAgIHBhcmFtZXRlcixcbiAgICB2YWx1ZSxcbiAgICBtZXNzYWdlLFxuICB9OiB7XG4gICAgcGFyYW1ldGVyOiBzdHJpbmc7XG4gICAgdmFsdWU6IHVua25vd247XG4gICAgbWVzc2FnZTogc3RyaW5nO1xuICB9KSB7XG4gICAgc3VwZXIoe1xuICAgICAgbmFtZSxcbiAgICAgIG1lc3NhZ2U6IGBJbnZhbGlkIGFyZ3VtZW50IGZvciBwYXJhbWV0ZXIgJHtwYXJhbWV0ZXJ9OiAke21lc3NhZ2V9YCxcbiAgICB9KTtcblxuICAgIHRoaXMucGFyYW1ldGVyID0gcGFyYW1ldGVyO1xuICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgfVxuXG4gIHN0YXRpYyBpc0luc3RhbmNlKGVycm9yOiB1bmtub3duKTogZXJyb3IgaXMgSW52YWxpZEFyZ3VtZW50RXJyb3Ige1xuICAgIHJldHVybiBBSVNES0Vycm9yLmhhc01hcmtlcihlcnJvciwgbWFya2VyKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAZGVwcmVjYXRlZCB1c2UgYGlzSW5zdGFuY2VgIGluc3RlYWRcbiAgICovXG4gIHN0YXRpYyBpc0ludmFsaWRBcmd1bWVudEVycm9yKGVycm9yOiB1bmtub3duKTogZXJyb3IgaXMgSW52YWxpZEFyZ3VtZW50RXJyb3Ige1xuICAgIHJldHVybiAoXG4gICAgICBlcnJvciBpbnN0YW5jZW9mIEVycm9yICYmXG4gICAgICBlcnJvci5uYW1lID09PSBuYW1lICYmXG4gICAgICB0eXBlb2YgKGVycm9yIGFzIEludmFsaWRBcmd1bWVudEVycm9yKS5wYXJhbWV0ZXIgPT09ICdzdHJpbmcnICYmXG4gICAgICB0eXBlb2YgKGVycm9yIGFzIEludmFsaWRBcmd1bWVudEVycm9yKS52YWx1ZSA9PT0gJ3N0cmluZydcbiAgICApO1xuICB9XG5cbiAgdG9KU09OKCkge1xuICAgIHJldHVybiB7XG4gICAgICBuYW1lOiB0aGlzLm5hbWUsXG4gICAgICBtZXNzYWdlOiB0aGlzLm1lc3NhZ2UsXG4gICAgICBzdGFjazogdGhpcy5zdGFjayxcblxuICAgICAgcGFyYW1ldGVyOiB0aGlzLnBhcmFtZXRlcixcbiAgICAgIHZhbHVlOiB0aGlzLnZhbHVlLFxuICAgIH07XG4gIH1cbn1cbiIsImltcG9ydCB7IEludmFsaWRBcmd1bWVudEVycm9yIH0gZnJvbSAnLi4vLi4vZXJyb3JzL2ludmFsaWQtYXJndW1lbnQtZXJyb3InO1xuaW1wb3J0IHsgQ2FsbFNldHRpbmdzIH0gZnJvbSAnLi9jYWxsLXNldHRpbmdzJztcblxuLyoqXG4gKiBWYWxpZGF0ZXMgY2FsbCBzZXR0aW5ncyBhbmQgc2V0cyBkZWZhdWx0IHZhbHVlcy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHByZXBhcmVDYWxsU2V0dGluZ3Moe1xuICBtYXhUb2tlbnMsXG4gIHRlbXBlcmF0dXJlLFxuICB0b3BQLFxuICB0b3BLLFxuICBwcmVzZW5jZVBlbmFsdHksXG4gIGZyZXF1ZW5jeVBlbmFsdHksXG4gIHN0b3BTZXF1ZW5jZXMsXG4gIHNlZWQsXG4gIG1heFJldHJpZXMsXG59OiBPbWl0PENhbGxTZXR0aW5ncywgJ2Fib3J0U2lnbmFsJyB8ICdoZWFkZXJzJz4pOiBPbWl0PFxuICBDYWxsU2V0dGluZ3MsXG4gICdhYm9ydFNpZ25hbCcgfCAnaGVhZGVycydcbj4ge1xuICBpZiAobWF4VG9rZW5zICE9IG51bGwpIHtcbiAgICBpZiAoIU51bWJlci5pc0ludGVnZXIobWF4VG9rZW5zKSkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKHtcbiAgICAgICAgcGFyYW1ldGVyOiAnbWF4VG9rZW5zJyxcbiAgICAgICAgdmFsdWU6IG1heFRva2VucyxcbiAgICAgICAgbWVzc2FnZTogJ21heFRva2VucyBtdXN0IGJlIGFuIGludGVnZXInLFxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKG1heFRva2VucyA8IDEpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcih7XG4gICAgICAgIHBhcmFtZXRlcjogJ21heFRva2VucycsXG4gICAgICAgIHZhbHVlOiBtYXhUb2tlbnMsXG4gICAgICAgIG1lc3NhZ2U6ICdtYXhUb2tlbnMgbXVzdCBiZSA+PSAxJyxcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIGlmICh0ZW1wZXJhdHVyZSAhPSBudWxsKSB7XG4gICAgaWYgKHR5cGVvZiB0ZW1wZXJhdHVyZSAhPT0gJ251bWJlcicpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcih7XG4gICAgICAgIHBhcmFtZXRlcjogJ3RlbXBlcmF0dXJlJyxcbiAgICAgICAgdmFsdWU6IHRlbXBlcmF0dXJlLFxuICAgICAgICBtZXNzYWdlOiAndGVtcGVyYXR1cmUgbXVzdCBiZSBhIG51bWJlcicsXG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICBpZiAodG9wUCAhPSBudWxsKSB7XG4gICAgaWYgKHR5cGVvZiB0b3BQICE9PSAnbnVtYmVyJykge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKHtcbiAgICAgICAgcGFyYW1ldGVyOiAndG9wUCcsXG4gICAgICAgIHZhbHVlOiB0b3BQLFxuICAgICAgICBtZXNzYWdlOiAndG9wUCBtdXN0IGJlIGEgbnVtYmVyJyxcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIGlmICh0b3BLICE9IG51bGwpIHtcbiAgICBpZiAodHlwZW9mIHRvcEsgIT09ICdudW1iZXInKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3Ioe1xuICAgICAgICBwYXJhbWV0ZXI6ICd0b3BLJyxcbiAgICAgICAgdmFsdWU6IHRvcEssXG4gICAgICAgIG1lc3NhZ2U6ICd0b3BLIG11c3QgYmUgYSBudW1iZXInLFxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgaWYgKHByZXNlbmNlUGVuYWx0eSAhPSBudWxsKSB7XG4gICAgaWYgKHR5cGVvZiBwcmVzZW5jZVBlbmFsdHkgIT09ICdudW1iZXInKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3Ioe1xuICAgICAgICBwYXJhbWV0ZXI6ICdwcmVzZW5jZVBlbmFsdHknLFxuICAgICAgICB2YWx1ZTogcHJlc2VuY2VQZW5hbHR5LFxuICAgICAgICBtZXNzYWdlOiAncHJlc2VuY2VQZW5hbHR5IG11c3QgYmUgYSBudW1iZXInLFxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgaWYgKGZyZXF1ZW5jeVBlbmFsdHkgIT0gbnVsbCkge1xuICAgIGlmICh0eXBlb2YgZnJlcXVlbmN5UGVuYWx0eSAhPT0gJ251bWJlcicpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcih7XG4gICAgICAgIHBhcmFtZXRlcjogJ2ZyZXF1ZW5jeVBlbmFsdHknLFxuICAgICAgICB2YWx1ZTogZnJlcXVlbmN5UGVuYWx0eSxcbiAgICAgICAgbWVzc2FnZTogJ2ZyZXF1ZW5jeVBlbmFsdHkgbXVzdCBiZSBhIG51bWJlcicsXG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICBpZiAoc2VlZCAhPSBudWxsKSB7XG4gICAgaWYgKCFOdW1iZXIuaXNJbnRlZ2VyKHNlZWQpKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3Ioe1xuICAgICAgICBwYXJhbWV0ZXI6ICdzZWVkJyxcbiAgICAgICAgdmFsdWU6IHNlZWQsXG4gICAgICAgIG1lc3NhZ2U6ICdzZWVkIG11c3QgYmUgYW4gaW50ZWdlcicsXG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICBpZiAobWF4UmV0cmllcyAhPSBudWxsKSB7XG4gICAgaWYgKCFOdW1iZXIuaXNJbnRlZ2VyKG1heFJldHJpZXMpKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3Ioe1xuICAgICAgICBwYXJhbWV0ZXI6ICdtYXhSZXRyaWVzJyxcbiAgICAgICAgdmFsdWU6IG1heFJldHJpZXMsXG4gICAgICAgIG1lc3NhZ2U6ICdtYXhSZXRyaWVzIG11c3QgYmUgYW4gaW50ZWdlcicsXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAobWF4UmV0cmllcyA8IDApIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcih7XG4gICAgICAgIHBhcmFtZXRlcjogJ21heFJldHJpZXMnLFxuICAgICAgICB2YWx1ZTogbWF4UmV0cmllcyxcbiAgICAgICAgbWVzc2FnZTogJ21heFJldHJpZXMgbXVzdCBiZSA+PSAwJyxcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgbWF4VG9rZW5zLFxuICAgIHRlbXBlcmF0dXJlOiB0ZW1wZXJhdHVyZSA/PyAwLFxuICAgIHRvcFAsXG4gICAgdG9wSyxcbiAgICBwcmVzZW5jZVBlbmFsdHksXG4gICAgZnJlcXVlbmN5UGVuYWx0eSxcbiAgICBzdG9wU2VxdWVuY2VzOlxuICAgICAgc3RvcFNlcXVlbmNlcyAhPSBudWxsICYmIHN0b3BTZXF1ZW5jZXMubGVuZ3RoID4gMFxuICAgICAgICA/IHN0b3BTZXF1ZW5jZXNcbiAgICAgICAgOiB1bmRlZmluZWQsXG4gICAgc2VlZCxcbiAgICBtYXhSZXRyaWVzOiBtYXhSZXRyaWVzID8/IDIsXG4gIH07XG59XG4iLCJpbXBvcnQge1xuICBMYW5ndWFnZU1vZGVsVjFGdW5jdGlvblRvb2wsXG4gIExhbmd1YWdlTW9kZWxWMVByb3ZpZGVyRGVmaW5lZFRvb2wsXG4gIExhbmd1YWdlTW9kZWxWMVRvb2xDaG9pY2UsXG59IGZyb20gJ0BhaS1zZGsvcHJvdmlkZXInO1xuaW1wb3J0IHsgYXNTY2hlbWEgfSBmcm9tICdAYWktc2RrL3VpLXV0aWxzJztcbmltcG9ydCB7IENvcmVUb29sIH0gZnJvbSAnLi4vdG9vbC90b29sJztcbmltcG9ydCB7IENvcmVUb29sQ2hvaWNlIH0gZnJvbSAnLi4vdHlwZXMvbGFuZ3VhZ2UtbW9kZWwnO1xuaW1wb3J0IHsgaXNOb25FbXB0eU9iamVjdCB9IGZyb20gJy4uL3V0aWwvaXMtbm9uLWVtcHR5LW9iamVjdCc7XG5cbmV4cG9ydCBmdW5jdGlvbiBwcmVwYXJlVG9vbHNBbmRUb29sQ2hvaWNlPFxuICBUT09MUyBleHRlbmRzIFJlY29yZDxzdHJpbmcsIENvcmVUb29sPixcbj4oe1xuICB0b29scyxcbiAgdG9vbENob2ljZSxcbiAgYWN0aXZlVG9vbHMsXG59OiB7XG4gIHRvb2xzOiBUT09MUyB8IHVuZGVmaW5lZDtcbiAgdG9vbENob2ljZTogQ29yZVRvb2xDaG9pY2U8VE9PTFM+IHwgdW5kZWZpbmVkO1xuICBhY3RpdmVUb29sczogQXJyYXk8a2V5b2YgVE9PTFM+IHwgdW5kZWZpbmVkO1xufSk6IHtcbiAgdG9vbHM6XG4gICAgfCBBcnJheTxMYW5ndWFnZU1vZGVsVjFGdW5jdGlvblRvb2wgfCBMYW5ndWFnZU1vZGVsVjFQcm92aWRlckRlZmluZWRUb29sPlxuICAgIHwgdW5kZWZpbmVkO1xuICB0b29sQ2hvaWNlOiBMYW5ndWFnZU1vZGVsVjFUb29sQ2hvaWNlIHwgdW5kZWZpbmVkO1xufSB7XG4gIGlmICghaXNOb25FbXB0eU9iamVjdCh0b29scykpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdG9vbHM6IHVuZGVmaW5lZCxcbiAgICAgIHRvb2xDaG9pY2U6IHVuZGVmaW5lZCxcbiAgICB9O1xuICB9XG5cbiAgLy8gd2hlbiBhY3RpdmVUb29scyBpcyBwcm92aWRlZCwgd2Ugb25seSBpbmNsdWRlIHRoZSB0b29scyB0aGF0IGFyZSBpbiB0aGUgbGlzdDpcbiAgY29uc3QgZmlsdGVyZWRUb29scyA9XG4gICAgYWN0aXZlVG9vbHMgIT0gbnVsbFxuICAgICAgPyBPYmplY3QuZW50cmllcyh0b29scykuZmlsdGVyKChbbmFtZV0pID0+XG4gICAgICAgICAgYWN0aXZlVG9vbHMuaW5jbHVkZXMobmFtZSBhcyBrZXlvZiBUT09MUyksXG4gICAgICAgIClcbiAgICAgIDogT2JqZWN0LmVudHJpZXModG9vbHMpO1xuXG4gIHJldHVybiB7XG4gICAgdG9vbHM6IGZpbHRlcmVkVG9vbHMubWFwKChbbmFtZSwgdG9vbF0pID0+IHtcbiAgICAgIGNvbnN0IHRvb2xUeXBlID0gdG9vbC50eXBlO1xuICAgICAgc3dpdGNoICh0b29sVHlwZSkge1xuICAgICAgICBjYXNlIHVuZGVmaW5lZDpcbiAgICAgICAgY2FzZSAnZnVuY3Rpb24nOlxuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiAnZnVuY3Rpb24nIGFzIGNvbnN0LFxuICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uOiB0b29sLmRlc2NyaXB0aW9uLFxuICAgICAgICAgICAgcGFyYW1ldGVyczogYXNTY2hlbWEodG9vbC5wYXJhbWV0ZXJzKS5qc29uU2NoZW1hLFxuICAgICAgICAgIH07XG4gICAgICAgIGNhc2UgJ3Byb3ZpZGVyLWRlZmluZWQnOlxuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiAncHJvdmlkZXItZGVmaW5lZCcgYXMgY29uc3QsXG4gICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgaWQ6IHRvb2wuaWQsXG4gICAgICAgICAgICBhcmdzOiB0b29sLmFyZ3MsXG4gICAgICAgICAgfTtcbiAgICAgICAgZGVmYXVsdDoge1xuICAgICAgICAgIGNvbnN0IGV4aGF1c3RpdmVDaGVjazogbmV2ZXIgPSB0b29sVHlwZTtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIHRvb2wgdHlwZTogJHtleGhhdXN0aXZlQ2hlY2t9YCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KSxcbiAgICB0b29sQ2hvaWNlOlxuICAgICAgdG9vbENob2ljZSA9PSBudWxsXG4gICAgICAgID8geyB0eXBlOiAnYXV0bycgfVxuICAgICAgICA6IHR5cGVvZiB0b29sQ2hvaWNlID09PSAnc3RyaW5nJ1xuICAgICAgICA/IHsgdHlwZTogdG9vbENob2ljZSB9XG4gICAgICAgIDogeyB0eXBlOiAndG9vbCcgYXMgY29uc3QsIHRvb2xOYW1lOiB0b29sQ2hvaWNlLnRvb2xOYW1lIGFzIHN0cmluZyB9LFxuICB9O1xufVxuIiwiZXhwb3J0IGZ1bmN0aW9uIGlzTm9uRW1wdHlPYmplY3QoXG4gIG9iamVjdDogUmVjb3JkPHN0cmluZywgdW5rbm93bj4gfCB1bmRlZmluZWQgfCBudWxsLFxuKTogb2JqZWN0IGlzIFJlY29yZDxzdHJpbmcsIHVua25vd24+IHtcbiAgcmV0dXJuIG9iamVjdCAhPSBudWxsICYmIE9iamVjdC5rZXlzKG9iamVjdCkubGVuZ3RoID4gMDtcbn1cbiIsImltcG9ydCB7IEludmFsaWRQcm9tcHRFcnJvciB9IGZyb20gJ0BhaS1zZGsvcHJvdmlkZXInO1xuaW1wb3J0IHsgc2FmZVZhbGlkYXRlVHlwZXMgfSBmcm9tICdAYWktc2RrL3Byb3ZpZGVyLXV0aWxzJztcbmltcG9ydCB7IHogfSBmcm9tICd6b2QnO1xuaW1wb3J0IHsgQ29yZU1lc3NhZ2UsIGNvcmVNZXNzYWdlU2NoZW1hIH0gZnJvbSAnLi9tZXNzYWdlJztcbmltcG9ydCB7IFByb21wdCB9IGZyb20gJy4vcHJvbXB0JztcbmltcG9ydCB7IGRldGVjdFByb21wdFR5cGUgfSBmcm9tICcuL2RldGVjdC1wcm9tcHQtdHlwZSc7XG5pbXBvcnQgeyBjb252ZXJ0VG9Db3JlTWVzc2FnZXMgfSBmcm9tICcuL2NvbnZlcnQtdG8tY29yZS1tZXNzYWdlcyc7XG5pbXBvcnQgeyBVSU1lc3NhZ2UgfSBmcm9tICcuL3VpLW1lc3NhZ2UnO1xuaW1wb3J0IHsgQ29yZVRvb2wgfSBmcm9tICcuLi90b29sL3Rvb2wnO1xuXG5leHBvcnQgdHlwZSBTdGFuZGFyZGl6ZWRQcm9tcHQgPSB7XG4gIC8qKlxuICAgKiBPcmlnaW5hbCBwcm9tcHQgdHlwZS4gVGhpcyBpcyBmb3J3YXJkZWQgdG8gdGhlIHByb3ZpZGVycyBhbmQgY2FuIGJlIHVzZWRcbiAgICogdG8gd3JpdGUgc2VuZCByYXcgdGV4dCB0byBwcm92aWRlcnMgdGhhdCBzdXBwb3J0IGl0LlxuICAgKi9cbiAgdHlwZTogJ3Byb21wdCcgfCAnbWVzc2FnZXMnO1xuXG4gIC8qKlxuICAgKiBTeXN0ZW0gbWVzc2FnZS5cbiAgICovXG4gIHN5c3RlbT86IHN0cmluZztcblxuICAvKipcbiAgICogTWVzc2FnZXMuXG4gICAqL1xuICBtZXNzYWdlczogQ29yZU1lc3NhZ2VbXTtcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiBzdGFuZGFyZGl6ZVByb21wdDxUT09MUyBleHRlbmRzIFJlY29yZDxzdHJpbmcsIENvcmVUb29sPj4oe1xuICBwcm9tcHQsXG4gIHRvb2xzLFxufToge1xuICBwcm9tcHQ6IFByb21wdDtcbiAgdG9vbHM6IHVuZGVmaW5lZCB8IFRPT0xTO1xufSk6IFN0YW5kYXJkaXplZFByb21wdCB7XG4gIGlmIChwcm9tcHQucHJvbXB0ID09IG51bGwgJiYgcHJvbXB0Lm1lc3NhZ2VzID09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgSW52YWxpZFByb21wdEVycm9yKHtcbiAgICAgIHByb21wdCxcbiAgICAgIG1lc3NhZ2U6ICdwcm9tcHQgb3IgbWVzc2FnZXMgbXVzdCBiZSBkZWZpbmVkJyxcbiAgICB9KTtcbiAgfVxuXG4gIGlmIChwcm9tcHQucHJvbXB0ICE9IG51bGwgJiYgcHJvbXB0Lm1lc3NhZ2VzICE9IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgSW52YWxpZFByb21wdEVycm9yKHtcbiAgICAgIHByb21wdCxcbiAgICAgIG1lc3NhZ2U6ICdwcm9tcHQgYW5kIG1lc3NhZ2VzIGNhbm5vdCBiZSBkZWZpbmVkIGF0IHRoZSBzYW1lIHRpbWUnLFxuICAgIH0pO1xuICB9XG5cbiAgLy8gdmFsaWRhdGUgdGhhdCBzeXN0ZW0gaXMgYSBzdHJpbmdcbiAgaWYgKHByb21wdC5zeXN0ZW0gIT0gbnVsbCAmJiB0eXBlb2YgcHJvbXB0LnN5c3RlbSAhPT0gJ3N0cmluZycpIHtcbiAgICB0aHJvdyBuZXcgSW52YWxpZFByb21wdEVycm9yKHtcbiAgICAgIHByb21wdCxcbiAgICAgIG1lc3NhZ2U6ICdzeXN0ZW0gbXVzdCBiZSBhIHN0cmluZycsXG4gICAgfSk7XG4gIH1cblxuICAvLyB0eXBlOiBwcm9tcHRcbiAgaWYgKHByb21wdC5wcm9tcHQgIT0gbnVsbCkge1xuICAgIC8vIHZhbGlkYXRlIHRoYXQgcHJvbXB0IGlzIGEgc3RyaW5nXG4gICAgaWYgKHR5cGVvZiBwcm9tcHQucHJvbXB0ICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRQcm9tcHRFcnJvcih7XG4gICAgICAgIHByb21wdCxcbiAgICAgICAgbWVzc2FnZTogJ3Byb21wdCBtdXN0IGJlIGEgc3RyaW5nJyxcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiAncHJvbXB0JyxcbiAgICAgIHN5c3RlbTogcHJvbXB0LnN5c3RlbSxcbiAgICAgIG1lc3NhZ2VzOiBbXG4gICAgICAgIHtcbiAgICAgICAgICByb2xlOiAndXNlcicsXG4gICAgICAgICAgY29udGVudDogcHJvbXB0LnByb21wdCxcbiAgICAgICAgfSxcbiAgICAgIF0sXG4gICAgfTtcbiAgfVxuXG4gIC8vIHR5cGU6IG1lc3NhZ2VzXG4gIGlmIChwcm9tcHQubWVzc2FnZXMgIT0gbnVsbCkge1xuICAgIGNvbnN0IHByb21wdFR5cGUgPSBkZXRlY3RQcm9tcHRUeXBlKHByb21wdC5tZXNzYWdlcyk7XG5cbiAgICBpZiAocHJvbXB0VHlwZSA9PT0gJ290aGVyJykge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRQcm9tcHRFcnJvcih7XG4gICAgICAgIHByb21wdCxcbiAgICAgICAgbWVzc2FnZTogJ21lc3NhZ2VzIG11c3QgYmUgYW4gYXJyYXkgb2YgQ29yZU1lc3NhZ2Ugb3IgVUlNZXNzYWdlJyxcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGNvbnN0IG1lc3NhZ2VzOiBDb3JlTWVzc2FnZVtdID1cbiAgICAgIHByb21wdFR5cGUgPT09ICd1aS1tZXNzYWdlcydcbiAgICAgICAgPyBjb252ZXJ0VG9Db3JlTWVzc2FnZXMocHJvbXB0Lm1lc3NhZ2VzIGFzIFVJTWVzc2FnZVtdLCB7XG4gICAgICAgICAgICB0b29scyxcbiAgICAgICAgICB9KVxuICAgICAgICA6IChwcm9tcHQubWVzc2FnZXMgYXMgQ29yZU1lc3NhZ2VbXSk7XG5cbiAgICBjb25zdCB2YWxpZGF0aW9uUmVzdWx0ID0gc2FmZVZhbGlkYXRlVHlwZXMoe1xuICAgICAgdmFsdWU6IG1lc3NhZ2VzLFxuICAgICAgc2NoZW1hOiB6LmFycmF5KGNvcmVNZXNzYWdlU2NoZW1hKSxcbiAgICB9KTtcblxuICAgIGlmICghdmFsaWRhdGlvblJlc3VsdC5zdWNjZXNzKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZFByb21wdEVycm9yKHtcbiAgICAgICAgcHJvbXB0LFxuICAgICAgICBtZXNzYWdlOiAnbWVzc2FnZXMgbXVzdCBiZSBhbiBhcnJheSBvZiBDb3JlTWVzc2FnZSBvciBVSU1lc3NhZ2UnLFxuICAgICAgICBjYXVzZTogdmFsaWRhdGlvblJlc3VsdC5lcnJvcixcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiAnbWVzc2FnZXMnLFxuICAgICAgbWVzc2FnZXMsXG4gICAgICBzeXN0ZW06IHByb21wdC5zeXN0ZW0sXG4gICAgfTtcbiAgfVxuXG4gIHRocm93IG5ldyBFcnJvcigndW5yZWFjaGFibGUnKTtcbn1cbiIsImltcG9ydCB7IHogfSBmcm9tICd6b2QnO1xuaW1wb3J0IHsgUHJvdmlkZXJNZXRhZGF0YSB9IGZyb20gJy4uL3R5cGVzJztcbmltcG9ydCB7IHByb3ZpZGVyTWV0YWRhdGFTY2hlbWEgfSBmcm9tICcuLi90eXBlcy9wcm92aWRlci1tZXRhZGF0YSc7XG5pbXBvcnQge1xuICBGaWxlUGFydCxcbiAgZmlsZVBhcnRTY2hlbWEsXG4gIEltYWdlUGFydCxcbiAgaW1hZ2VQYXJ0U2NoZW1hLFxuICBUZXh0UGFydCxcbiAgdGV4dFBhcnRTY2hlbWEsXG4gIFRvb2xDYWxsUGFydCxcbiAgdG9vbENhbGxQYXJ0U2NoZW1hLFxuICBUb29sUmVzdWx0UGFydCxcbiAgdG9vbFJlc3VsdFBhcnRTY2hlbWEsXG59IGZyb20gJy4vY29udGVudC1wYXJ0JztcblxuLyoqXG4gQSBzeXN0ZW0gbWVzc2FnZS4gSXQgY2FuIGNvbnRhaW4gc3lzdGVtIGluZm9ybWF0aW9uLlxuXG4gTm90ZTogdXNpbmcgdGhlIFwic3lzdGVtXCIgcGFydCBvZiB0aGUgcHJvbXB0IGlzIHN0cm9uZ2x5IHByZWZlcnJlZFxuIHRvIGluY3JlYXNlIHRoZSByZXNpbGllbmNlIGFnYWluc3QgcHJvbXB0IGluamVjdGlvbiBhdHRhY2tzLFxuIGFuZCBiZWNhdXNlIG5vdCBhbGwgcHJvdmlkZXJzIHN1cHBvcnQgc2V2ZXJhbCBzeXN0ZW0gbWVzc2FnZXMuXG4gKi9cbmV4cG9ydCB0eXBlIENvcmVTeXN0ZW1NZXNzYWdlID0ge1xuICByb2xlOiAnc3lzdGVtJztcbiAgY29udGVudDogc3RyaW5nO1xuXG4gIC8qKlxuQWRkaXRpb25hbCBwcm92aWRlci1zcGVjaWZpYyBtZXRhZGF0YS4gVGhleSBhcmUgcGFzc2VkIHRocm91Z2hcbnRvIHRoZSBwcm92aWRlciBmcm9tIHRoZSBBSSBTREsgYW5kIGVuYWJsZSBwcm92aWRlci1zcGVjaWZpY1xuZnVuY3Rpb25hbGl0eSB0aGF0IGNhbiBiZSBmdWxseSBlbmNhcHN1bGF0ZWQgaW4gdGhlIHByb3ZpZGVyLlxuICovXG4gIGV4cGVyaW1lbnRhbF9wcm92aWRlck1ldGFkYXRhPzogUHJvdmlkZXJNZXRhZGF0YTtcbn07XG5cbmV4cG9ydCBjb25zdCBjb3JlU3lzdGVtTWVzc2FnZVNjaGVtYTogei5ab2RUeXBlPENvcmVTeXN0ZW1NZXNzYWdlPiA9IHoub2JqZWN0KHtcbiAgcm9sZTogei5saXRlcmFsKCdzeXN0ZW0nKSxcbiAgY29udGVudDogei5zdHJpbmcoKSxcbiAgZXhwZXJpbWVudGFsX3Byb3ZpZGVyTWV0YWRhdGE6IHByb3ZpZGVyTWV0YWRhdGFTY2hlbWEub3B0aW9uYWwoKSxcbn0pO1xuXG4vKipcbiAqIEBkZXByZWNhdGVkIFVzZSBgQ29yZU1lc3NhZ2VgIGluc3RlYWQuXG4gKi9cbmV4cG9ydCB0eXBlIEV4cGVyaW1lbnRhbE1lc3NhZ2UgPSBDb3JlTWVzc2FnZTtcblxuLyoqXG5BIHVzZXIgbWVzc2FnZS4gSXQgY2FuIGNvbnRhaW4gdGV4dCBvciBhIGNvbWJpbmF0aW9uIG9mIHRleHQgYW5kIGltYWdlcy5cbiAqL1xuZXhwb3J0IHR5cGUgQ29yZVVzZXJNZXNzYWdlID0ge1xuICByb2xlOiAndXNlcic7XG4gIGNvbnRlbnQ6IFVzZXJDb250ZW50O1xuXG4gIC8qKlxuQWRkaXRpb25hbCBwcm92aWRlci1zcGVjaWZpYyBtZXRhZGF0YS4gVGhleSBhcmUgcGFzc2VkIHRocm91Z2hcbnRvIHRoZSBwcm92aWRlciBmcm9tIHRoZSBBSSBTREsgYW5kIGVuYWJsZSBwcm92aWRlci1zcGVjaWZpY1xuZnVuY3Rpb25hbGl0eSB0aGF0IGNhbiBiZSBmdWxseSBlbmNhcHN1bGF0ZWQgaW4gdGhlIHByb3ZpZGVyLlxuICovXG4gIGV4cGVyaW1lbnRhbF9wcm92aWRlck1ldGFkYXRhPzogUHJvdmlkZXJNZXRhZGF0YTtcbn07XG5cbmV4cG9ydCBjb25zdCBjb3JlVXNlck1lc3NhZ2VTY2hlbWE6IHouWm9kVHlwZTxDb3JlVXNlck1lc3NhZ2U+ID0gei5vYmplY3Qoe1xuICByb2xlOiB6LmxpdGVyYWwoJ3VzZXInKSxcbiAgY29udGVudDogei51bmlvbihbXG4gICAgei5zdHJpbmcoKSxcbiAgICB6LmFycmF5KHoudW5pb24oW3RleHRQYXJ0U2NoZW1hLCBpbWFnZVBhcnRTY2hlbWEsIGZpbGVQYXJ0U2NoZW1hXSkpLFxuICBdKSxcbiAgZXhwZXJpbWVudGFsX3Byb3ZpZGVyTWV0YWRhdGE6IHByb3ZpZGVyTWV0YWRhdGFTY2hlbWEub3B0aW9uYWwoKSxcbn0pO1xuXG4vKipcbiAqIEBkZXByZWNhdGVkIFVzZSBgQ29yZVVzZXJNZXNzYWdlYCBpbnN0ZWFkLlxuICovXG5leHBvcnQgdHlwZSBFeHBlcmltZW50YWxVc2VyTWVzc2FnZSA9IENvcmVVc2VyTWVzc2FnZTtcblxuLyoqXG5Db250ZW50IG9mIGEgdXNlciBtZXNzYWdlLiBJdCBjYW4gYmUgYSBzdHJpbmcgb3IgYW4gYXJyYXkgb2YgdGV4dCBhbmQgaW1hZ2UgcGFydHMuXG4gKi9cbmV4cG9ydCB0eXBlIFVzZXJDb250ZW50ID0gc3RyaW5nIHwgQXJyYXk8VGV4dFBhcnQgfCBJbWFnZVBhcnQgfCBGaWxlUGFydD47XG5cbi8qKlxuQW4gYXNzaXN0YW50IG1lc3NhZ2UuIEl0IGNhbiBjb250YWluIHRleHQsIHRvb2wgY2FsbHMsIG9yIGEgY29tYmluYXRpb24gb2YgdGV4dCBhbmQgdG9vbCBjYWxscy5cbiAqL1xuZXhwb3J0IHR5cGUgQ29yZUFzc2lzdGFudE1lc3NhZ2UgPSB7XG4gIHJvbGU6ICdhc3Npc3RhbnQnO1xuICBjb250ZW50OiBBc3Npc3RhbnRDb250ZW50O1xuXG4gIC8qKlxuQWRkaXRpb25hbCBwcm92aWRlci1zcGVjaWZpYyBtZXRhZGF0YS4gVGhleSBhcmUgcGFzc2VkIHRocm91Z2hcbnRvIHRoZSBwcm92aWRlciBmcm9tIHRoZSBBSSBTREsgYW5kIGVuYWJsZSBwcm92aWRlci1zcGVjaWZpY1xuZnVuY3Rpb25hbGl0eSB0aGF0IGNhbiBiZSBmdWxseSBlbmNhcHN1bGF0ZWQgaW4gdGhlIHByb3ZpZGVyLlxuICovXG4gIGV4cGVyaW1lbnRhbF9wcm92aWRlck1ldGFkYXRhPzogUHJvdmlkZXJNZXRhZGF0YTtcbn07XG5cbmV4cG9ydCBjb25zdCBjb3JlQXNzaXN0YW50TWVzc2FnZVNjaGVtYTogei5ab2RUeXBlPENvcmVBc3Npc3RhbnRNZXNzYWdlPiA9XG4gIHoub2JqZWN0KHtcbiAgICByb2xlOiB6LmxpdGVyYWwoJ2Fzc2lzdGFudCcpLFxuICAgIGNvbnRlbnQ6IHoudW5pb24oW1xuICAgICAgei5zdHJpbmcoKSxcbiAgICAgIHouYXJyYXkoei51bmlvbihbdGV4dFBhcnRTY2hlbWEsIHRvb2xDYWxsUGFydFNjaGVtYV0pKSxcbiAgICBdKSxcbiAgICBleHBlcmltZW50YWxfcHJvdmlkZXJNZXRhZGF0YTogcHJvdmlkZXJNZXRhZGF0YVNjaGVtYS5vcHRpb25hbCgpLFxuICB9KTtcblxuLyoqXG4gKiBAZGVwcmVjYXRlZCBVc2UgYENvcmVBc3Npc3RhbnRNZXNzYWdlYCBpbnN0ZWFkLlxuICovXG5leHBvcnQgdHlwZSBFeHBlcmltZW50YWxBc3Npc3RhbnRNZXNzYWdlID0gQ29yZUFzc2lzdGFudE1lc3NhZ2U7XG5cbi8qKlxuQ29udGVudCBvZiBhbiBhc3Npc3RhbnQgbWVzc2FnZS4gSXQgY2FuIGJlIGEgc3RyaW5nIG9yIGFuIGFycmF5IG9mIHRleHQgYW5kIHRvb2wgY2FsbCBwYXJ0cy5cbiAqL1xuZXhwb3J0IHR5cGUgQXNzaXN0YW50Q29udGVudCA9IHN0cmluZyB8IEFycmF5PFRleHRQYXJ0IHwgVG9vbENhbGxQYXJ0PjtcblxuLyoqXG5BIHRvb2wgbWVzc2FnZS4gSXQgY29udGFpbnMgdGhlIHJlc3VsdCBvZiBvbmUgb3IgbW9yZSB0b29sIGNhbGxzLlxuICovXG5leHBvcnQgdHlwZSBDb3JlVG9vbE1lc3NhZ2UgPSB7XG4gIHJvbGU6ICd0b29sJztcbiAgY29udGVudDogVG9vbENvbnRlbnQ7XG5cbiAgLyoqXG5BZGRpdGlvbmFsIHByb3ZpZGVyLXNwZWNpZmljIG1ldGFkYXRhLiBUaGV5IGFyZSBwYXNzZWQgdGhyb3VnaFxudG8gdGhlIHByb3ZpZGVyIGZyb20gdGhlIEFJIFNESyBhbmQgZW5hYmxlIHByb3ZpZGVyLXNwZWNpZmljXG5mdW5jdGlvbmFsaXR5IHRoYXQgY2FuIGJlIGZ1bGx5IGVuY2Fwc3VsYXRlZCBpbiB0aGUgcHJvdmlkZXIuXG4gKi9cbiAgZXhwZXJpbWVudGFsX3Byb3ZpZGVyTWV0YWRhdGE/OiBQcm92aWRlck1ldGFkYXRhO1xufTtcblxuZXhwb3J0IGNvbnN0IGNvcmVUb29sTWVzc2FnZVNjaGVtYTogei5ab2RUeXBlPENvcmVUb29sTWVzc2FnZT4gPSB6Lm9iamVjdCh7XG4gIHJvbGU6IHoubGl0ZXJhbCgndG9vbCcpLFxuICBjb250ZW50OiB6LmFycmF5KHRvb2xSZXN1bHRQYXJ0U2NoZW1hKSxcbiAgZXhwZXJpbWVudGFsX3Byb3ZpZGVyTWV0YWRhdGE6IHByb3ZpZGVyTWV0YWRhdGFTY2hlbWEub3B0aW9uYWwoKSxcbn0pO1xuXG4vKipcbiAqIEBkZXByZWNhdGVkIFVzZSBgQ29yZVRvb2xNZXNzYWdlYCBpbnN0ZWFkLlxuICovXG5leHBvcnQgdHlwZSBFeHBlcmltZW50YWxUb29sTWVzc2FnZSA9IENvcmVUb29sTWVzc2FnZTtcblxuLyoqXG5Db250ZW50IG9mIGEgdG9vbCBtZXNzYWdlLiBJdCBpcyBhbiBhcnJheSBvZiB0b29sIHJlc3VsdCBwYXJ0cy5cbiAqL1xuZXhwb3J0IHR5cGUgVG9vbENvbnRlbnQgPSBBcnJheTxUb29sUmVzdWx0UGFydD47XG5cbi8qKlxuQSBtZXNzYWdlIHRoYXQgY2FuIGJlIHVzZWQgaW4gdGhlIGBtZXNzYWdlc2AgZmllbGQgb2YgYSBwcm9tcHQuXG5JdCBjYW4gYmUgYSB1c2VyIG1lc3NhZ2UsIGFuIGFzc2lzdGFudCBtZXNzYWdlLCBvciBhIHRvb2wgbWVzc2FnZS5cbiAqL1xuZXhwb3J0IHR5cGUgQ29yZU1lc3NhZ2UgPVxuICB8IENvcmVTeXN0ZW1NZXNzYWdlXG4gIHwgQ29yZVVzZXJNZXNzYWdlXG4gIHwgQ29yZUFzc2lzdGFudE1lc3NhZ2VcbiAgfCBDb3JlVG9vbE1lc3NhZ2U7XG5cbmV4cG9ydCBjb25zdCBjb3JlTWVzc2FnZVNjaGVtYTogei5ab2RUeXBlPENvcmVNZXNzYWdlPiA9IHoudW5pb24oW1xuICBjb3JlU3lzdGVtTWVzc2FnZVNjaGVtYSxcbiAgY29yZVVzZXJNZXNzYWdlU2NoZW1hLFxuICBjb3JlQXNzaXN0YW50TWVzc2FnZVNjaGVtYSxcbiAgY29yZVRvb2xNZXNzYWdlU2NoZW1hLFxuXSk7XG4iLCJpbXBvcnQgeyBMYW5ndWFnZU1vZGVsVjFQcm92aWRlck1ldGFkYXRhIH0gZnJvbSAnQGFpLXNkay9wcm92aWRlcic7XG5pbXBvcnQgeyB6IH0gZnJvbSAnem9kJztcbmltcG9ydCB7IGpzb25WYWx1ZVNjaGVtYSB9IGZyb20gJy4vanNvbi12YWx1ZSc7XG5cbi8qKlxuQWRkaXRpb25hbCBwcm92aWRlci1zcGVjaWZpYyBtZXRhZGF0YS4gVGhleSBhcmUgcGFzc2VkIHRocm91Z2hcbnRvIHRoZSBwcm92aWRlciBmcm9tIHRoZSBBSSBTREsgYW5kIGVuYWJsZSBwcm92aWRlci1zcGVjaWZpY1xuZnVuY3Rpb25hbGl0eSB0aGF0IGNhbiBiZSBmdWxseSBlbmNhcHN1bGF0ZWQgaW4gdGhlIHByb3ZpZGVyLlxuICovXG5leHBvcnQgdHlwZSBQcm92aWRlck1ldGFkYXRhID0gTGFuZ3VhZ2VNb2RlbFYxUHJvdmlkZXJNZXRhZGF0YTtcblxuZXhwb3J0IGNvbnN0IHByb3ZpZGVyTWV0YWRhdGFTY2hlbWE6IHouWm9kVHlwZTxQcm92aWRlck1ldGFkYXRhPiA9IHoucmVjb3JkKFxuICB6LnN0cmluZygpLFxuICB6LnJlY29yZCh6LnN0cmluZygpLCBqc29uVmFsdWVTY2hlbWEpLFxuKTtcbiIsImltcG9ydCB7IEpTT05WYWx1ZSB9IGZyb20gJ0BhaS1zZGsvcHJvdmlkZXInO1xuaW1wb3J0IHsgeiB9IGZyb20gJ3pvZCc7XG5cbmV4cG9ydCBjb25zdCBqc29uVmFsdWVTY2hlbWE6IHouWm9kVHlwZTxKU09OVmFsdWU+ID0gei5sYXp5KCgpID0+XG4gIHoudW5pb24oW1xuICAgIHoubnVsbCgpLFxuICAgIHouc3RyaW5nKCksXG4gICAgei5udW1iZXIoKSxcbiAgICB6LmJvb2xlYW4oKSxcbiAgICB6LnJlY29yZCh6LnN0cmluZygpLCBqc29uVmFsdWVTY2hlbWEpLFxuICAgIHouYXJyYXkoanNvblZhbHVlU2NoZW1hKSxcbiAgXSksXG4pO1xuIiwiaW1wb3J0IHsgeiB9IGZyb20gJ3pvZCc7XG5pbXBvcnQge1xuICBQcm92aWRlck1ldGFkYXRhLFxuICBwcm92aWRlck1ldGFkYXRhU2NoZW1hLFxufSBmcm9tICcuLi90eXBlcy9wcm92aWRlci1tZXRhZGF0YSc7XG5pbXBvcnQgeyBEYXRhQ29udGVudCwgZGF0YUNvbnRlbnRTY2hlbWEgfSBmcm9tICcuL2RhdGEtY29udGVudCc7XG5pbXBvcnQge1xuICBUb29sUmVzdWx0Q29udGVudCxcbiAgdG9vbFJlc3VsdENvbnRlbnRTY2hlbWEsXG59IGZyb20gJy4vdG9vbC1yZXN1bHQtY29udGVudCc7XG5cbi8qKlxuVGV4dCBjb250ZW50IHBhcnQgb2YgYSBwcm9tcHQuIEl0IGNvbnRhaW5zIGEgc3RyaW5nIG9mIHRleHQuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgVGV4dFBhcnQge1xuICB0eXBlOiAndGV4dCc7XG5cbiAgLyoqXG5UaGUgdGV4dCBjb250ZW50LlxuICAgKi9cbiAgdGV4dDogc3RyaW5nO1xuXG4gIC8qKlxuQWRkaXRpb25hbCBwcm92aWRlci1zcGVjaWZpYyBtZXRhZGF0YS4gVGhleSBhcmUgcGFzc2VkIHRocm91Z2hcbnRvIHRoZSBwcm92aWRlciBmcm9tIHRoZSBBSSBTREsgYW5kIGVuYWJsZSBwcm92aWRlci1zcGVjaWZpY1xuZnVuY3Rpb25hbGl0eSB0aGF0IGNhbiBiZSBmdWxseSBlbmNhcHN1bGF0ZWQgaW4gdGhlIHByb3ZpZGVyLlxuICovXG4gIGV4cGVyaW1lbnRhbF9wcm92aWRlck1ldGFkYXRhPzogUHJvdmlkZXJNZXRhZGF0YTtcbn1cblxuZXhwb3J0IGNvbnN0IHRleHRQYXJ0U2NoZW1hOiB6LlpvZFR5cGU8VGV4dFBhcnQ+ID0gei5vYmplY3Qoe1xuICB0eXBlOiB6LmxpdGVyYWwoJ3RleHQnKSxcbiAgdGV4dDogei5zdHJpbmcoKSxcbiAgZXhwZXJpbWVudGFsX3Byb3ZpZGVyTWV0YWRhdGE6IHByb3ZpZGVyTWV0YWRhdGFTY2hlbWEub3B0aW9uYWwoKSxcbn0pO1xuXG4vKipcbkltYWdlIGNvbnRlbnQgcGFydCBvZiBhIHByb21wdC4gSXQgY29udGFpbnMgYW4gaW1hZ2UuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgSW1hZ2VQYXJ0IHtcbiAgdHlwZTogJ2ltYWdlJztcblxuICAvKipcbkltYWdlIGRhdGEuIENhbiBlaXRoZXIgYmU6XG5cbi0gZGF0YTogYSBiYXNlNjQtZW5jb2RlZCBzdHJpbmcsIGEgVWludDhBcnJheSwgYW4gQXJyYXlCdWZmZXIsIG9yIGEgQnVmZmVyXG4tIFVSTDogYSBVUkwgdGhhdCBwb2ludHMgdG8gdGhlIGltYWdlXG4gICAqL1xuICBpbWFnZTogRGF0YUNvbnRlbnQgfCBVUkw7XG5cbiAgLyoqXG5PcHRpb25hbCBtaW1lIHR5cGUgb2YgdGhlIGltYWdlLlxuICAgKi9cbiAgbWltZVR5cGU/OiBzdHJpbmc7XG5cbiAgLyoqXG5BZGRpdGlvbmFsIHByb3ZpZGVyLXNwZWNpZmljIG1ldGFkYXRhLiBUaGV5IGFyZSBwYXNzZWQgdGhyb3VnaFxudG8gdGhlIHByb3ZpZGVyIGZyb20gdGhlIEFJIFNESyBhbmQgZW5hYmxlIHByb3ZpZGVyLXNwZWNpZmljXG5mdW5jdGlvbmFsaXR5IHRoYXQgY2FuIGJlIGZ1bGx5IGVuY2Fwc3VsYXRlZCBpbiB0aGUgcHJvdmlkZXIuXG4gKi9cbiAgZXhwZXJpbWVudGFsX3Byb3ZpZGVyTWV0YWRhdGE/OiBQcm92aWRlck1ldGFkYXRhO1xufVxuXG5leHBvcnQgY29uc3QgaW1hZ2VQYXJ0U2NoZW1hOiB6LlpvZFR5cGU8SW1hZ2VQYXJ0PiA9IHoub2JqZWN0KHtcbiAgdHlwZTogei5saXRlcmFsKCdpbWFnZScpLFxuICBpbWFnZTogei51bmlvbihbZGF0YUNvbnRlbnRTY2hlbWEsIHouaW5zdGFuY2VvZihVUkwpXSksXG4gIG1pbWVUeXBlOiB6LnN0cmluZygpLm9wdGlvbmFsKCksXG4gIGV4cGVyaW1lbnRhbF9wcm92aWRlck1ldGFkYXRhOiBwcm92aWRlck1ldGFkYXRhU2NoZW1hLm9wdGlvbmFsKCksXG59KTtcblxuLyoqXG5GaWxlIGNvbnRlbnQgcGFydCBvZiBhIHByb21wdC4gSXQgY29udGFpbnMgYSBmaWxlLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIEZpbGVQYXJ0IHtcbiAgdHlwZTogJ2ZpbGUnO1xuXG4gIC8qKlxuRmlsZSBkYXRhLiBDYW4gZWl0aGVyIGJlOlxuXG4tIGRhdGE6IGEgYmFzZTY0LWVuY29kZWQgc3RyaW5nLCBhIFVpbnQ4QXJyYXksIGFuIEFycmF5QnVmZmVyLCBvciBhIEJ1ZmZlclxuLSBVUkw6IGEgVVJMIHRoYXQgcG9pbnRzIHRvIHRoZSBpbWFnZVxuICAgKi9cbiAgZGF0YTogRGF0YUNvbnRlbnQgfCBVUkw7XG5cbiAgLyoqXG5NaW1lIHR5cGUgb2YgdGhlIGZpbGUuXG4gICAqL1xuICBtaW1lVHlwZTogc3RyaW5nO1xuXG4gIC8qKlxuQWRkaXRpb25hbCBwcm92aWRlci1zcGVjaWZpYyBtZXRhZGF0YS4gVGhleSBhcmUgcGFzc2VkIHRocm91Z2hcbnRvIHRoZSBwcm92aWRlciBmcm9tIHRoZSBBSSBTREsgYW5kIGVuYWJsZSBwcm92aWRlci1zcGVjaWZpY1xuZnVuY3Rpb25hbGl0eSB0aGF0IGNhbiBiZSBmdWxseSBlbmNhcHN1bGF0ZWQgaW4gdGhlIHByb3ZpZGVyLlxuICovXG4gIGV4cGVyaW1lbnRhbF9wcm92aWRlck1ldGFkYXRhPzogUHJvdmlkZXJNZXRhZGF0YTtcbn1cblxuZXhwb3J0IGNvbnN0IGZpbGVQYXJ0U2NoZW1hOiB6LlpvZFR5cGU8RmlsZVBhcnQ+ID0gei5vYmplY3Qoe1xuICB0eXBlOiB6LmxpdGVyYWwoJ2ZpbGUnKSxcbiAgZGF0YTogei51bmlvbihbZGF0YUNvbnRlbnRTY2hlbWEsIHouaW5zdGFuY2VvZihVUkwpXSksXG4gIG1pbWVUeXBlOiB6LnN0cmluZygpLFxuICBleHBlcmltZW50YWxfcHJvdmlkZXJNZXRhZGF0YTogcHJvdmlkZXJNZXRhZGF0YVNjaGVtYS5vcHRpb25hbCgpLFxufSk7XG5cbi8qKlxuVG9vbCBjYWxsIGNvbnRlbnQgcGFydCBvZiBhIHByb21wdC4gSXQgY29udGFpbnMgYSB0b29sIGNhbGwgKHVzdWFsbHkgZ2VuZXJhdGVkIGJ5IHRoZSBBSSBtb2RlbCkuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgVG9vbENhbGxQYXJ0IHtcbiAgdHlwZTogJ3Rvb2wtY2FsbCc7XG5cbiAgLyoqXG5JRCBvZiB0aGUgdG9vbCBjYWxsLiBUaGlzIElEIGlzIHVzZWQgdG8gbWF0Y2ggdGhlIHRvb2wgY2FsbCB3aXRoIHRoZSB0b29sIHJlc3VsdC5cbiAqL1xuICB0b29sQ2FsbElkOiBzdHJpbmc7XG5cbiAgLyoqXG5OYW1lIG9mIHRoZSB0b29sIHRoYXQgaXMgYmVpbmcgY2FsbGVkLlxuICovXG4gIHRvb2xOYW1lOiBzdHJpbmc7XG5cbiAgLyoqXG5Bcmd1bWVudHMgb2YgdGhlIHRvb2wgY2FsbC4gVGhpcyBpcyBhIEpTT04tc2VyaWFsaXphYmxlIG9iamVjdCB0aGF0IG1hdGNoZXMgdGhlIHRvb2wncyBpbnB1dCBzY2hlbWEuXG4gICAqL1xuICBhcmdzOiB1bmtub3duO1xuXG4gIC8qKlxuQWRkaXRpb25hbCBwcm92aWRlci1zcGVjaWZpYyBtZXRhZGF0YS4gVGhleSBhcmUgcGFzc2VkIHRocm91Z2hcbnRvIHRoZSBwcm92aWRlciBmcm9tIHRoZSBBSSBTREsgYW5kIGVuYWJsZSBwcm92aWRlci1zcGVjaWZpY1xuZnVuY3Rpb25hbGl0eSB0aGF0IGNhbiBiZSBmdWxseSBlbmNhcHN1bGF0ZWQgaW4gdGhlIHByb3ZpZGVyLlxuICovXG4gIGV4cGVyaW1lbnRhbF9wcm92aWRlck1ldGFkYXRhPzogUHJvdmlkZXJNZXRhZGF0YTtcbn1cblxuZXhwb3J0IGNvbnN0IHRvb2xDYWxsUGFydFNjaGVtYTogei5ab2RUeXBlPFRvb2xDYWxsUGFydD4gPSB6Lm9iamVjdCh7XG4gIHR5cGU6IHoubGl0ZXJhbCgndG9vbC1jYWxsJyksXG4gIHRvb2xDYWxsSWQ6IHouc3RyaW5nKCksXG4gIHRvb2xOYW1lOiB6LnN0cmluZygpLFxuICBhcmdzOiB6LnVua25vd24oKSxcbn0pIGFzIHouWm9kVHlwZTxUb29sQ2FsbFBhcnQ+OyAvLyBuZWNlc3NhcnkgYmMgYXJncyBpcyBvcHRpb25hbCBvbiBab2QgdHlwZVxuXG4vKipcblRvb2wgcmVzdWx0IGNvbnRlbnQgcGFydCBvZiBhIHByb21wdC4gSXQgY29udGFpbnMgdGhlIHJlc3VsdCBvZiB0aGUgdG9vbCBjYWxsIHdpdGggdGhlIG1hdGNoaW5nIElELlxuICovXG5leHBvcnQgaW50ZXJmYWNlIFRvb2xSZXN1bHRQYXJ0IHtcbiAgdHlwZTogJ3Rvb2wtcmVzdWx0JztcblxuICAvKipcbklEIG9mIHRoZSB0b29sIGNhbGwgdGhhdCB0aGlzIHJlc3VsdCBpcyBhc3NvY2lhdGVkIHdpdGguXG4gKi9cbiAgdG9vbENhbGxJZDogc3RyaW5nO1xuXG4gIC8qKlxuTmFtZSBvZiB0aGUgdG9vbCB0aGF0IGdlbmVyYXRlZCB0aGlzIHJlc3VsdC5cbiAgKi9cbiAgdG9vbE5hbWU6IHN0cmluZztcblxuICAvKipcblJlc3VsdCBvZiB0aGUgdG9vbCBjYWxsLiBUaGlzIGlzIGEgSlNPTi1zZXJpYWxpemFibGUgb2JqZWN0LlxuICAgKi9cbiAgcmVzdWx0OiB1bmtub3duO1xuXG4gIC8qKlxuTXVsdGktcGFydCBjb250ZW50IG9mIHRoZSB0b29sIHJlc3VsdC4gT25seSBmb3IgdG9vbHMgdGhhdCBzdXBwb3J0IG11bHRpcGFydCByZXN1bHRzLlxuICAgKi9cbiAgZXhwZXJpbWVudGFsX2NvbnRlbnQ/OiBUb29sUmVzdWx0Q29udGVudDtcblxuICAvKipcbk9wdGlvbmFsIGZsYWcgaWYgdGhlIHJlc3VsdCBpcyBhbiBlcnJvciBvciBhbiBlcnJvciBtZXNzYWdlLlxuICAgKi9cbiAgaXNFcnJvcj86IGJvb2xlYW47XG5cbiAgLyoqXG5BZGRpdGlvbmFsIHByb3ZpZGVyLXNwZWNpZmljIG1ldGFkYXRhLiBUaGV5IGFyZSBwYXNzZWQgdGhyb3VnaFxudG8gdGhlIHByb3ZpZGVyIGZyb20gdGhlIEFJIFNESyBhbmQgZW5hYmxlIHByb3ZpZGVyLXNwZWNpZmljXG5mdW5jdGlvbmFsaXR5IHRoYXQgY2FuIGJlIGZ1bGx5IGVuY2Fwc3VsYXRlZCBpbiB0aGUgcHJvdmlkZXIuXG4gKi9cbiAgZXhwZXJpbWVudGFsX3Byb3ZpZGVyTWV0YWRhdGE/OiBQcm92aWRlck1ldGFkYXRhO1xufVxuXG5leHBvcnQgY29uc3QgdG9vbFJlc3VsdFBhcnRTY2hlbWE6IHouWm9kVHlwZTxUb29sUmVzdWx0UGFydD4gPSB6Lm9iamVjdCh7XG4gIHR5cGU6IHoubGl0ZXJhbCgndG9vbC1yZXN1bHQnKSxcbiAgdG9vbENhbGxJZDogei5zdHJpbmcoKSxcbiAgdG9vbE5hbWU6IHouc3RyaW5nKCksXG4gIHJlc3VsdDogei51bmtub3duKCksXG4gIGNvbnRlbnQ6IHRvb2xSZXN1bHRDb250ZW50U2NoZW1hLm9wdGlvbmFsKCksXG4gIGlzRXJyb3I6IHouYm9vbGVhbigpLm9wdGlvbmFsKCksXG4gIGV4cGVyaW1lbnRhbF9wcm92aWRlck1ldGFkYXRhOiBwcm92aWRlck1ldGFkYXRhU2NoZW1hLm9wdGlvbmFsKCksXG59KSBhcyB6LlpvZFR5cGU8VG9vbFJlc3VsdFBhcnQ+OyAvLyBuZWNlc3NhcnkgYmMgcmVzdWx0IGlzIG9wdGlvbmFsIG9uIFpvZCB0eXBlXG4iLCJpbXBvcnQgeyB6IH0gZnJvbSAnem9kJztcblxuZXhwb3J0IHR5cGUgVG9vbFJlc3VsdENvbnRlbnQgPSBBcnJheTxcbiAgfCB7XG4gICAgICB0eXBlOiAndGV4dCc7XG4gICAgICB0ZXh0OiBzdHJpbmc7XG4gICAgfVxuICB8IHtcbiAgICAgIHR5cGU6ICdpbWFnZSc7XG4gICAgICBkYXRhOiBzdHJpbmc7IC8vIGJhc2U2NCBlbmNvZGVkIHBuZyBpbWFnZSwgZS5nLiBzY3JlZW5zaG90XG4gICAgICBtaW1lVHlwZT86IHN0cmluZzsgLy8gZS5nLiAnaW1hZ2UvcG5nJztcbiAgICB9XG4+O1xuXG5leHBvcnQgY29uc3QgdG9vbFJlc3VsdENvbnRlbnRTY2hlbWE6IHouWm9kVHlwZTxUb29sUmVzdWx0Q29udGVudD4gPSB6LmFycmF5KFxuICB6LnVuaW9uKFtcbiAgICB6Lm9iamVjdCh7IHR5cGU6IHoubGl0ZXJhbCgndGV4dCcpLCB0ZXh0OiB6LnN0cmluZygpIH0pLFxuICAgIHoub2JqZWN0KHtcbiAgICAgIHR5cGU6IHoubGl0ZXJhbCgnaW1hZ2UnKSxcbiAgICAgIGRhdGE6IHouc3RyaW5nKCksXG4gICAgICBtaW1lVHlwZTogei5zdHJpbmcoKS5vcHRpb25hbCgpLFxuICAgIH0pLFxuICBdKSxcbik7XG5cbmV4cG9ydCBmdW5jdGlvbiBpc1Rvb2xSZXN1bHRDb250ZW50KFxuICB2YWx1ZTogdW5rbm93bixcbik6IHZhbHVlIGlzIFRvb2xSZXN1bHRDb250ZW50IHtcbiAgaWYgKCFBcnJheS5pc0FycmF5KHZhbHVlKSB8fCB2YWx1ZS5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gdmFsdWUuZXZlcnkocGFydCA9PiB7XG4gICAgaWYgKHR5cGVvZiBwYXJ0ICE9PSAnb2JqZWN0JyB8fCBwYXJ0ID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKHBhcnQudHlwZSA9PT0gJ3RleHQnKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIHBhcnQudGV4dCA9PT0gJ3N0cmluZyc7XG4gICAgfVxuXG4gICAgaWYgKHBhcnQudHlwZSA9PT0gJ2ltYWdlJykge1xuICAgICAgcmV0dXJuIChcbiAgICAgICAgdHlwZW9mIHBhcnQuZGF0YSA9PT0gJ3N0cmluZycgJiZcbiAgICAgICAgKHBhcnQubWltZVR5cGUgPT09IHVuZGVmaW5lZCB8fCB0eXBlb2YgcGFydC5taW1lVHlwZSA9PT0gJ3N0cmluZycpXG4gICAgICApO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfSk7XG59XG4iLCJleHBvcnQgZnVuY3Rpb24gZGV0ZWN0UHJvbXB0VHlwZShcbiAgcHJvbXB0OiBBcnJheTxhbnk+LFxuKTogJ3VpLW1lc3NhZ2VzJyB8ICdtZXNzYWdlcycgfCAnb3RoZXInIHtcbiAgaWYgKCFBcnJheS5pc0FycmF5KHByb21wdCkpIHtcbiAgICByZXR1cm4gJ290aGVyJztcbiAgfVxuXG4gIGlmIChwcm9tcHQubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuICdtZXNzYWdlcyc7XG4gIH1cblxuICBjb25zdCBjaGFyYWN0ZXJpc3RpY3MgPSBwcm9tcHQubWFwKGRldGVjdFNpbmdsZU1lc3NhZ2VDaGFyYWN0ZXJpc3RpY3MpO1xuXG4gIGlmIChjaGFyYWN0ZXJpc3RpY3Muc29tZShjID0+IGMgPT09ICdoYXMtdWktc3BlY2lmaWMtcGFydHMnKSkge1xuICAgIHJldHVybiAndWktbWVzc2FnZXMnO1xuICB9IGVsc2UgaWYgKFxuICAgIGNoYXJhY3RlcmlzdGljcy5ldmVyeShcbiAgICAgIGMgPT4gYyA9PT0gJ2hhcy1jb3JlLXNwZWNpZmljLXBhcnRzJyB8fCBjID09PSAnbWVzc2FnZScsXG4gICAgKVxuICApIHtcbiAgICByZXR1cm4gJ21lc3NhZ2VzJztcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gJ290aGVyJztcbiAgfVxufVxuXG5mdW5jdGlvbiBkZXRlY3RTaW5nbGVNZXNzYWdlQ2hhcmFjdGVyaXN0aWNzKFxuICBtZXNzYWdlOiBhbnksXG4pOiAnaGFzLXVpLXNwZWNpZmljLXBhcnRzJyB8ICdoYXMtY29yZS1zcGVjaWZpYy1wYXJ0cycgfCAnbWVzc2FnZScgfCAnb3RoZXInIHtcbiAgaWYgKFxuICAgIHR5cGVvZiBtZXNzYWdlID09PSAnb2JqZWN0JyAmJlxuICAgIG1lc3NhZ2UgIT09IG51bGwgJiZcbiAgICAobWVzc2FnZS5yb2xlID09PSAnZnVuY3Rpb24nIHx8IC8vIFVJLW9ubHkgcm9sZVxuICAgICAgbWVzc2FnZS5yb2xlID09PSAnZGF0YScgfHwgLy8gVUktb25seSByb2xlXG4gICAgICAndG9vbEludm9jYXRpb25zJyBpbiBtZXNzYWdlIHx8IC8vIFVJLXNwZWNpZmljIGZpZWxkXG4gICAgICAnZXhwZXJpbWVudGFsX2F0dGFjaG1lbnRzJyBpbiBtZXNzYWdlKVxuICApIHtcbiAgICByZXR1cm4gJ2hhcy11aS1zcGVjaWZpYy1wYXJ0cyc7XG4gIH0gZWxzZSBpZiAoXG4gICAgdHlwZW9mIG1lc3NhZ2UgPT09ICdvYmplY3QnICYmXG4gICAgbWVzc2FnZSAhPT0gbnVsbCAmJlxuICAgICdjb250ZW50JyBpbiBtZXNzYWdlICYmXG4gICAgKEFycmF5LmlzQXJyYXkobWVzc2FnZS5jb250ZW50KSB8fCAvLyBDb3JlIG1lc3NhZ2VzIGNhbiBoYXZlIGFycmF5IGNvbnRlbnRcbiAgICAgICdleHBlcmltZW50YWxfcHJvdmlkZXJNZXRhZGF0YScgaW4gbWVzc2FnZSlcbiAgKSB7XG4gICAgcmV0dXJuICdoYXMtY29yZS1zcGVjaWZpYy1wYXJ0cyc7XG4gIH0gZWxzZSBpZiAoXG4gICAgdHlwZW9mIG1lc3NhZ2UgPT09ICdvYmplY3QnICYmXG4gICAgbWVzc2FnZSAhPT0gbnVsbCAmJlxuICAgICdyb2xlJyBpbiBtZXNzYWdlICYmXG4gICAgJ2NvbnRlbnQnIGluIG1lc3NhZ2UgJiZcbiAgICB0eXBlb2YgbWVzc2FnZS5jb250ZW50ID09PSAnc3RyaW5nJyAmJlxuICAgIFsnc3lzdGVtJywgJ3VzZXInLCAnYXNzaXN0YW50JywgJ3Rvb2wnXS5pbmNsdWRlcyhtZXNzYWdlLnJvbGUpXG4gICkge1xuICAgIHJldHVybiAnbWVzc2FnZSc7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuICdvdGhlcic7XG4gIH1cbn1cbiIsImltcG9ydCB7IEF0dGFjaG1lbnQgfSBmcm9tICdAYWktc2RrL3VpLXV0aWxzJztcbmltcG9ydCB7IEZpbGVQYXJ0LCBJbWFnZVBhcnQsIFRleHRQYXJ0IH0gZnJvbSAnLi9jb250ZW50LXBhcnQnO1xuaW1wb3J0IHtcbiAgY29udmVydERhdGFDb250ZW50VG9VaW50OEFycmF5LFxuICBjb252ZXJ0VWludDhBcnJheVRvVGV4dCxcbn0gZnJvbSAnLi9kYXRhLWNvbnRlbnQnO1xuXG50eXBlIENvbnRlbnRQYXJ0ID0gVGV4dFBhcnQgfCBJbWFnZVBhcnQgfCBGaWxlUGFydDtcblxuLyoqXG4gKiBDb252ZXJ0cyBhIGxpc3Qgb2YgYXR0YWNobWVudHMgdG8gYSBsaXN0IG9mIGNvbnRlbnQgcGFydHNcbiAqIGZvciBjb25zdW1wdGlvbiBieSBgYWkvY29yZWAgZnVuY3Rpb25zLlxuICogQ3VycmVudGx5IG9ubHkgc3VwcG9ydHMgaW1hZ2VzIGFuZCB0ZXh0IGF0dGFjaG1lbnRzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gYXR0YWNobWVudHNUb1BhcnRzKGF0dGFjaG1lbnRzOiBBdHRhY2htZW50W10pOiBDb250ZW50UGFydFtdIHtcbiAgY29uc3QgcGFydHM6IENvbnRlbnRQYXJ0W10gPSBbXTtcblxuICBmb3IgKGNvbnN0IGF0dGFjaG1lbnQgb2YgYXR0YWNobWVudHMpIHtcbiAgICBsZXQgdXJsO1xuXG4gICAgdHJ5IHtcbiAgICAgIHVybCA9IG5ldyBVUkwoYXR0YWNobWVudC51cmwpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgVVJMOiAke2F0dGFjaG1lbnQudXJsfWApO1xuICAgIH1cblxuICAgIHN3aXRjaCAodXJsLnByb3RvY29sKSB7XG4gICAgICBjYXNlICdodHRwOic6XG4gICAgICBjYXNlICdodHRwczonOiB7XG4gICAgICAgIGlmIChhdHRhY2htZW50LmNvbnRlbnRUeXBlPy5zdGFydHNXaXRoKCdpbWFnZS8nKSkge1xuICAgICAgICAgIHBhcnRzLnB1c2goeyB0eXBlOiAnaW1hZ2UnLCBpbWFnZTogdXJsIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmICghYXR0YWNobWVudC5jb250ZW50VHlwZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgICAnSWYgdGhlIGF0dGFjaG1lbnQgaXMgbm90IGFuIGltYWdlLCBpdCBtdXN0IHNwZWNpZnkgYSBjb250ZW50IHR5cGUnLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBwYXJ0cy5wdXNoKHtcbiAgICAgICAgICAgIHR5cGU6ICdmaWxlJyxcbiAgICAgICAgICAgIGRhdGE6IHVybCxcbiAgICAgICAgICAgIG1pbWVUeXBlOiBhdHRhY2htZW50LmNvbnRlbnRUeXBlLFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBjYXNlICdkYXRhOic6IHtcbiAgICAgICAgbGV0IGhlYWRlcjtcbiAgICAgICAgbGV0IGJhc2U2NENvbnRlbnQ7XG4gICAgICAgIGxldCBtaW1lVHlwZTtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgIFtoZWFkZXIsIGJhc2U2NENvbnRlbnRdID0gYXR0YWNobWVudC51cmwuc3BsaXQoJywnKTtcbiAgICAgICAgICBtaW1lVHlwZSA9IGhlYWRlci5zcGxpdCgnOycpWzBdLnNwbGl0KCc6JylbMV07XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBFcnJvciBwcm9jZXNzaW5nIGRhdGEgVVJMOiAke2F0dGFjaG1lbnQudXJsfWApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG1pbWVUeXBlID09IG51bGwgfHwgYmFzZTY0Q29udGVudCA9PSBudWxsKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGRhdGEgVVJMIGZvcm1hdDogJHthdHRhY2htZW50LnVybH1gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChhdHRhY2htZW50LmNvbnRlbnRUeXBlPy5zdGFydHNXaXRoKCdpbWFnZS8nKSkge1xuICAgICAgICAgIHBhcnRzLnB1c2goe1xuICAgICAgICAgICAgdHlwZTogJ2ltYWdlJyxcbiAgICAgICAgICAgIGltYWdlOiBjb252ZXJ0RGF0YUNvbnRlbnRUb1VpbnQ4QXJyYXkoYmFzZTY0Q29udGVudCksXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSBpZiAoYXR0YWNobWVudC5jb250ZW50VHlwZT8uc3RhcnRzV2l0aCgndGV4dC8nKSkge1xuICAgICAgICAgIHBhcnRzLnB1c2goe1xuICAgICAgICAgICAgdHlwZTogJ3RleHQnLFxuICAgICAgICAgICAgdGV4dDogY29udmVydFVpbnQ4QXJyYXlUb1RleHQoXG4gICAgICAgICAgICAgIGNvbnZlcnREYXRhQ29udGVudFRvVWludDhBcnJheShiYXNlNjRDb250ZW50KSxcbiAgICAgICAgICAgICksXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKCFhdHRhY2htZW50LmNvbnRlbnRUeXBlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgICdJZiB0aGUgYXR0YWNobWVudCBpcyBub3QgYW4gaW1hZ2Ugb3IgdGV4dCwgaXQgbXVzdCBzcGVjaWZ5IGEgY29udGVudCB0eXBlJyxcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcGFydHMucHVzaCh7XG4gICAgICAgICAgICB0eXBlOiAnZmlsZScsXG4gICAgICAgICAgICBkYXRhOiBiYXNlNjRDb250ZW50LFxuICAgICAgICAgICAgbWltZVR5cGU6IGF0dGFjaG1lbnQuY29udGVudFR5cGUsXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgZGVmYXVsdDoge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIFVSTCBwcm90b2NvbDogJHt1cmwucHJvdG9jb2x9YCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHBhcnRzO1xufVxuIiwiaW1wb3J0IHsgQUlTREtFcnJvciB9IGZyb20gJ0BhaS1zZGsvcHJvdmlkZXInO1xuaW1wb3J0IHsgVUlNZXNzYWdlIH0gZnJvbSAnLi91aS1tZXNzYWdlJztcblxuY29uc3QgbmFtZSA9ICdBSV9NZXNzYWdlQ29udmVyc2lvbkVycm9yJztcbmNvbnN0IG1hcmtlciA9IGB2ZXJjZWwuYWkuZXJyb3IuJHtuYW1lfWA7XG5jb25zdCBzeW1ib2wgPSBTeW1ib2wuZm9yKG1hcmtlcik7XG5cbmV4cG9ydCBjbGFzcyBNZXNzYWdlQ29udmVyc2lvbkVycm9yIGV4dGVuZHMgQUlTREtFcnJvciB7XG4gIHByaXZhdGUgcmVhZG9ubHkgW3N5bWJvbF0gPSB0cnVlOyAvLyB1c2VkIGluIGlzSW5zdGFuY2VcblxuICByZWFkb25seSBvcmlnaW5hbE1lc3NhZ2U6IFVJTWVzc2FnZTtcblxuICBjb25zdHJ1Y3Rvcih7XG4gICAgb3JpZ2luYWxNZXNzYWdlLFxuICAgIG1lc3NhZ2UsXG4gIH06IHtcbiAgICBvcmlnaW5hbE1lc3NhZ2U6IFVJTWVzc2FnZTtcbiAgICBtZXNzYWdlOiBzdHJpbmc7XG4gIH0pIHtcbiAgICBzdXBlcih7IG5hbWUsIG1lc3NhZ2UgfSk7XG5cbiAgICB0aGlzLm9yaWdpbmFsTWVzc2FnZSA9IG9yaWdpbmFsTWVzc2FnZTtcbiAgfVxuXG4gIHN0YXRpYyBpc0luc3RhbmNlKGVycm9yOiB1bmtub3duKTogZXJyb3IgaXMgTWVzc2FnZUNvbnZlcnNpb25FcnJvciB7XG4gICAgcmV0dXJuIEFJU0RLRXJyb3IuaGFzTWFya2VyKGVycm9yLCBtYXJrZXIpO1xuICB9XG59XG4iLCJpbXBvcnQgeyBDb3JlTWVzc2FnZSwgVG9vbENhbGxQYXJ0LCBUb29sUmVzdWx0UGFydCB9IGZyb20gJy4uL3Byb21wdCc7XG5pbXBvcnQgeyBDb3JlVG9vbCB9IGZyb20gJy4uL3Rvb2wvdG9vbCc7XG5pbXBvcnQgeyBhdHRhY2htZW50c1RvUGFydHMgfSBmcm9tICcuL2F0dGFjaG1lbnRzLXRvLXBhcnRzJztcbmltcG9ydCB7IE1lc3NhZ2VDb252ZXJzaW9uRXJyb3IgfSBmcm9tICcuL21lc3NhZ2UtY29udmVyc2lvbi1lcnJvcic7XG5pbXBvcnQgeyBVSU1lc3NhZ2UgfSBmcm9tICcuL3VpLW1lc3NhZ2UnO1xuXG4vKipcbkNvbnZlcnRzIGFuIGFycmF5IG9mIG1lc3NhZ2VzIGZyb20gdXNlQ2hhdCBpbnRvIGFuIGFycmF5IG9mIENvcmVNZXNzYWdlcyB0aGF0IGNhbiBiZSB1c2VkXG53aXRoIHRoZSBBSSBjb3JlIGZ1bmN0aW9ucyAoZS5nLiBgc3RyZWFtVGV4dGApLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY29udmVydFRvQ29yZU1lc3NhZ2VzPFxuICBUT09MUyBleHRlbmRzIFJlY29yZDxzdHJpbmcsIENvcmVUb29sPiA9IG5ldmVyLFxuPihtZXNzYWdlczogQXJyYXk8VUlNZXNzYWdlPiwgb3B0aW9ucz86IHsgdG9vbHM/OiBUT09MUyB9KSB7XG4gIGNvbnN0IHRvb2xzID0gb3B0aW9ucz8udG9vbHMgPz8gKHt9IGFzIFRPT0xTKTtcbiAgY29uc3QgY29yZU1lc3NhZ2VzOiBDb3JlTWVzc2FnZVtdID0gW107XG5cbiAgZm9yIChjb25zdCBtZXNzYWdlIG9mIG1lc3NhZ2VzKSB7XG4gICAgY29uc3QgeyByb2xlLCBjb250ZW50LCB0b29sSW52b2NhdGlvbnMsIGV4cGVyaW1lbnRhbF9hdHRhY2htZW50cyB9ID1cbiAgICAgIG1lc3NhZ2U7XG5cbiAgICBzd2l0Y2ggKHJvbGUpIHtcbiAgICAgIGNhc2UgJ3N5c3RlbSc6IHtcbiAgICAgICAgY29yZU1lc3NhZ2VzLnB1c2goe1xuICAgICAgICAgIHJvbGU6ICdzeXN0ZW0nLFxuICAgICAgICAgIGNvbnRlbnQsXG4gICAgICAgIH0pO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgY2FzZSAndXNlcic6IHtcbiAgICAgICAgY29yZU1lc3NhZ2VzLnB1c2goe1xuICAgICAgICAgIHJvbGU6ICd1c2VyJyxcbiAgICAgICAgICBjb250ZW50OiBleHBlcmltZW50YWxfYXR0YWNobWVudHNcbiAgICAgICAgICAgID8gW1xuICAgICAgICAgICAgICAgIHsgdHlwZTogJ3RleHQnLCB0ZXh0OiBjb250ZW50IH0sXG4gICAgICAgICAgICAgICAgLi4uYXR0YWNobWVudHNUb1BhcnRzKGV4cGVyaW1lbnRhbF9hdHRhY2htZW50cyksXG4gICAgICAgICAgICAgIF1cbiAgICAgICAgICAgIDogY29udGVudCxcbiAgICAgICAgfSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBjYXNlICdhc3Npc3RhbnQnOiB7XG4gICAgICAgIGlmICh0b29sSW52b2NhdGlvbnMgPT0gbnVsbCkge1xuICAgICAgICAgIGNvcmVNZXNzYWdlcy5wdXNoKHsgcm9sZTogJ2Fzc2lzdGFudCcsIGNvbnRlbnQgfSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBhc3Npc3RhbnQgbWVzc2FnZSB3aXRoIHRvb2wgY2FsbHNcbiAgICAgICAgY29yZU1lc3NhZ2VzLnB1c2goe1xuICAgICAgICAgIHJvbGU6ICdhc3Npc3RhbnQnLFxuICAgICAgICAgIGNvbnRlbnQ6IFtcbiAgICAgICAgICAgIHsgdHlwZTogJ3RleHQnLCB0ZXh0OiBjb250ZW50IH0sXG4gICAgICAgICAgICAuLi50b29sSW52b2NhdGlvbnMubWFwKFxuICAgICAgICAgICAgICAoeyB0b29sQ2FsbElkLCB0b29sTmFtZSwgYXJncyB9KTogVG9vbENhbGxQYXJ0ID0+ICh7XG4gICAgICAgICAgICAgICAgdHlwZTogJ3Rvb2wtY2FsbCcgYXMgY29uc3QsXG4gICAgICAgICAgICAgICAgdG9vbENhbGxJZCxcbiAgICAgICAgICAgICAgICB0b29sTmFtZSxcbiAgICAgICAgICAgICAgICBhcmdzLFxuICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICksXG4gICAgICAgICAgXSxcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gdG9vbCBtZXNzYWdlIHdpdGggdG9vbCByZXN1bHRzXG4gICAgICAgIGNvcmVNZXNzYWdlcy5wdXNoKHtcbiAgICAgICAgICByb2xlOiAndG9vbCcsXG4gICAgICAgICAgY29udGVudDogdG9vbEludm9jYXRpb25zLm1hcCgodG9vbEludm9jYXRpb24pOiBUb29sUmVzdWx0UGFydCA9PiB7XG4gICAgICAgICAgICBpZiAoISgncmVzdWx0JyBpbiB0b29sSW52b2NhdGlvbikpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IE1lc3NhZ2VDb252ZXJzaW9uRXJyb3Ioe1xuICAgICAgICAgICAgICAgIG9yaWdpbmFsTWVzc2FnZTogbWVzc2FnZSxcbiAgICAgICAgICAgICAgICBtZXNzYWdlOlxuICAgICAgICAgICAgICAgICAgJ1Rvb2xJbnZvY2F0aW9uIG11c3QgaGF2ZSBhIHJlc3VsdDogJyArXG4gICAgICAgICAgICAgICAgICBKU09OLnN0cmluZ2lmeSh0b29sSW52b2NhdGlvbiksXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCB7IHRvb2xDYWxsSWQsIHRvb2xOYW1lLCByZXN1bHQgfSA9IHRvb2xJbnZvY2F0aW9uO1xuXG4gICAgICAgICAgICBjb25zdCB0b29sID0gdG9vbHNbdG9vbE5hbWVdO1xuICAgICAgICAgICAgcmV0dXJuIHRvb2w/LmV4cGVyaW1lbnRhbF90b1Rvb2xSZXN1bHRDb250ZW50ICE9IG51bGxcbiAgICAgICAgICAgICAgPyB7XG4gICAgICAgICAgICAgICAgICB0eXBlOiAndG9vbC1yZXN1bHQnLFxuICAgICAgICAgICAgICAgICAgdG9vbENhbGxJZCxcbiAgICAgICAgICAgICAgICAgIHRvb2xOYW1lLFxuICAgICAgICAgICAgICAgICAgcmVzdWx0OiB0b29sLmV4cGVyaW1lbnRhbF90b1Rvb2xSZXN1bHRDb250ZW50KHJlc3VsdCksXG4gICAgICAgICAgICAgICAgICBleHBlcmltZW50YWxfY29udGVudDpcbiAgICAgICAgICAgICAgICAgICAgdG9vbC5leHBlcmltZW50YWxfdG9Ub29sUmVzdWx0Q29udGVudChyZXN1bHQpLFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgOiB7XG4gICAgICAgICAgICAgICAgICB0eXBlOiAndG9vbC1yZXN1bHQnLFxuICAgICAgICAgICAgICAgICAgdG9vbENhbGxJZCxcbiAgICAgICAgICAgICAgICAgIHRvb2xOYW1lLFxuICAgICAgICAgICAgICAgICAgcmVzdWx0LFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgfSksXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBjYXNlICdmdW5jdGlvbic6XG4gICAgICBjYXNlICdkYXRhJzpcbiAgICAgIGNhc2UgJ3Rvb2wnOiB7XG4gICAgICAgIC8vIGlnbm9yZVxuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgZGVmYXVsdDoge1xuICAgICAgICBjb25zdCBfZXhoYXVzdGl2ZUNoZWNrOiBuZXZlciA9IHJvbGU7XG4gICAgICAgIHRocm93IG5ldyBNZXNzYWdlQ29udmVyc2lvbkVycm9yKHtcbiAgICAgICAgICBvcmlnaW5hbE1lc3NhZ2U6IG1lc3NhZ2UsXG4gICAgICAgICAgbWVzc2FnZTogYFVuc3VwcG9ydGVkIHJvbGU6ICR7X2V4aGF1c3RpdmVDaGVja31gLFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gY29yZU1lc3NhZ2VzO1xufVxuIiwiLyoqXG5SZXByZXNlbnRzIHRoZSBudW1iZXIgb2YgdG9rZW5zIHVzZWQgaW4gYSBwcm9tcHQgYW5kIGNvbXBsZXRpb24uXG4gKi9cbmV4cG9ydCB0eXBlIExhbmd1YWdlTW9kZWxVc2FnZSA9IHtcbiAgLyoqXG5UaGUgbnVtYmVyIG9mIHRva2VucyB1c2VkIGluIHRoZSBwcm9tcHQuXG4gICAqL1xuICBwcm9tcHRUb2tlbnM6IG51bWJlcjtcblxuICAvKipcblRoZSBudW1iZXIgb2YgdG9rZW5zIHVzZWQgaW4gdGhlIGNvbXBsZXRpb24uXG4gKi9cbiAgY29tcGxldGlvblRva2VuczogbnVtYmVyO1xuXG4gIC8qKlxuVGhlIHRvdGFsIG51bWJlciBvZiB0b2tlbnMgdXNlZCAocHJvbXB0VG9rZW5zICsgY29tcGxldGlvblRva2VucykuXG4gICAqL1xuICB0b3RhbFRva2VuczogbnVtYmVyO1xufTtcblxuLyoqXG5SZXByZXNlbnRzIHRoZSBudW1iZXIgb2YgdG9rZW5zIHVzZWQgaW4gYSBwcm9tcHQgYW5kIGNvbXBsZXRpb24uXG5cbkBkZXByZWNhdGVkIFVzZSBgTGFuZ3VhZ2VNb2RlbFVzYWdlYCBpbnN0ZWFkLlxuICovXG5leHBvcnQgdHlwZSBDb21wbGV0aW9uVG9rZW5Vc2FnZSA9IExhbmd1YWdlTW9kZWxVc2FnZTtcblxuLyoqXG5SZXByZXNlbnRzIHRoZSBudW1iZXIgb2YgdG9rZW5zIHVzZWQgaW4gYW4gZW1iZWRkaW5nLlxuICovXG5leHBvcnQgdHlwZSBFbWJlZGRpbmdNb2RlbFVzYWdlID0ge1xuICAvKipcblRoZSBudW1iZXIgb2YgdG9rZW5zIHVzZWQgaW4gdGhlIGVtYmVkZGluZy5cbiAgICovXG4gIHRva2VuczogbnVtYmVyO1xufTtcblxuLyoqXG5SZXByZXNlbnRzIHRoZSBudW1iZXIgb2YgdG9rZW5zIHVzZWQgaW4gYW4gZW1iZWRkaW5nLlxuXG5AZGVwcmVjYXRlZCBVc2UgYEVtYmVkZGluZ01vZGVsVXNhZ2VgIGluc3RlYWQuXG4gKi9cbmV4cG9ydCB0eXBlIEVtYmVkZGluZ1Rva2VuVXNhZ2UgPSBFbWJlZGRpbmdNb2RlbFVzYWdlO1xuXG5leHBvcnQgZnVuY3Rpb24gY2FsY3VsYXRlTGFuZ3VhZ2VNb2RlbFVzYWdlKHVzYWdlOiB7XG4gIHByb21wdFRva2VuczogbnVtYmVyO1xuICBjb21wbGV0aW9uVG9rZW5zOiBudW1iZXI7XG59KTogTGFuZ3VhZ2VNb2RlbFVzYWdlIHtcbiAgcmV0dXJuIHtcbiAgICBwcm9tcHRUb2tlbnM6IHVzYWdlLnByb21wdFRva2VucyxcbiAgICBjb21wbGV0aW9uVG9rZW5zOiB1c2FnZS5jb21wbGV0aW9uVG9rZW5zLFxuICAgIHRvdGFsVG9rZW5zOiB1c2FnZS5wcm9tcHRUb2tlbnMgKyB1c2FnZS5jb21wbGV0aW9uVG9rZW5zLFxuICB9O1xufVxuIiwiaW1wb3J0IHsgQUlTREtFcnJvciwgZ2V0RXJyb3JNZXNzYWdlIH0gZnJvbSAnQGFpLXNkay9wcm92aWRlcic7XG5cbmNvbnN0IG5hbWUgPSAnQUlfSW52YWxpZFRvb2xBcmd1bWVudHNFcnJvcic7XG5jb25zdCBtYXJrZXIgPSBgdmVyY2VsLmFpLmVycm9yLiR7bmFtZX1gO1xuY29uc3Qgc3ltYm9sID0gU3ltYm9sLmZvcihtYXJrZXIpO1xuXG5leHBvcnQgY2xhc3MgSW52YWxpZFRvb2xBcmd1bWVudHNFcnJvciBleHRlbmRzIEFJU0RLRXJyb3Ige1xuICBwcml2YXRlIHJlYWRvbmx5IFtzeW1ib2xdID0gdHJ1ZTsgLy8gdXNlZCBpbiBpc0luc3RhbmNlXG5cbiAgcmVhZG9ubHkgdG9vbE5hbWU6IHN0cmluZztcbiAgcmVhZG9ubHkgdG9vbEFyZ3M6IHN0cmluZztcblxuICBjb25zdHJ1Y3Rvcih7XG4gICAgdG9vbEFyZ3MsXG4gICAgdG9vbE5hbWUsXG4gICAgY2F1c2UsXG4gICAgbWVzc2FnZSA9IGBJbnZhbGlkIGFyZ3VtZW50cyBmb3IgdG9vbCAke3Rvb2xOYW1lfTogJHtnZXRFcnJvck1lc3NhZ2UoXG4gICAgICBjYXVzZSxcbiAgICApfWAsXG4gIH06IHtcbiAgICBtZXNzYWdlPzogc3RyaW5nO1xuICAgIHRvb2xBcmdzOiBzdHJpbmc7XG4gICAgdG9vbE5hbWU6IHN0cmluZztcbiAgICBjYXVzZTogdW5rbm93bjtcbiAgfSkge1xuICAgIHN1cGVyKHsgbmFtZSwgbWVzc2FnZSwgY2F1c2UgfSk7XG5cbiAgICB0aGlzLnRvb2xBcmdzID0gdG9vbEFyZ3M7XG4gICAgdGhpcy50b29sTmFtZSA9IHRvb2xOYW1lO1xuICB9XG5cbiAgc3RhdGljIGlzSW5zdGFuY2UoZXJyb3I6IHVua25vd24pOiBlcnJvciBpcyBJbnZhbGlkVG9vbEFyZ3VtZW50c0Vycm9yIHtcbiAgICByZXR1cm4gQUlTREtFcnJvci5oYXNNYXJrZXIoZXJyb3IsIG1hcmtlcik7XG4gIH1cblxuICAvKipcbiAgICogQGRlcHJlY2F0ZWQgdXNlIGBpc0luc3RhbmNlYCBpbnN0ZWFkXG4gICAqL1xuICBzdGF0aWMgaXNJbnZhbGlkVG9vbEFyZ3VtZW50c0Vycm9yKFxuICAgIGVycm9yOiB1bmtub3duLFxuICApOiBlcnJvciBpcyBJbnZhbGlkVG9vbEFyZ3VtZW50c0Vycm9yIHtcbiAgICByZXR1cm4gKFxuICAgICAgZXJyb3IgaW5zdGFuY2VvZiBFcnJvciAmJlxuICAgICAgZXJyb3IubmFtZSA9PT0gbmFtZSAmJlxuICAgICAgdHlwZW9mIChlcnJvciBhcyBJbnZhbGlkVG9vbEFyZ3VtZW50c0Vycm9yKS50b29sTmFtZSA9PT0gJ3N0cmluZycgJiZcbiAgICAgIHR5cGVvZiAoZXJyb3IgYXMgSW52YWxpZFRvb2xBcmd1bWVudHNFcnJvcikudG9vbEFyZ3MgPT09ICdzdHJpbmcnXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAZGVwcmVjYXRlZCBEbyBub3QgdXNlIHRoaXMgbWV0aG9kLiBJdCB3aWxsIGJlIHJlbW92ZWQgaW4gdGhlIG5leHQgbWFqb3IgdmVyc2lvbi5cbiAgICovXG4gIHRvSlNPTigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbmFtZTogdGhpcy5uYW1lLFxuICAgICAgbWVzc2FnZTogdGhpcy5tZXNzYWdlLFxuICAgICAgY2F1c2U6IHRoaXMuY2F1c2UsXG4gICAgICBzdGFjazogdGhpcy5zdGFjayxcblxuICAgICAgdG9vbE5hbWU6IHRoaXMudG9vbE5hbWUsXG4gICAgICB0b29sQXJnczogdGhpcy50b29sQXJncyxcbiAgICB9O1xuICB9XG59XG4iLCJpbXBvcnQgeyBBSVNES0Vycm9yIH0gZnJvbSAnQGFpLXNkay9wcm92aWRlcic7XG5cbmNvbnN0IG5hbWUgPSAnQUlfTm9TdWNoVG9vbEVycm9yJztcbmNvbnN0IG1hcmtlciA9IGB2ZXJjZWwuYWkuZXJyb3IuJHtuYW1lfWA7XG5jb25zdCBzeW1ib2wgPSBTeW1ib2wuZm9yKG1hcmtlcik7XG5cbmV4cG9ydCBjbGFzcyBOb1N1Y2hUb29sRXJyb3IgZXh0ZW5kcyBBSVNES0Vycm9yIHtcbiAgcHJpdmF0ZSByZWFkb25seSBbc3ltYm9sXSA9IHRydWU7IC8vIHVzZWQgaW4gaXNJbnN0YW5jZVxuXG4gIHJlYWRvbmx5IHRvb2xOYW1lOiBzdHJpbmc7XG4gIHJlYWRvbmx5IGF2YWlsYWJsZVRvb2xzOiBzdHJpbmdbXSB8IHVuZGVmaW5lZDtcblxuICBjb25zdHJ1Y3Rvcih7XG4gICAgdG9vbE5hbWUsXG4gICAgYXZhaWxhYmxlVG9vbHMgPSB1bmRlZmluZWQsXG4gICAgbWVzc2FnZSA9IGBNb2RlbCB0cmllZCB0byBjYWxsIHVuYXZhaWxhYmxlIHRvb2wgJyR7dG9vbE5hbWV9Jy4gJHtcbiAgICAgIGF2YWlsYWJsZVRvb2xzID09PSB1bmRlZmluZWRcbiAgICAgICAgPyAnTm8gdG9vbHMgYXJlIGF2YWlsYWJsZS4nXG4gICAgICAgIDogYEF2YWlsYWJsZSB0b29sczogJHthdmFpbGFibGVUb29scy5qb2luKCcsICcpfS5gXG4gICAgfWAsXG4gIH06IHtcbiAgICB0b29sTmFtZTogc3RyaW5nO1xuICAgIGF2YWlsYWJsZVRvb2xzPzogc3RyaW5nW10gfCB1bmRlZmluZWQ7XG4gICAgbWVzc2FnZT86IHN0cmluZztcbiAgfSkge1xuICAgIHN1cGVyKHsgbmFtZSwgbWVzc2FnZSB9KTtcblxuICAgIHRoaXMudG9vbE5hbWUgPSB0b29sTmFtZTtcbiAgICB0aGlzLmF2YWlsYWJsZVRvb2xzID0gYXZhaWxhYmxlVG9vbHM7XG4gIH1cblxuICBzdGF0aWMgaXNJbnN0YW5jZShlcnJvcjogdW5rbm93bik6IGVycm9yIGlzIE5vU3VjaFRvb2xFcnJvciB7XG4gICAgcmV0dXJuIEFJU0RLRXJyb3IuaGFzTWFya2VyKGVycm9yLCBtYXJrZXIpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkIHVzZSBgaXNJbnN0YW5jZWAgaW5zdGVhZFxuICAgKi9cbiAgc3RhdGljIGlzTm9TdWNoVG9vbEVycm9yKGVycm9yOiB1bmtub3duKTogZXJyb3IgaXMgTm9TdWNoVG9vbEVycm9yIHtcbiAgICByZXR1cm4gKFxuICAgICAgZXJyb3IgaW5zdGFuY2VvZiBFcnJvciAmJlxuICAgICAgZXJyb3IubmFtZSA9PT0gbmFtZSAmJlxuICAgICAgJ3Rvb2xOYW1lJyBpbiBlcnJvciAmJlxuICAgICAgZXJyb3IudG9vbE5hbWUgIT0gdW5kZWZpbmVkICYmXG4gICAgICB0eXBlb2YgZXJyb3IubmFtZSA9PT0gJ3N0cmluZydcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkIERvIG5vdCB1c2UgdGhpcyBtZXRob2QuIEl0IHdpbGwgYmUgcmVtb3ZlZCBpbiB0aGUgbmV4dCBtYWpvciB2ZXJzaW9uLlxuICAgKi9cbiAgdG9KU09OKCkge1xuICAgIHJldHVybiB7XG4gICAgICBuYW1lOiB0aGlzLm5hbWUsXG4gICAgICBtZXNzYWdlOiB0aGlzLm1lc3NhZ2UsXG4gICAgICBzdGFjazogdGhpcy5zdGFjayxcblxuICAgICAgdG9vbE5hbWU6IHRoaXMudG9vbE5hbWUsXG4gICAgICBhdmFpbGFibGVUb29sczogdGhpcy5hdmFpbGFibGVUb29scyxcbiAgICB9O1xuICB9XG59XG4iLCJleHBvcnQgZnVuY3Rpb24gaXNBc3luY0dlbmVyYXRvcjxULCBUUmV0dXJuLCBUTmV4dD4oXG4gIHZhbHVlOiB1bmtub3duLFxuKTogdmFsdWUgaXMgQXN5bmNHZW5lcmF0b3I8VCwgVFJldHVybiwgVE5leHQ+IHtcbiAgcmV0dXJuIChcbiAgICB2YWx1ZSAhPSBudWxsICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgU3ltYm9sLmFzeW5jSXRlcmF0b3IgaW4gdmFsdWVcbiAgKTtcbn1cbiIsImV4cG9ydCBmdW5jdGlvbiBpc0dlbmVyYXRvcjxULCBUUmV0dXJuLCBUTmV4dD4oXG4gIHZhbHVlOiB1bmtub3duLFxuKTogdmFsdWUgaXMgR2VuZXJhdG9yPFQsIFRSZXR1cm4sIFROZXh0PiB7XG4gIHJldHVybiB2YWx1ZSAhPSBudWxsICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgU3ltYm9sLml0ZXJhdG9yIGluIHZhbHVlO1xufVxuIiwiaW1wb3J0IHsgQVBJQ2FsbEVycm9yIH0gZnJvbSAnQGFpLXNkay9wcm92aWRlcic7XG5pbXBvcnQgeyBnZXRFcnJvck1lc3NhZ2UsIGlzQWJvcnRFcnJvciB9IGZyb20gJ0BhaS1zZGsvcHJvdmlkZXItdXRpbHMnO1xuaW1wb3J0IHsgZGVsYXkgfSBmcm9tICcuL2RlbGF5JztcbmltcG9ydCB7IFJldHJ5RXJyb3IgfSBmcm9tICcuL3JldHJ5LWVycm9yJztcblxuZXhwb3J0IHR5cGUgUmV0cnlGdW5jdGlvbiA9IDxPVVRQVVQ+KFxuICBmbjogKCkgPT4gUHJvbWlzZUxpa2U8T1VUUFVUPixcbikgPT4gUHJvbWlzZUxpa2U8T1VUUFVUPjtcblxuLyoqXG5UaGUgYHJldHJ5V2l0aEV4cG9uZW50aWFsQmFja29mZmAgc3RyYXRlZ3kgcmV0cmllcyBhIGZhaWxlZCBBUEkgY2FsbCB3aXRoIGFuIGV4cG9uZW50aWFsIGJhY2tvZmYuXG5Zb3UgY2FuIGNvbmZpZ3VyZSB0aGUgbWF4aW11bSBudW1iZXIgb2YgcmV0cmllcywgdGhlIGluaXRpYWwgZGVsYXksIGFuZCB0aGUgYmFja29mZiBmYWN0b3IuXG4gKi9cbmV4cG9ydCBjb25zdCByZXRyeVdpdGhFeHBvbmVudGlhbEJhY2tvZmYgPVxuICAoe1xuICAgIG1heFJldHJpZXMgPSAyLFxuICAgIGluaXRpYWxEZWxheUluTXMgPSAyMDAwLFxuICAgIGJhY2tvZmZGYWN0b3IgPSAyLFxuICB9ID0ge30pOiBSZXRyeUZ1bmN0aW9uID0+XG4gIGFzeW5jIDxPVVRQVVQ+KGY6ICgpID0+IFByb21pc2VMaWtlPE9VVFBVVD4pID0+XG4gICAgX3JldHJ5V2l0aEV4cG9uZW50aWFsQmFja29mZihmLCB7XG4gICAgICBtYXhSZXRyaWVzLFxuICAgICAgZGVsYXlJbk1zOiBpbml0aWFsRGVsYXlJbk1zLFxuICAgICAgYmFja29mZkZhY3RvcixcbiAgICB9KTtcblxuYXN5bmMgZnVuY3Rpb24gX3JldHJ5V2l0aEV4cG9uZW50aWFsQmFja29mZjxPVVRQVVQ+KFxuICBmOiAoKSA9PiBQcm9taXNlTGlrZTxPVVRQVVQ+LFxuICB7XG4gICAgbWF4UmV0cmllcyxcbiAgICBkZWxheUluTXMsXG4gICAgYmFja29mZkZhY3RvcixcbiAgfTogeyBtYXhSZXRyaWVzOiBudW1iZXI7IGRlbGF5SW5NczogbnVtYmVyOyBiYWNrb2ZmRmFjdG9yOiBudW1iZXIgfSxcbiAgZXJyb3JzOiB1bmtub3duW10gPSBbXSxcbik6IFByb21pc2U8T1VUUFVUPiB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGF3YWl0IGYoKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBpZiAoaXNBYm9ydEVycm9yKGVycm9yKSkge1xuICAgICAgdGhyb3cgZXJyb3I7IC8vIGRvbid0IHJldHJ5IHdoZW4gdGhlIHJlcXVlc3Qgd2FzIGFib3J0ZWRcbiAgICB9XG5cbiAgICBpZiAobWF4UmV0cmllcyA9PT0gMCkge1xuICAgICAgdGhyb3cgZXJyb3I7IC8vIGRvbid0IHdyYXAgdGhlIGVycm9yIHdoZW4gcmV0cmllcyBhcmUgZGlzYWJsZWRcbiAgICB9XG5cbiAgICBjb25zdCBlcnJvck1lc3NhZ2UgPSBnZXRFcnJvck1lc3NhZ2UoZXJyb3IpO1xuICAgIGNvbnN0IG5ld0Vycm9ycyA9IFsuLi5lcnJvcnMsIGVycm9yXTtcbiAgICBjb25zdCB0cnlOdW1iZXIgPSBuZXdFcnJvcnMubGVuZ3RoO1xuXG4gICAgaWYgKHRyeU51bWJlciA+IG1heFJldHJpZXMpIHtcbiAgICAgIHRocm93IG5ldyBSZXRyeUVycm9yKHtcbiAgICAgICAgbWVzc2FnZTogYEZhaWxlZCBhZnRlciAke3RyeU51bWJlcn0gYXR0ZW1wdHMuIExhc3QgZXJyb3I6ICR7ZXJyb3JNZXNzYWdlfWAsXG4gICAgICAgIHJlYXNvbjogJ21heFJldHJpZXNFeGNlZWRlZCcsXG4gICAgICAgIGVycm9yczogbmV3RXJyb3JzLFxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKFxuICAgICAgZXJyb3IgaW5zdGFuY2VvZiBFcnJvciAmJlxuICAgICAgQVBJQ2FsbEVycm9yLmlzQVBJQ2FsbEVycm9yKGVycm9yKSAmJlxuICAgICAgZXJyb3IuaXNSZXRyeWFibGUgPT09IHRydWUgJiZcbiAgICAgIHRyeU51bWJlciA8PSBtYXhSZXRyaWVzXG4gICAgKSB7XG4gICAgICBhd2FpdCBkZWxheShkZWxheUluTXMpO1xuICAgICAgcmV0dXJuIF9yZXRyeVdpdGhFeHBvbmVudGlhbEJhY2tvZmYoXG4gICAgICAgIGYsXG4gICAgICAgIHsgbWF4UmV0cmllcywgZGVsYXlJbk1zOiBiYWNrb2ZmRmFjdG9yICogZGVsYXlJbk1zLCBiYWNrb2ZmRmFjdG9yIH0sXG4gICAgICAgIG5ld0Vycm9ycyxcbiAgICAgICk7XG4gICAgfVxuXG4gICAgaWYgKHRyeU51bWJlciA9PT0gMSkge1xuICAgICAgdGhyb3cgZXJyb3I7IC8vIGRvbid0IHdyYXAgdGhlIGVycm9yIHdoZW4gYSBub24tcmV0cnlhYmxlIGVycm9yIG9jY3VycyBvbiB0aGUgZmlyc3QgdHJ5XG4gICAgfVxuXG4gICAgdGhyb3cgbmV3IFJldHJ5RXJyb3Ioe1xuICAgICAgbWVzc2FnZTogYEZhaWxlZCBhZnRlciAke3RyeU51bWJlcn0gYXR0ZW1wdHMgd2l0aCBub24tcmV0cnlhYmxlIGVycm9yOiAnJHtlcnJvck1lc3NhZ2V9J2AsXG4gICAgICByZWFzb246ICdlcnJvck5vdFJldHJ5YWJsZScsXG4gICAgICBlcnJvcnM6IG5ld0Vycm9ycyxcbiAgICB9KTtcbiAgfVxufVxuIiwiZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGRlbGF5KGRlbGF5SW5Ncz86IG51bWJlcik6IFByb21pc2U8dm9pZD4ge1xuICByZXR1cm4gZGVsYXlJbk1zID09PSB1bmRlZmluZWRcbiAgICA/IFByb21pc2UucmVzb2x2ZSgpXG4gICAgOiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgZGVsYXlJbk1zKSk7XG59XG4iLCJpbXBvcnQgeyBBSVNES0Vycm9yIH0gZnJvbSAnQGFpLXNkay9wcm92aWRlcic7XG5cbmNvbnN0IG5hbWUgPSAnQUlfUmV0cnlFcnJvcic7XG5jb25zdCBtYXJrZXIgPSBgdmVyY2VsLmFpLmVycm9yLiR7bmFtZX1gO1xuY29uc3Qgc3ltYm9sID0gU3ltYm9sLmZvcihtYXJrZXIpO1xuXG5leHBvcnQgdHlwZSBSZXRyeUVycm9yUmVhc29uID1cbiAgfCAnbWF4UmV0cmllc0V4Y2VlZGVkJ1xuICB8ICdlcnJvck5vdFJldHJ5YWJsZSdcbiAgfCAnYWJvcnQnO1xuXG5leHBvcnQgY2xhc3MgUmV0cnlFcnJvciBleHRlbmRzIEFJU0RLRXJyb3Ige1xuICBwcml2YXRlIHJlYWRvbmx5IFtzeW1ib2xdID0gdHJ1ZTsgLy8gdXNlZCBpbiBpc0luc3RhbmNlXG5cbiAgLy8gbm90ZTogcHJvcGVydHkgb3JkZXIgZGV0ZXJtaW5lcyBkZWJ1Z2dpbmcgb3V0cHV0XG4gIHJlYWRvbmx5IHJlYXNvbjogUmV0cnlFcnJvclJlYXNvbjtcbiAgcmVhZG9ubHkgbGFzdEVycm9yOiB1bmtub3duO1xuICByZWFkb25seSBlcnJvcnM6IEFycmF5PHVua25vd24+O1xuXG4gIGNvbnN0cnVjdG9yKHtcbiAgICBtZXNzYWdlLFxuICAgIHJlYXNvbixcbiAgICBlcnJvcnMsXG4gIH06IHtcbiAgICBtZXNzYWdlOiBzdHJpbmc7XG4gICAgcmVhc29uOiBSZXRyeUVycm9yUmVhc29uO1xuICAgIGVycm9yczogQXJyYXk8dW5rbm93bj47XG4gIH0pIHtcbiAgICBzdXBlcih7IG5hbWUsIG1lc3NhZ2UgfSk7XG5cbiAgICB0aGlzLnJlYXNvbiA9IHJlYXNvbjtcbiAgICB0aGlzLmVycm9ycyA9IGVycm9ycztcblxuICAgIC8vIHNlcGFyYXRlIG91ciBsYXN0IGVycm9yIHRvIG1ha2UgZGVidWdnaW5nIHZpYSBsb2cgZWFzaWVyOlxuICAgIHRoaXMubGFzdEVycm9yID0gZXJyb3JzW2Vycm9ycy5sZW5ndGggLSAxXTtcbiAgfVxuXG4gIHN0YXRpYyBpc0luc3RhbmNlKGVycm9yOiB1bmtub3duKTogZXJyb3IgaXMgUmV0cnlFcnJvciB7XG4gICAgcmV0dXJuIEFJU0RLRXJyb3IuaGFzTWFya2VyKGVycm9yLCBtYXJrZXIpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkIHVzZSBgaXNJbnN0YW5jZWAgaW5zdGVhZFxuICAgKi9cbiAgc3RhdGljIGlzUmV0cnlFcnJvcihlcnJvcjogdW5rbm93bik6IGVycm9yIGlzIFJldHJ5RXJyb3Ige1xuICAgIHJldHVybiAoXG4gICAgICBlcnJvciBpbnN0YW5jZW9mIEVycm9yICYmXG4gICAgICBlcnJvci5uYW1lID09PSBuYW1lICYmXG4gICAgICB0eXBlb2YgKGVycm9yIGFzIFJldHJ5RXJyb3IpLnJlYXNvbiA9PT0gJ3N0cmluZycgJiZcbiAgICAgIEFycmF5LmlzQXJyYXkoKGVycm9yIGFzIFJldHJ5RXJyb3IpLmVycm9ycylcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkIERvIG5vdCB1c2UgdGhpcyBtZXRob2QuIEl0IHdpbGwgYmUgcmVtb3ZlZCBpbiB0aGUgbmV4dCBtYWpvciB2ZXJzaW9uLlxuICAgKi9cbiAgdG9KU09OKCkge1xuICAgIHJldHVybiB7XG4gICAgICBuYW1lOiB0aGlzLm5hbWUsXG4gICAgICBtZXNzYWdlOiB0aGlzLm1lc3NhZ2UsXG4gICAgICByZWFzb246IHRoaXMucmVhc29uLFxuICAgICAgbGFzdEVycm9yOiB0aGlzLmxhc3RFcnJvcixcbiAgICAgIGVycm9yczogdGhpcy5lcnJvcnMsXG4gICAgfTtcbiAgfVxufVxuIiwiLyoqXG4gKiBXYXJuaW5nIHRpbWUgZm9yIG5vdGlmeWluZyBkZXZlbG9wZXJzIHRoYXQgYSBzdHJlYW0gaXMgaGFuZ2luZyBpbiBkZXYgbW9kZVxuICogdXNpbmcgYSBjb25zb2xlLndhcm4uXG4gKi9cbmV4cG9ydCBjb25zdCBIQU5HSU5HX1NUUkVBTV9XQVJOSU5HX1RJTUVfTVMgPSAxNSAqIDEwMDA7XG4iLCJpbXBvcnQgUmVhY3QsIHsgU3VzcGVuc2UgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBjcmVhdGVSZXNvbHZhYmxlUHJvbWlzZSB9IGZyb20gJy4uLy4uL3V0aWwvY3JlYXRlLXJlc29sdmFibGUtcHJvbWlzZSc7XG5cbi8vIFJlY3Vyc2l2ZSB0eXBlIGZvciB0aGUgY2h1bmsuXG50eXBlIENodW5rVHlwZSA9XG4gIHwge1xuICAgICAgZG9uZTogZmFsc2U7XG4gICAgICB2YWx1ZTogUmVhY3QuUmVhY3ROb2RlO1xuICAgICAgbmV4dDogUHJvbWlzZTxDaHVua1R5cGU+O1xuICAgICAgYXBwZW5kPzogYm9vbGVhbjtcbiAgICB9XG4gIHwge1xuICAgICAgZG9uZTogdHJ1ZTtcbiAgICAgIHZhbHVlOiBSZWFjdC5SZWFjdE5vZGU7XG4gICAgfTtcblxuLy8gVXNlIHNpbmdsZSBsZXR0ZXIgbmFtZXMgZm9yIHRoZSB2YXJpYWJsZXMgdG8gcmVkdWNlIHRoZSBzaXplIG9mIHRoZSBSU0MgcGF5bG9hZC5cbi8vIGBSYCBmb3IgYFJvd2AsIGBjYCBmb3IgYGN1cnJlbnRgLCBgbmAgZm9yIGBuZXh0YC5cbi8vIE5vdGU6IEFycmF5IGNvbnN0cnVjdGlvbiBpcyBuZWVkZWQgdG8gYWNjZXNzIHRoZSBuYW1lIFIuXG5jb25zdCBSID0gW1xuICAoYXN5bmMgKHtcbiAgICBjOiBjdXJyZW50LFxuICAgIG46IG5leHQsXG4gIH06IHtcbiAgICBjOiBSZWFjdC5SZWFjdE5vZGU7XG4gICAgbjogUHJvbWlzZTxDaHVua1R5cGU+O1xuICB9KSA9PiB7XG4gICAgY29uc3QgY2h1bmsgPSBhd2FpdCBuZXh0O1xuXG4gICAgaWYgKGNodW5rLmRvbmUpIHtcbiAgICAgIHJldHVybiBjaHVuay52YWx1ZTtcbiAgICB9XG5cbiAgICBpZiAoY2h1bmsuYXBwZW5kKSB7XG4gICAgICByZXR1cm4gKFxuICAgICAgICA8PlxuICAgICAgICAgIHtjdXJyZW50fVxuICAgICAgICAgIDxTdXNwZW5zZSBmYWxsYmFjaz17Y2h1bmsudmFsdWV9PlxuICAgICAgICAgICAgPFIgYz17Y2h1bmsudmFsdWV9IG49e2NodW5rLm5leHR9IC8+XG4gICAgICAgICAgPC9TdXNwZW5zZT5cbiAgICAgICAgPC8+XG4gICAgICApO1xuICAgIH1cblxuICAgIHJldHVybiAoXG4gICAgICA8U3VzcGVuc2UgZmFsbGJhY2s9e2NodW5rLnZhbHVlfT5cbiAgICAgICAgPFIgYz17Y2h1bmsudmFsdWV9IG49e2NodW5rLm5leHR9IC8+XG4gICAgICA8L1N1c3BlbnNlPlxuICAgICk7XG4gIH0pIGFzIHVua25vd24gYXMgUmVhY3QuRkM8e1xuICAgIGM6IFJlYWN0LlJlYWN0Tm9kZTtcbiAgICBuOiBQcm9taXNlPENodW5rVHlwZT47XG4gIH0+LFxuXVswXTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgc3VzcGVuZGVkIGNodW5rIGZvciBSZWFjdCBTZXJ2ZXIgQ29tcG9uZW50cy5cbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIGdlbmVyYXRlcyBhIHN1c3BlbnNlZnVsIFJlYWN0IGNvbXBvbmVudCB0aGF0IGNhbiBiZSBkeW5hbWljYWxseSB1cGRhdGVkLlxuICogSXQncyB1c2VmdWwgZm9yIHN0cmVhbWluZyB1cGRhdGVzIHRvIHRoZSBjbGllbnQgaW4gYSBSZWFjdCBTZXJ2ZXIgQ29tcG9uZW50cyBjb250ZXh0LlxuICpcbiAqIEBwYXJhbSB7UmVhY3QuUmVhY3ROb2RlfSBpbml0aWFsVmFsdWUgLSBUaGUgaW5pdGlhbCB2YWx1ZSB0byByZW5kZXIgd2hpbGUgdGhlIHByb21pc2UgaXMgcGVuZGluZy5cbiAqIEByZXR1cm5zIHtPYmplY3R9IEFuIG9iamVjdCBjb250YWluaW5nOlxuICogICAtIHJvdzogQSBSZWFjdCBub2RlIHRoYXQgcmVuZGVycyB0aGUgc3VzcGVuc2VmdWwgY29udGVudC5cbiAqICAgLSByZXNvbHZlOiBBIGZ1bmN0aW9uIHRvIHJlc29sdmUgdGhlIHByb21pc2Ugd2l0aCBhIG5ldyB2YWx1ZS5cbiAqICAgLSByZWplY3Q6IEEgZnVuY3Rpb24gdG8gcmVqZWN0IHRoZSBwcm9taXNlIHdpdGggYW4gZXJyb3IuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVTdXNwZW5kZWRDaHVuayhpbml0aWFsVmFsdWU6IFJlYWN0LlJlYWN0Tm9kZSk6IHtcbiAgcm93OiBSZWFjdC5SZWFjdE5vZGU7XG4gIHJlc29sdmU6ICh2YWx1ZTogQ2h1bmtUeXBlKSA9PiB2b2lkO1xuICByZWplY3Q6IChlcnJvcjogdW5rbm93bikgPT4gdm9pZDtcbn0ge1xuICBjb25zdCB7IHByb21pc2UsIHJlc29sdmUsIHJlamVjdCB9ID0gY3JlYXRlUmVzb2x2YWJsZVByb21pc2U8Q2h1bmtUeXBlPigpO1xuXG4gIHJldHVybiB7XG4gICAgcm93OiAoXG4gICAgICA8U3VzcGVuc2UgZmFsbGJhY2s9e2luaXRpYWxWYWx1ZX0+XG4gICAgICAgIDxSIGM9e2luaXRpYWxWYWx1ZX0gbj17cHJvbWlzZX0gLz5cbiAgICAgIDwvU3VzcGVuc2U+XG4gICAgKSxcbiAgICByZXNvbHZlLFxuICAgIHJlamVjdCxcbiAgfTtcbn1cbiIsImltcG9ydCB7IEhBTkdJTkdfU1RSRUFNX1dBUk5JTkdfVElNRV9NUyB9IGZyb20gJy4uLy4uL3V0aWwvY29uc3RhbnRzJztcbmltcG9ydCB7IGNyZWF0ZVJlc29sdmFibGVQcm9taXNlIH0gZnJvbSAnLi4vLi4vdXRpbC9jcmVhdGUtcmVzb2x2YWJsZS1wcm9taXNlJztcbmltcG9ydCB7IGNyZWF0ZVN1c3BlbmRlZENodW5rIH0gZnJvbSAnLi9jcmVhdGUtc3VzcGVuZGVkLWNodW5rJztcblxuLy8gSXQncyBuZWNlc3NhcnkgdG8gZGVmaW5lIHRoZSB0eXBlIG1hbnVhbGx5IGhlcmUsIG90aGVyd2lzZSBUeXBlU2NyaXB0IGNvbXBpbGVyXG4vLyB3aWxsIG5vdCBiZSBhYmxlIHRvIGluZmVyIHRoZSBjb3JyZWN0IHJldHVybiB0eXBlIGFzIGl0J3MgY2lyY3VsYXIuXG50eXBlIFN0cmVhbWFibGVVSVdyYXBwZXIgPSB7XG4gIC8qKlxuICAgKiBUaGUgdmFsdWUgb2YgdGhlIHN0cmVhbWFibGUgVUkuIFRoaXMgY2FuIGJlIHJldHVybmVkIGZyb20gYSBTZXJ2ZXIgQWN0aW9uIGFuZCByZWNlaXZlZCBieSB0aGUgY2xpZW50LlxuICAgKi9cbiAgcmVhZG9ubHkgdmFsdWU6IFJlYWN0LlJlYWN0Tm9kZTtcblxuICAvKipcbiAgICogVGhpcyBtZXRob2QgdXBkYXRlcyB0aGUgY3VycmVudCBVSSBub2RlLiBJdCB0YWtlcyBhIG5ldyBVSSBub2RlIGFuZCByZXBsYWNlcyB0aGUgb2xkIG9uZS5cbiAgICovXG4gIHVwZGF0ZSh2YWx1ZTogUmVhY3QuUmVhY3ROb2RlKTogU3RyZWFtYWJsZVVJV3JhcHBlcjtcblxuICAvKipcbiAgICogVGhpcyBtZXRob2QgaXMgdXNlZCB0byBhcHBlbmQgYSBuZXcgVUkgbm9kZSB0byB0aGUgZW5kIG9mIHRoZSBvbGQgb25lLlxuICAgKiBPbmNlIGFwcGVuZGVkIGEgbmV3IFVJIG5vZGUsIHRoZSBwcmV2aW91cyBVSSBub2RlIGNhbm5vdCBiZSB1cGRhdGVkIGFueW1vcmUuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYGpzeFxuICAgKiBjb25zdCB1aSA9IGNyZWF0ZVN0cmVhbWFibGVVSSg8ZGl2PmhlbGxvPC9kaXY+KVxuICAgKiB1aS5hcHBlbmQoPGRpdj53b3JsZDwvZGl2PilcbiAgICpcbiAgICogLy8gVGhlIFVJIG5vZGUgd2lsbCBiZTpcbiAgICogLy8gPD5cbiAgICogLy8gICA8ZGl2PmhlbGxvPC9kaXY+XG4gICAqIC8vICAgPGRpdj53b3JsZDwvZGl2PlxuICAgKiAvLyA8Lz5cbiAgICogYGBgXG4gICAqL1xuICBhcHBlbmQodmFsdWU6IFJlYWN0LlJlYWN0Tm9kZSk6IFN0cmVhbWFibGVVSVdyYXBwZXI7XG5cbiAgLyoqXG4gICAqIFRoaXMgbWV0aG9kIGlzIHVzZWQgdG8gc2lnbmFsIHRoYXQgdGhlcmUgaXMgYW4gZXJyb3IgaW4gdGhlIFVJIHN0cmVhbS5cbiAgICogSXQgd2lsbCBiZSB0aHJvd24gb24gdGhlIGNsaWVudCBzaWRlIGFuZCBjYXVnaHQgYnkgdGhlIG5lYXJlc3QgZXJyb3IgYm91bmRhcnkgY29tcG9uZW50LlxuICAgKi9cbiAgZXJyb3IoZXJyb3I6IGFueSk6IFN0cmVhbWFibGVVSVdyYXBwZXI7XG5cbiAgLyoqXG4gICAqIFRoaXMgbWV0aG9kIG1hcmtzIHRoZSBVSSBub2RlIGFzIGZpbmFsaXplZC4gWW91IGNhbiBlaXRoZXIgY2FsbCBpdCB3aXRob3V0IGFueSBwYXJhbWV0ZXJzIG9yIHdpdGggYSBuZXcgVUkgbm9kZSBhcyB0aGUgZmluYWwgc3RhdGUuXG4gICAqIE9uY2UgY2FsbGVkLCB0aGUgVUkgbm9kZSBjYW5ub3QgYmUgdXBkYXRlZCBvciBhcHBlbmRlZCBhbnltb3JlLlxuICAgKlxuICAgKiBUaGlzIG1ldGhvZCBpcyBhbHdheXMgKipyZXF1aXJlZCoqIHRvIGJlIGNhbGxlZCwgb3RoZXJ3aXNlIHRoZSByZXNwb25zZSB3aWxsIGJlIHN0dWNrIGluIGEgbG9hZGluZyBzdGF0ZS5cbiAgICovXG4gIGRvbmUoLi4uYXJnczogW1JlYWN0LlJlYWN0Tm9kZV0gfCBbXSk6IFN0cmVhbWFibGVVSVdyYXBwZXI7XG59O1xuXG4vKipcbiAqIENyZWF0ZSBhIHBpZWNlIG9mIGNoYW5nZWFibGUgVUkgdGhhdCBjYW4gYmUgc3RyZWFtZWQgdG8gdGhlIGNsaWVudC5cbiAqIE9uIHRoZSBjbGllbnQgc2lkZSwgaXQgY2FuIGJlIHJlbmRlcmVkIGFzIGEgbm9ybWFsIFJlYWN0IG5vZGUuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVN0cmVhbWFibGVVSShpbml0aWFsVmFsdWU/OiBSZWFjdC5SZWFjdE5vZGUpIHtcbiAgbGV0IGN1cnJlbnRWYWx1ZSA9IGluaXRpYWxWYWx1ZTtcbiAgbGV0IGNsb3NlZCA9IGZhbHNlO1xuICBsZXQgeyByb3csIHJlc29sdmUsIHJlamVjdCB9ID0gY3JlYXRlU3VzcGVuZGVkQ2h1bmsoaW5pdGlhbFZhbHVlKTtcblxuICBmdW5jdGlvbiBhc3NlcnRTdHJlYW0obWV0aG9kOiBzdHJpbmcpIHtcbiAgICBpZiAoY2xvc2VkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IobWV0aG9kICsgJzogVUkgc3RyZWFtIGlzIGFscmVhZHkgY2xvc2VkLicpO1xuICAgIH1cbiAgfVxuXG4gIGxldCB3YXJuaW5nVGltZW91dDogTm9kZUpTLlRpbWVvdXQgfCB1bmRlZmluZWQ7XG4gIGZ1bmN0aW9uIHdhcm5VbmNsb3NlZFN0cmVhbSgpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcpIHtcbiAgICAgIGlmICh3YXJuaW5nVGltZW91dCkge1xuICAgICAgICBjbGVhclRpbWVvdXQod2FybmluZ1RpbWVvdXQpO1xuICAgICAgfVxuICAgICAgd2FybmluZ1RpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgICdUaGUgc3RyZWFtYWJsZSBVSSBoYXMgYmVlbiBzbG93IHRvIHVwZGF0ZS4gVGhpcyBtYXkgYmUgYSBidWcgb3IgYSBwZXJmb3JtYW5jZSBpc3N1ZSBvciB5b3UgZm9yZ290IHRvIGNhbGwgYC5kb25lKClgLicsXG4gICAgICAgICk7XG4gICAgICB9LCBIQU5HSU5HX1NUUkVBTV9XQVJOSU5HX1RJTUVfTVMpO1xuICAgIH1cbiAgfVxuICB3YXJuVW5jbG9zZWRTdHJlYW0oKTtcblxuICBjb25zdCBzdHJlYW1hYmxlOiBTdHJlYW1hYmxlVUlXcmFwcGVyID0ge1xuICAgIHZhbHVlOiByb3csXG4gICAgdXBkYXRlKHZhbHVlOiBSZWFjdC5SZWFjdE5vZGUpIHtcbiAgICAgIGFzc2VydFN0cmVhbSgnLnVwZGF0ZSgpJyk7XG5cbiAgICAgIC8vIFRoZXJlIGlzIG5vIG5lZWQgdG8gdXBkYXRlIHRoZSB2YWx1ZSBpZiBpdCdzIHJlZmVyZW50aWFsbHkgZXF1YWwuXG4gICAgICBpZiAodmFsdWUgPT09IGN1cnJlbnRWYWx1ZSkge1xuICAgICAgICB3YXJuVW5jbG9zZWRTdHJlYW0oKTtcbiAgICAgICAgcmV0dXJuIHN0cmVhbWFibGU7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHJlc29sdmFibGUgPSBjcmVhdGVSZXNvbHZhYmxlUHJvbWlzZSgpO1xuICAgICAgY3VycmVudFZhbHVlID0gdmFsdWU7XG5cbiAgICAgIHJlc29sdmUoeyB2YWx1ZTogY3VycmVudFZhbHVlLCBkb25lOiBmYWxzZSwgbmV4dDogcmVzb2x2YWJsZS5wcm9taXNlIH0pO1xuICAgICAgcmVzb2x2ZSA9IHJlc29sdmFibGUucmVzb2x2ZTtcbiAgICAgIHJlamVjdCA9IHJlc29sdmFibGUucmVqZWN0O1xuXG4gICAgICB3YXJuVW5jbG9zZWRTdHJlYW0oKTtcblxuICAgICAgcmV0dXJuIHN0cmVhbWFibGU7XG4gICAgfSxcbiAgICBhcHBlbmQodmFsdWU6IFJlYWN0LlJlYWN0Tm9kZSkge1xuICAgICAgYXNzZXJ0U3RyZWFtKCcuYXBwZW5kKCknKTtcblxuICAgICAgY29uc3QgcmVzb2x2YWJsZSA9IGNyZWF0ZVJlc29sdmFibGVQcm9taXNlKCk7XG4gICAgICBjdXJyZW50VmFsdWUgPSB2YWx1ZTtcblxuICAgICAgcmVzb2x2ZSh7IHZhbHVlLCBkb25lOiBmYWxzZSwgYXBwZW5kOiB0cnVlLCBuZXh0OiByZXNvbHZhYmxlLnByb21pc2UgfSk7XG4gICAgICByZXNvbHZlID0gcmVzb2x2YWJsZS5yZXNvbHZlO1xuICAgICAgcmVqZWN0ID0gcmVzb2x2YWJsZS5yZWplY3Q7XG5cbiAgICAgIHdhcm5VbmNsb3NlZFN0cmVhbSgpO1xuXG4gICAgICByZXR1cm4gc3RyZWFtYWJsZTtcbiAgICB9LFxuICAgIGVycm9yKGVycm9yOiBhbnkpIHtcbiAgICAgIGFzc2VydFN0cmVhbSgnLmVycm9yKCknKTtcblxuICAgICAgaWYgKHdhcm5pbmdUaW1lb3V0KSB7XG4gICAgICAgIGNsZWFyVGltZW91dCh3YXJuaW5nVGltZW91dCk7XG4gICAgICB9XG4gICAgICBjbG9zZWQgPSB0cnVlO1xuICAgICAgcmVqZWN0KGVycm9yKTtcblxuICAgICAgcmV0dXJuIHN0cmVhbWFibGU7XG4gICAgfSxcbiAgICBkb25lKC4uLmFyZ3M6IFtdIHwgW1JlYWN0LlJlYWN0Tm9kZV0pIHtcbiAgICAgIGFzc2VydFN0cmVhbSgnLmRvbmUoKScpO1xuXG4gICAgICBpZiAod2FybmluZ1RpbWVvdXQpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHdhcm5pbmdUaW1lb3V0KTtcbiAgICAgIH1cbiAgICAgIGNsb3NlZCA9IHRydWU7XG4gICAgICBpZiAoYXJncy5sZW5ndGgpIHtcbiAgICAgICAgcmVzb2x2ZSh7IHZhbHVlOiBhcmdzWzBdLCBkb25lOiB0cnVlIH0pO1xuICAgICAgICByZXR1cm4gc3RyZWFtYWJsZTtcbiAgICAgIH1cbiAgICAgIHJlc29sdmUoeyB2YWx1ZTogY3VycmVudFZhbHVlLCBkb25lOiB0cnVlIH0pO1xuXG4gICAgICByZXR1cm4gc3RyZWFtYWJsZTtcbiAgICB9LFxuICB9O1xuXG4gIHJldHVybiBzdHJlYW1hYmxlO1xufVxuXG5leHBvcnQgeyBjcmVhdGVTdHJlYW1hYmxlVUkgfTtcbiIsImltcG9ydCB0eXBlIE9wZW5BSSBmcm9tICdvcGVuYWknO1xuaW1wb3J0IHR5cGUgeyBSZWFjdE5vZGUgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyB6IH0gZnJvbSAnem9kJztcbmltcG9ydCB6b2RUb0pzb25TY2hlbWEgZnJvbSAnem9kLXRvLWpzb24tc2NoZW1hJztcbmltcG9ydCB7IE9wZW5BSVN0cmVhbSB9IGZyb20gJy4uLy4uL3N0cmVhbXMnO1xuaW1wb3J0IHsgY29uc3VtZVN0cmVhbSB9IGZyb20gJy4uLy4uL3V0aWwvY29uc3VtZS1zdHJlYW0nO1xuaW1wb3J0IHsgY3JlYXRlUmVzb2x2YWJsZVByb21pc2UgfSBmcm9tICcuLi8uLi91dGlsL2NyZWF0ZS1yZXNvbHZhYmxlLXByb21pc2UnO1xuaW1wb3J0IHsgY3JlYXRlU3RyZWFtYWJsZVVJIH0gZnJvbSAnLi4vc3RyZWFtYWJsZS11aS9jcmVhdGUtc3RyZWFtYWJsZS11aSc7XG5cbnR5cGUgU3RyZWFtYWJsZSA9IFJlYWN0Tm9kZSB8IFByb21pc2U8UmVhY3ROb2RlPjtcbnR5cGUgUmVuZGVyZXI8VD4gPSAoXG4gIHByb3BzOiBULFxuKSA9PlxuICB8IFN0cmVhbWFibGVcbiAgfCBHZW5lcmF0b3I8U3RyZWFtYWJsZSwgU3RyZWFtYWJsZSwgdm9pZD5cbiAgfCBBc3luY0dlbmVyYXRvcjxTdHJlYW1hYmxlLCBTdHJlYW1hYmxlLCB2b2lkPjtcblxuLyoqXG4gKiBgcmVuZGVyYCBpcyBhIGhlbHBlciBmdW5jdGlvbiB0byBjcmVhdGUgYSBzdHJlYW1hYmxlIFVJIGZyb20gc29tZSBMTE1zLlxuICogVGhpcyBBUEkgb25seSBzdXBwb3J0cyBPcGVuQUkncyBHUFQgbW9kZWxzIHdpdGggRnVuY3Rpb24gQ2FsbGluZyBhbmQgQXNzaXN0YW50cyBUb29scyxcbiAqIHBsZWFzZSB1c2UgYHN0cmVhbVVJYCBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG90aGVyIHByb3ZpZGVycy5cbiAqXG4gKiBAZGVwcmVjYXRlZCBJdCdzIHJlY29tbWVuZGVkIHRvIHVzZSB0aGUgYHN0cmVhbVVJYCBBUEkgZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBBSSBTREsgQ29yZSBBUElzXG4gKiBhbmQgZnV0dXJlIGZlYXR1cmVzLiBUaGlzIEFQSSB3aWxsIGJlIHJlbW92ZWQgaW4gYSBmdXR1cmUgcmVsZWFzZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlbmRlcjxcbiAgVFMgZXh0ZW5kcyB7XG4gICAgW25hbWU6IHN0cmluZ106IHouU2NoZW1hO1xuICB9ID0ge30sXG4gIEZTIGV4dGVuZHMge1xuICAgIFtuYW1lOiBzdHJpbmddOiB6LlNjaGVtYTtcbiAgfSA9IHt9LFxuPihvcHRpb25zOiB7XG4gIC8qKlxuICAgKiBUaGUgbW9kZWwgbmFtZSB0byB1c2UuIE11c3QgYmUgT3BlbkFJIFNESyBjb21wYXRpYmxlLiBUb29scyBhbmQgRnVuY3Rpb25zIGFyZSBvbmx5IHN1cHBvcnRlZFxuICAgKiBHUFQgbW9kZWxzICgzLjUvNCksIE9wZW5BSSBBc3Npc3RhbnRzLCBNaXN0cmFsIHNtYWxsIGFuZCBsYXJnZSwgYW5kIEZpcmV3b3JrcyBmaXJlZnVuY3Rpb24tdjEuXG4gICAqXG4gICAqIEBleGFtcGxlIFwiZ3B0LTMuNS10dXJib1wiXG4gICAqL1xuICBtb2RlbDogc3RyaW5nO1xuICAvKipcbiAgICogVGhlIHByb3ZpZGVyIGluc3RhbmNlIHRvIHVzZS4gQ3VycmVudGx5IHRoZSBvbmx5IHByb3ZpZGVyIGF2YWlsYWJsZSBpcyBPcGVuQUkuXG4gICAqIFRoaXMgbmVlZHMgdG8gbWF0Y2ggdGhlIG1vZGVsIG5hbWUuXG4gICAqL1xuICBwcm92aWRlcjogT3BlbkFJO1xuICBtZXNzYWdlczogUGFyYW1ldGVyczxcbiAgICB0eXBlb2YgT3BlbkFJLnByb3RvdHlwZS5jaGF0LmNvbXBsZXRpb25zLmNyZWF0ZVxuICA+WzBdWydtZXNzYWdlcyddO1xuICB0ZXh0PzogUmVuZGVyZXI8e1xuICAgIC8qKlxuICAgICAqIFRoZSBmdWxsIHRleHQgY29udGVudCBmcm9tIHRoZSBtb2RlbCBzbyBmYXIuXG4gICAgICovXG4gICAgY29udGVudDogc3RyaW5nO1xuICAgIC8qKlxuICAgICAqIFRoZSBuZXcgYXBwZW5kZWQgdGV4dCBjb250ZW50IGZyb20gdGhlIG1vZGVsIHNpbmNlIHRoZSBsYXN0IGB0ZXh0YCBjYWxsLlxuICAgICAqL1xuICAgIGRlbHRhOiBzdHJpbmc7XG4gICAgLyoqXG4gICAgICogV2hldGhlciB0aGUgbW9kZWwgaXMgZG9uZSBnZW5lcmF0aW5nIHRleHQuXG4gICAgICogSWYgYHRydWVgLCB0aGUgYGNvbnRlbnRgIHdpbGwgYmUgdGhlIGZpbmFsIG91dHB1dCBhbmQgdGhpcyBjYWxsIHdpbGwgYmUgdGhlIGxhc3QuXG4gICAgICovXG4gICAgZG9uZTogYm9vbGVhbjtcbiAgfT47XG4gIHRvb2xzPzoge1xuICAgIFtuYW1lIGluIGtleW9mIFRTXToge1xuICAgICAgZGVzY3JpcHRpb24/OiBzdHJpbmc7XG4gICAgICBwYXJhbWV0ZXJzOiBUU1tuYW1lXTtcbiAgICAgIHJlbmRlcjogUmVuZGVyZXI8ei5pbmZlcjxUU1tuYW1lXT4+O1xuICAgIH07XG4gIH07XG4gIGZ1bmN0aW9ucz86IHtcbiAgICBbbmFtZSBpbiBrZXlvZiBGU106IHtcbiAgICAgIGRlc2NyaXB0aW9uPzogc3RyaW5nO1xuICAgICAgcGFyYW1ldGVyczogRlNbbmFtZV07XG4gICAgICByZW5kZXI6IFJlbmRlcmVyPHouaW5mZXI8RlNbbmFtZV0+PjtcbiAgICB9O1xuICB9O1xuICBpbml0aWFsPzogUmVhY3ROb2RlO1xuICB0ZW1wZXJhdHVyZT86IG51bWJlcjtcbn0pOiBSZWFjdE5vZGUge1xuICBjb25zdCB1aSA9IGNyZWF0ZVN0cmVhbWFibGVVSShvcHRpb25zLmluaXRpYWwpO1xuXG4gIC8vIFRoZSBkZWZhdWx0IHRleHQgcmVuZGVyZXIganVzdCByZXR1cm5zIHRoZSBjb250ZW50IGFzIHN0cmluZy5cbiAgY29uc3QgdGV4dCA9IG9wdGlvbnMudGV4dFxuICAgID8gb3B0aW9ucy50ZXh0XG4gICAgOiAoeyBjb250ZW50IH06IHsgY29udGVudDogc3RyaW5nIH0pID0+IGNvbnRlbnQ7XG5cbiAgY29uc3QgZnVuY3Rpb25zID0gb3B0aW9ucy5mdW5jdGlvbnNcbiAgICA/IE9iamVjdC5lbnRyaWVzKG9wdGlvbnMuZnVuY3Rpb25zKS5tYXAoXG4gICAgICAgIChbbmFtZSwgeyBkZXNjcmlwdGlvbiwgcGFyYW1ldGVycyB9XSkgPT4ge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgZGVzY3JpcHRpb24sXG4gICAgICAgICAgICBwYXJhbWV0ZXJzOiB6b2RUb0pzb25TY2hlbWEocGFyYW1ldGVycykgYXMgUmVjb3JkPHN0cmluZywgdW5rbm93bj4sXG4gICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgIClcbiAgICA6IHVuZGVmaW5lZDtcblxuICBjb25zdCB0b29scyA9IG9wdGlvbnMudG9vbHNcbiAgICA/IE9iamVjdC5lbnRyaWVzKG9wdGlvbnMudG9vbHMpLm1hcChcbiAgICAgICAgKFtuYW1lLCB7IGRlc2NyaXB0aW9uLCBwYXJhbWV0ZXJzIH1dKSA9PiB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6ICdmdW5jdGlvbicgYXMgY29uc3QsXG4gICAgICAgICAgICBmdW5jdGlvbjoge1xuICAgICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgICBkZXNjcmlwdGlvbixcbiAgICAgICAgICAgICAgcGFyYW1ldGVyczogem9kVG9Kc29uU2NoZW1hKHBhcmFtZXRlcnMpIGFzIFJlY29yZDxcbiAgICAgICAgICAgICAgICBzdHJpbmcsXG4gICAgICAgICAgICAgICAgdW5rbm93blxuICAgICAgICAgICAgICA+LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgKVxuICAgIDogdW5kZWZpbmVkO1xuXG4gIGlmIChmdW5jdGlvbnMgJiYgdG9vbHMpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBcIllvdSBjYW4ndCBoYXZlIGJvdGggZnVuY3Rpb25zIGFuZCB0b29scyBkZWZpbmVkLiBQbGVhc2UgY2hvb3NlIG9uZSBvciB0aGUgb3RoZXIuXCIsXG4gICAgKTtcbiAgfVxuXG4gIGxldCBmaW5pc2hlZDogUHJvbWlzZTx2b2lkPiB8IHVuZGVmaW5lZDtcblxuICBhc3luYyBmdW5jdGlvbiBoYW5kbGVSZW5kZXIoXG4gICAgYXJnczogYW55LFxuICAgIHJlbmRlcmVyOiB1bmRlZmluZWQgfCBSZW5kZXJlcjxhbnk+LFxuICAgIHJlczogUmV0dXJuVHlwZTx0eXBlb2YgY3JlYXRlU3RyZWFtYWJsZVVJPixcbiAgKSB7XG4gICAgaWYgKCFyZW5kZXJlcikgcmV0dXJuO1xuXG4gICAgY29uc3QgcmVzb2x2YWJsZSA9IGNyZWF0ZVJlc29sdmFibGVQcm9taXNlPHZvaWQ+KCk7XG5cbiAgICBpZiAoZmluaXNoZWQpIHtcbiAgICAgIGZpbmlzaGVkID0gZmluaXNoZWQudGhlbigoKSA9PiByZXNvbHZhYmxlLnByb21pc2UpO1xuICAgIH0gZWxzZSB7XG4gICAgICBmaW5pc2hlZCA9IHJlc29sdmFibGUucHJvbWlzZTtcbiAgICB9XG5cbiAgICBjb25zdCB2YWx1ZSA9IHJlbmRlcmVyKGFyZ3MpO1xuICAgIGlmIChcbiAgICAgIHZhbHVlIGluc3RhbmNlb2YgUHJvbWlzZSB8fFxuICAgICAgKHZhbHVlICYmXG4gICAgICAgIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgJ3RoZW4nIGluIHZhbHVlICYmXG4gICAgICAgIHR5cGVvZiB2YWx1ZS50aGVuID09PSAnZnVuY3Rpb24nKVxuICAgICkge1xuICAgICAgY29uc3Qgbm9kZSA9IGF3YWl0ICh2YWx1ZSBhcyBQcm9taXNlPFJlYWN0LlJlYWN0Tm9kZT4pO1xuICAgICAgcmVzLnVwZGF0ZShub2RlKTtcbiAgICAgIHJlc29sdmFibGUucmVzb2x2ZSh2b2lkIDApO1xuICAgIH0gZWxzZSBpZiAoXG4gICAgICB2YWx1ZSAmJlxuICAgICAgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJlxuICAgICAgU3ltYm9sLmFzeW5jSXRlcmF0b3IgaW4gdmFsdWVcbiAgICApIHtcbiAgICAgIGNvbnN0IGl0ID0gdmFsdWUgYXMgQXN5bmNHZW5lcmF0b3I8XG4gICAgICAgIFJlYWN0LlJlYWN0Tm9kZSxcbiAgICAgICAgUmVhY3QuUmVhY3ROb2RlLFxuICAgICAgICB2b2lkXG4gICAgICA+O1xuICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgY29uc3QgeyBkb25lLCB2YWx1ZSB9ID0gYXdhaXQgaXQubmV4dCgpO1xuICAgICAgICByZXMudXBkYXRlKHZhbHVlKTtcbiAgICAgICAgaWYgKGRvbmUpIGJyZWFrO1xuICAgICAgfVxuICAgICAgcmVzb2x2YWJsZS5yZXNvbHZlKHZvaWQgMCk7XG4gICAgfSBlbHNlIGlmICh2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIFN5bWJvbC5pdGVyYXRvciBpbiB2YWx1ZSkge1xuICAgICAgY29uc3QgaXQgPSB2YWx1ZSBhcyBHZW5lcmF0b3I8UmVhY3QuUmVhY3ROb2RlLCBSZWFjdC5SZWFjdE5vZGUsIHZvaWQ+O1xuICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgY29uc3QgeyBkb25lLCB2YWx1ZSB9ID0gaXQubmV4dCgpO1xuICAgICAgICByZXMudXBkYXRlKHZhbHVlKTtcbiAgICAgICAgaWYgKGRvbmUpIGJyZWFrO1xuICAgICAgfVxuICAgICAgcmVzb2x2YWJsZS5yZXNvbHZlKHZvaWQgMCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlcy51cGRhdGUodmFsdWUpO1xuICAgICAgcmVzb2x2YWJsZS5yZXNvbHZlKHZvaWQgMCk7XG4gICAgfVxuICB9XG5cbiAgKGFzeW5jICgpID0+IHtcbiAgICBsZXQgaGFzRnVuY3Rpb24gPSBmYWxzZTtcbiAgICBsZXQgY29udGVudCA9ICcnO1xuXG4gICAgY29uc3VtZVN0cmVhbShcbiAgICAgIE9wZW5BSVN0cmVhbShcbiAgICAgICAgKGF3YWl0IG9wdGlvbnMucHJvdmlkZXIuY2hhdC5jb21wbGV0aW9ucy5jcmVhdGUoe1xuICAgICAgICAgIG1vZGVsOiBvcHRpb25zLm1vZGVsLFxuICAgICAgICAgIG1lc3NhZ2VzOiBvcHRpb25zLm1lc3NhZ2VzLFxuICAgICAgICAgIHRlbXBlcmF0dXJlOiBvcHRpb25zLnRlbXBlcmF0dXJlLFxuICAgICAgICAgIHN0cmVhbTogdHJ1ZSxcbiAgICAgICAgICAuLi4oZnVuY3Rpb25zXG4gICAgICAgICAgICA/IHtcbiAgICAgICAgICAgICAgICBmdW5jdGlvbnMsXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIDoge30pLFxuICAgICAgICAgIC4uLih0b29sc1xuICAgICAgICAgICAgPyB7XG4gICAgICAgICAgICAgICAgdG9vbHMsXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIDoge30pLFxuICAgICAgICB9KSkgYXMgYW55LFxuICAgICAgICB7XG4gICAgICAgICAgLi4uKGZ1bmN0aW9uc1xuICAgICAgICAgICAgPyB7XG4gICAgICAgICAgICAgICAgYXN5bmMgZXhwZXJpbWVudGFsX29uRnVuY3Rpb25DYWxsKGZ1bmN0aW9uQ2FsbFBheWxvYWQpIHtcbiAgICAgICAgICAgICAgICAgIGhhc0Z1bmN0aW9uID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgIGhhbmRsZVJlbmRlcihcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb25DYWxsUGF5bG9hZC5hcmd1bWVudHMsXG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuZnVuY3Rpb25zPy5bZnVuY3Rpb25DYWxsUGF5bG9hZC5uYW1lIGFzIGFueV1cbiAgICAgICAgICAgICAgICAgICAgICA/LnJlbmRlcixcbiAgICAgICAgICAgICAgICAgICAgdWksXG4gICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIDoge30pLFxuICAgICAgICAgIC4uLih0b29sc1xuICAgICAgICAgICAgPyB7XG4gICAgICAgICAgICAgICAgYXN5bmMgZXhwZXJpbWVudGFsX29uVG9vbENhbGwodG9vbENhbGxQYXlsb2FkOiBhbnkpIHtcbiAgICAgICAgICAgICAgICAgIGhhc0Z1bmN0aW9uID0gdHJ1ZTtcblxuICAgICAgICAgICAgICAgICAgLy8gVE9ETzogV2UgbWlnaHQgbmVlZCBQcm9taXNlLmFsbCBoZXJlP1xuICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCB0b29sIG9mIHRvb2xDYWxsUGF5bG9hZC50b29scykge1xuICAgICAgICAgICAgICAgICAgICBoYW5kbGVSZW5kZXIoXG4gICAgICAgICAgICAgICAgICAgICAgdG9vbC5mdW5jLmFyZ3VtZW50cyxcbiAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLnRvb2xzPy5bdG9vbC5mdW5jLm5hbWUgYXMgYW55XT8ucmVuZGVyLFxuICAgICAgICAgICAgICAgICAgICAgIHVpLFxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIDoge30pLFxuICAgICAgICAgIG9uVGV4dChjaHVuaykge1xuICAgICAgICAgICAgY29udGVudCArPSBjaHVuaztcbiAgICAgICAgICAgIGhhbmRsZVJlbmRlcih7IGNvbnRlbnQsIGRvbmU6IGZhbHNlLCBkZWx0YTogY2h1bmsgfSwgdGV4dCwgdWkpO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgYXN5bmMgb25GaW5hbCgpIHtcbiAgICAgICAgICAgIGlmIChoYXNGdW5jdGlvbikge1xuICAgICAgICAgICAgICBhd2FpdCBmaW5pc2hlZDtcbiAgICAgICAgICAgICAgdWkuZG9uZSgpO1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGhhbmRsZVJlbmRlcih7IGNvbnRlbnQsIGRvbmU6IHRydWUgfSwgdGV4dCwgdWkpO1xuICAgICAgICAgICAgYXdhaXQgZmluaXNoZWQ7XG4gICAgICAgICAgICB1aS5kb25lKCk7XG4gICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICAgICksXG4gICAgKTtcbiAgfSkoKTtcblxuICByZXR1cm4gdWkudmFsdWU7XG59XG4iLCJpbXBvcnQge1xuICBjcmVhdGVQYXJzZXIsXG4gIHR5cGUgRXZlbnRTb3VyY2VQYXJzZXIsXG4gIHR5cGUgUGFyc2VkRXZlbnQsXG4gIHR5cGUgUmVjb25uZWN0SW50ZXJ2YWwsXG59IGZyb20gJ2V2ZW50c291cmNlLXBhcnNlcic7XG5pbXBvcnQgeyBPcGVuQUlTdHJlYW1DYWxsYmFja3MgfSBmcm9tICcuL29wZW5haS1zdHJlYW0nO1xuXG5leHBvcnQgaW50ZXJmYWNlIEZ1bmN0aW9uQ2FsbFBheWxvYWQge1xuICBuYW1lOiBzdHJpbmc7XG4gIGFyZ3VtZW50czogUmVjb3JkPHN0cmluZywgdW5rbm93bj47XG59XG5leHBvcnQgaW50ZXJmYWNlIFRvb2xDYWxsUGF5bG9hZCB7XG4gIHRvb2xzOiB7XG4gICAgaWQ6IHN0cmluZztcbiAgICB0eXBlOiAnZnVuY3Rpb24nO1xuICAgIGZ1bmM6IHtcbiAgICAgIG5hbWU6IHN0cmluZztcbiAgICAgIGFyZ3VtZW50czogUmVjb3JkPHN0cmluZywgdW5rbm93bj47XG4gICAgfTtcbiAgfVtdO1xufVxuXG4vKipcbiAqIENvbmZpZ3VyYXRpb24gb3B0aW9ucyBhbmQgaGVscGVyIGNhbGxiYWNrIG1ldGhvZHMgZm9yIEFJU3RyZWFtIHN0cmVhbSBsaWZlY3ljbGUgZXZlbnRzLlxuICogQGludGVyZmFjZVxuICovXG5leHBvcnQgaW50ZXJmYWNlIEFJU3RyZWFtQ2FsbGJhY2tzQW5kT3B0aW9ucyB7XG4gIC8qKiBgb25TdGFydGA6IENhbGxlZCBvbmNlIHdoZW4gdGhlIHN0cmVhbSBpcyBpbml0aWFsaXplZC4gKi9cbiAgb25TdGFydD86ICgpID0+IFByb21pc2U8dm9pZD4gfCB2b2lkO1xuICAvKiogYG9uQ29tcGxldGlvbmA6IENhbGxlZCBmb3IgZWFjaCB0b2tlbml6ZWQgbWVzc2FnZS4gKi9cbiAgb25Db21wbGV0aW9uPzogKGNvbXBsZXRpb246IHN0cmluZykgPT4gUHJvbWlzZTx2b2lkPiB8IHZvaWQ7XG4gIC8qKiBgb25GaW5hbGA6IENhbGxlZCBvbmNlIHdoZW4gdGhlIHN0cmVhbSBpcyBjbG9zZWQgd2l0aCB0aGUgZmluYWwgY29tcGxldGlvbiBtZXNzYWdlLiAqL1xuICBvbkZpbmFsPzogKGNvbXBsZXRpb246IHN0cmluZykgPT4gUHJvbWlzZTx2b2lkPiB8IHZvaWQ7XG4gIC8qKiBgb25Ub2tlbmA6IENhbGxlZCBmb3IgZWFjaCB0b2tlbml6ZWQgbWVzc2FnZS4gKi9cbiAgb25Ub2tlbj86ICh0b2tlbjogc3RyaW5nKSA9PiBQcm9taXNlPHZvaWQ+IHwgdm9pZDtcbiAgLyoqIGBvblRleHRgOiBDYWxsZWQgZm9yIGVhY2ggdGV4dCBjaHVuay4gKi9cbiAgb25UZXh0PzogKHRleHQ6IHN0cmluZykgPT4gUHJvbWlzZTx2b2lkPiB8IHZvaWQ7XG4gIC8qKlxuICAgKiBAZGVwcmVjYXRlZCBUaGlzIGZsYWcgaXMgbm8gbG9uZ2VyIHVzZWQgYW5kIG9ubHkgcmV0YWluZWQgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5LlxuICAgKiBZb3UgY2FuIHJlbW92ZSBpdCBmcm9tIHlvdXIgY29kZS5cbiAgICovXG4gIGV4cGVyaW1lbnRhbF9zdHJlYW1EYXRhPzogYm9vbGVhbjtcbn1cblxuLyoqXG4gKiBPcHRpb25zIGZvciB0aGUgQUlTdHJlYW1QYXJzZXIuXG4gKiBAaW50ZXJmYWNlXG4gKiBAcHJvcGVydHkge3N0cmluZ30gZXZlbnQgLSBUaGUgZXZlbnQgKHR5cGUpIGZyb20gdGhlIHNlcnZlciBzaWRlIGV2ZW50IHN0cmVhbS5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBBSVN0cmVhbVBhcnNlck9wdGlvbnMge1xuICBldmVudD86IHN0cmluZztcbn1cblxuLyoqXG4gKiBDdXN0b20gcGFyc2VyIGZvciBBSVN0cmVhbSBkYXRhLlxuICogQGludGVyZmFjZVxuICogQHBhcmFtIHtzdHJpbmd9IGRhdGEgLSBUaGUgZGF0YSB0byBiZSBwYXJzZWQuXG4gKiBAcGFyYW0ge0FJU3RyZWFtUGFyc2VyT3B0aW9uc30gb3B0aW9ucyAtIFRoZSBvcHRpb25zIGZvciB0aGUgcGFyc2VyLlxuICogQHJldHVybnMge3N0cmluZyB8IHZvaWR9IFRoZSBwYXJzZWQgZGF0YSBvciB2b2lkLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIEFJU3RyZWFtUGFyc2VyIHtcbiAgKGRhdGE6IHN0cmluZywgb3B0aW9uczogQUlTdHJlYW1QYXJzZXJPcHRpb25zKTpcbiAgICB8IHN0cmluZ1xuICAgIHwgdm9pZFxuICAgIHwgeyBpc1RleHQ6IGZhbHNlOyBjb250ZW50OiBzdHJpbmcgfTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgVHJhbnNmb3JtU3RyZWFtIHRoYXQgcGFyc2VzIGV2ZW50cyBmcm9tIGFuIEV2ZW50U291cmNlIHN0cmVhbSB1c2luZyBhIGN1c3RvbSBwYXJzZXIuXG4gKiBAcGFyYW0ge0FJU3RyZWFtUGFyc2VyfSBjdXN0b21QYXJzZXIgLSBGdW5jdGlvbiB0byBoYW5kbGUgZXZlbnQgZGF0YS5cbiAqIEByZXR1cm5zIHtUcmFuc2Zvcm1TdHJlYW08VWludDhBcnJheSwgc3RyaW5nPn0gVHJhbnNmb3JtU3RyZWFtIHBhcnNpbmcgZXZlbnRzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlRXZlbnRTdHJlYW1UcmFuc2Zvcm1lcihcbiAgY3VzdG9tUGFyc2VyPzogQUlTdHJlYW1QYXJzZXIsXG4pOiBUcmFuc2Zvcm1TdHJlYW08VWludDhBcnJheSwgc3RyaW5nIHwgeyBpc1RleHQ6IGZhbHNlOyBjb250ZW50OiBzdHJpbmcgfT4ge1xuICBjb25zdCB0ZXh0RGVjb2RlciA9IG5ldyBUZXh0RGVjb2RlcigpO1xuICBsZXQgZXZlbnRTb3VyY2VQYXJzZXI6IEV2ZW50U291cmNlUGFyc2VyO1xuXG4gIHJldHVybiBuZXcgVHJhbnNmb3JtU3RyZWFtKHtcbiAgICBhc3luYyBzdGFydChjb250cm9sbGVyKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgICBldmVudFNvdXJjZVBhcnNlciA9IGNyZWF0ZVBhcnNlcihcbiAgICAgICAgKGV2ZW50OiBQYXJzZWRFdmVudCB8IFJlY29ubmVjdEludGVydmFsKSA9PiB7XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgKCdkYXRhJyBpbiBldmVudCAmJlxuICAgICAgICAgICAgICBldmVudC50eXBlID09PSAnZXZlbnQnICYmXG4gICAgICAgICAgICAgIGV2ZW50LmRhdGEgPT09ICdbRE9ORV0nKSB8fFxuICAgICAgICAgICAgLy8gUmVwbGljYXRlIGRvZXNuJ3Qgc2VuZCBbRE9ORV0gYnV0IGRvZXMgc2VuZCBhICdkb25lJyBldmVudFxuICAgICAgICAgICAgLy8gQHNlZSBodHRwczovL3JlcGxpY2F0ZS5jb20vZG9jcy9zdHJlYW1pbmdcbiAgICAgICAgICAgIChldmVudCBhcyBhbnkpLmV2ZW50ID09PSAnZG9uZSdcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIGNvbnRyb2xsZXIudGVybWluYXRlKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKCdkYXRhJyBpbiBldmVudCkge1xuICAgICAgICAgICAgY29uc3QgcGFyc2VkTWVzc2FnZSA9IGN1c3RvbVBhcnNlclxuICAgICAgICAgICAgICA/IGN1c3RvbVBhcnNlcihldmVudC5kYXRhLCB7XG4gICAgICAgICAgICAgICAgICBldmVudDogZXZlbnQuZXZlbnQsXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgOiBldmVudC5kYXRhO1xuICAgICAgICAgICAgaWYgKHBhcnNlZE1lc3NhZ2UpIGNvbnRyb2xsZXIuZW5xdWV1ZShwYXJzZWRNZXNzYWdlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICApO1xuICAgIH0sXG5cbiAgICB0cmFuc2Zvcm0oY2h1bmspIHtcbiAgICAgIGV2ZW50U291cmNlUGFyc2VyLmZlZWQodGV4dERlY29kZXIuZGVjb2RlKGNodW5rKSk7XG4gICAgfSxcbiAgfSk7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIHRyYW5zZm9ybSBzdHJlYW0gdGhhdCBlbmNvZGVzIGlucHV0IG1lc3NhZ2VzIGFuZCBpbnZva2VzIG9wdGlvbmFsIGNhbGxiYWNrIGZ1bmN0aW9ucy5cbiAqIFRoZSB0cmFuc2Zvcm0gc3RyZWFtIHVzZXMgdGhlIHByb3ZpZGVkIGNhbGxiYWNrcyB0byBleGVjdXRlIGN1c3RvbSBsb2dpYyBhdCBkaWZmZXJlbnQgc3RhZ2VzIG9mIHRoZSBzdHJlYW0ncyBsaWZlY3ljbGUuXG4gKiAtIGBvblN0YXJ0YDogQ2FsbGVkIG9uY2Ugd2hlbiB0aGUgc3RyZWFtIGlzIGluaXRpYWxpemVkLlxuICogLSBgb25Ub2tlbmA6IENhbGxlZCBmb3IgZWFjaCB0b2tlbml6ZWQgbWVzc2FnZS5cbiAqIC0gYG9uQ29tcGxldGlvbmA6IENhbGxlZCBldmVyeSB0aW1lIGFuIEFJU3RyZWFtIGNvbXBsZXRpb24gbWVzc2FnZSBpcyByZWNlaXZlZC4gVGhpcyBjYW4gb2NjdXIgbXVsdGlwbGUgdGltZXMgd2hlbiB1c2luZyBlLmcuIE9wZW5BSSBmdW5jdGlvbnNcbiAqIC0gYG9uRmluYWxgOiBDYWxsZWQgb25jZSB3aGVuIHRoZSBzdHJlYW0gaXMgY2xvc2VkIHdpdGggdGhlIGZpbmFsIGNvbXBsZXRpb24gbWVzc2FnZS5cbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIGlzIHVzZWZ1bCB3aGVuIHlvdSB3YW50IHRvIHByb2Nlc3MgYSBzdHJlYW0gb2YgbWVzc2FnZXMgYW5kIHBlcmZvcm0gc3BlY2lmaWMgYWN0aW9ucyBkdXJpbmcgdGhlIHN0cmVhbSdzIGxpZmVjeWNsZS5cbiAqXG4gKiBAcGFyYW0ge0FJU3RyZWFtQ2FsbGJhY2tzQW5kT3B0aW9uc30gW2NhbGxiYWNrc10gLSBBbiBvYmplY3QgY29udGFpbmluZyB0aGUgY2FsbGJhY2sgZnVuY3Rpb25zLlxuICogQHJldHVybiB7VHJhbnNmb3JtU3RyZWFtPHN0cmluZywgVWludDhBcnJheT59IEEgdHJhbnNmb3JtIHN0cmVhbSB0aGF0IGVuY29kZXMgaW5wdXQgbWVzc2FnZXMgYXMgVWludDhBcnJheSBhbmQgYWxsb3dzIHRoZSBleGVjdXRpb24gb2YgY3VzdG9tIGxvZ2ljIHRocm91Z2ggY2FsbGJhY2tzLlxuICpcbiAqIEBleGFtcGxlXG4gKiBjb25zdCBjYWxsYmFja3MgPSB7XG4gKiAgIG9uU3RhcnQ6IGFzeW5jICgpID0+IGNvbnNvbGUubG9nKCdTdHJlYW0gc3RhcnRlZCcpLFxuICogICBvblRva2VuOiBhc3luYyAodG9rZW4pID0+IGNvbnNvbGUubG9nKGBUb2tlbjogJHt0b2tlbn1gKSxcbiAqICAgb25Db21wbGV0aW9uOiBhc3luYyAoY29tcGxldGlvbikgPT4gY29uc29sZS5sb2coYENvbXBsZXRpb246ICR7Y29tcGxldGlvbn1gKVxuICogICBvbkZpbmFsOiBhc3luYyAoKSA9PiBkYXRhLmNsb3NlKClcbiAqIH07XG4gKiBjb25zdCB0cmFuc2Zvcm1lciA9IGNyZWF0ZUNhbGxiYWNrc1RyYW5zZm9ybWVyKGNhbGxiYWNrcyk7XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVDYWxsYmFja3NUcmFuc2Zvcm1lcihcbiAgY2I6IEFJU3RyZWFtQ2FsbGJhY2tzQW5kT3B0aW9ucyB8IE9wZW5BSVN0cmVhbUNhbGxiYWNrcyB8IHVuZGVmaW5lZCxcbik6IFRyYW5zZm9ybVN0cmVhbTxzdHJpbmcgfCB7IGlzVGV4dDogZmFsc2U7IGNvbnRlbnQ6IHN0cmluZyB9LCBVaW50OEFycmF5PiB7XG4gIGNvbnN0IHRleHRFbmNvZGVyID0gbmV3IFRleHRFbmNvZGVyKCk7XG4gIGxldCBhZ2dyZWdhdGVkUmVzcG9uc2UgPSAnJztcbiAgY29uc3QgY2FsbGJhY2tzID0gY2IgfHwge307XG5cbiAgcmV0dXJuIG5ldyBUcmFuc2Zvcm1TdHJlYW0oe1xuICAgIGFzeW5jIHN0YXJ0KCk6IFByb21pc2U8dm9pZD4ge1xuICAgICAgaWYgKGNhbGxiYWNrcy5vblN0YXJ0KSBhd2FpdCBjYWxsYmFja3Mub25TdGFydCgpO1xuICAgIH0sXG5cbiAgICBhc3luYyB0cmFuc2Zvcm0obWVzc2FnZSwgY29udHJvbGxlcik6IFByb21pc2U8dm9pZD4ge1xuICAgICAgY29uc3QgY29udGVudCA9IHR5cGVvZiBtZXNzYWdlID09PSAnc3RyaW5nJyA/IG1lc3NhZ2UgOiBtZXNzYWdlLmNvbnRlbnQ7XG5cbiAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZSh0ZXh0RW5jb2Rlci5lbmNvZGUoY29udGVudCkpO1xuXG4gICAgICBhZ2dyZWdhdGVkUmVzcG9uc2UgKz0gY29udGVudDtcblxuICAgICAgaWYgKGNhbGxiYWNrcy5vblRva2VuKSBhd2FpdCBjYWxsYmFja3Mub25Ub2tlbihjb250ZW50KTtcbiAgICAgIGlmIChjYWxsYmFja3Mub25UZXh0ICYmIHR5cGVvZiBtZXNzYWdlID09PSAnc3RyaW5nJykge1xuICAgICAgICBhd2FpdCBjYWxsYmFja3Mub25UZXh0KG1lc3NhZ2UpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBhc3luYyBmbHVzaCgpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICAgIGNvbnN0IGlzT3BlbkFJQ2FsbGJhY2tzID0gaXNPZlR5cGVPcGVuQUlTdHJlYW1DYWxsYmFja3MoY2FsbGJhY2tzKTtcbiAgICAgIC8vIElmIGl0J3MgT3BlbkFJQ2FsbGJhY2tzLCBpdCBoYXMgYW4gZXhwZXJpbWVudGFsX29uRnVuY3Rpb25DYWxsIHdoaWNoIG1lYW5zIHRoYXQgdGhlIGNyZWF0ZUZ1bmN0aW9uQ2FsbFRyYW5zZm9ybWVyXG4gICAgICAvLyB3aWxsIGhhbmRsZSBjYWxsaW5nIG9uQ29tcGxldGUuXG4gICAgICBpZiAoY2FsbGJhY2tzLm9uQ29tcGxldGlvbikge1xuICAgICAgICBhd2FpdCBjYWxsYmFja3Mub25Db21wbGV0aW9uKGFnZ3JlZ2F0ZWRSZXNwb25zZSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChjYWxsYmFja3Mub25GaW5hbCAmJiAhaXNPcGVuQUlDYWxsYmFja3MpIHtcbiAgICAgICAgYXdhaXQgY2FsbGJhY2tzLm9uRmluYWwoYWdncmVnYXRlZFJlc3BvbnNlKTtcbiAgICAgIH1cbiAgICB9LFxuICB9KTtcbn1cblxuZnVuY3Rpb24gaXNPZlR5cGVPcGVuQUlTdHJlYW1DYWxsYmFja3MoXG4gIGNhbGxiYWNrczogQUlTdHJlYW1DYWxsYmFja3NBbmRPcHRpb25zIHwgT3BlbkFJU3RyZWFtQ2FsbGJhY2tzLFxuKTogY2FsbGJhY2tzIGlzIE9wZW5BSVN0cmVhbUNhbGxiYWNrcyB7XG4gIHJldHVybiAnZXhwZXJpbWVudGFsX29uRnVuY3Rpb25DYWxsJyBpbiBjYWxsYmFja3M7XG59XG4vKipcbiAqIFJldHVybnMgYSBzdGF0ZWZ1bCBmdW5jdGlvbiB0aGF0LCB3aGVuIGludm9rZWQsIHRyaW1zIGxlYWRpbmcgd2hpdGVzcGFjZVxuICogZnJvbSB0aGUgaW5wdXQgdGV4dC4gVGhlIHRyaW1taW5nIG9ubHkgb2NjdXJzIG9uIHRoZSBmaXJzdCBpbnZvY2F0aW9uLCBlbnN1cmluZyB0aGF0XG4gKiBzdWJzZXF1ZW50IGNhbGxzIGRvIG5vdCBhbHRlciB0aGUgaW5wdXQgdGV4dC4gVGhpcyBpcyBwYXJ0aWN1bGFybHkgdXNlZnVsIGluIHNjZW5hcmlvc1xuICogd2hlcmUgYSB0ZXh0IHN0cmVhbSBpcyBiZWluZyBwcm9jZXNzZWQgYW5kIG9ubHkgdGhlIGluaXRpYWwgd2hpdGVzcGFjZSBzaG91bGQgYmUgcmVtb3ZlZC5cbiAqXG4gKiBAcmV0dXJuIHtmdW5jdGlvbihzdHJpbmcpOiBzdHJpbmd9IEEgZnVuY3Rpb24gdGhhdCB0YWtlcyBhIHN0cmluZyBhcyBpbnB1dCBhbmQgcmV0dXJucyBhIHN0cmluZ1xuICogd2l0aCBsZWFkaW5nIHdoaXRlc3BhY2UgcmVtb3ZlZCBpZiBpdCBpcyB0aGUgZmlyc3QgaW52b2NhdGlvbjsgb3RoZXJ3aXNlLCBpdCByZXR1cm5zIHRoZSBpbnB1dCB1bmNoYW5nZWQuXG4gKlxuICogQGV4YW1wbGVcbiAqIGNvbnN0IHRyaW1TdGFydCA9IHRyaW1TdGFydE9mU3RyZWFtSGVscGVyKCk7XG4gKiBjb25zdCBvdXRwdXQxID0gdHJpbVN0YXJ0KFwiICAgdGV4dFwiKTsgLy8gXCJ0ZXh0XCJcbiAqIGNvbnN0IG91dHB1dDIgPSB0cmltU3RhcnQoXCIgICB0ZXh0XCIpOyAvLyBcIiAgIHRleHRcIlxuICpcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRyaW1TdGFydE9mU3RyZWFtSGVscGVyKCk6ICh0ZXh0OiBzdHJpbmcpID0+IHN0cmluZyB7XG4gIGxldCBpc1N0cmVhbVN0YXJ0ID0gdHJ1ZTtcblxuICByZXR1cm4gKHRleHQ6IHN0cmluZyk6IHN0cmluZyA9PiB7XG4gICAgaWYgKGlzU3RyZWFtU3RhcnQpIHtcbiAgICAgIHRleHQgPSB0ZXh0LnRyaW1TdGFydCgpO1xuICAgICAgaWYgKHRleHQpIGlzU3RyZWFtU3RhcnQgPSBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRleHQ7XG4gIH07XG59XG5cbi8qKlxuICogUmV0dXJucyBhIFJlYWRhYmxlU3RyZWFtIGNyZWF0ZWQgZnJvbSB0aGUgcmVzcG9uc2UsIHBhcnNlZCBhbmQgaGFuZGxlZCB3aXRoIGN1c3RvbSBsb2dpYy5cbiAqIFRoZSBzdHJlYW0gZ29lcyB0aHJvdWdoIHR3byB0cmFuc2Zvcm1hdGlvbiBzdGFnZXMsIGZpcnN0IHBhcnNpbmcgdGhlIGV2ZW50cyBhbmQgdGhlblxuICogaW52b2tpbmcgdGhlIHByb3ZpZGVkIGNhbGxiYWNrcy5cbiAqXG4gKiBGb3IgMnh4IEhUVFAgcmVzcG9uc2VzOlxuICogLSBUaGUgZnVuY3Rpb24gY29udGludWVzIHdpdGggc3RhbmRhcmQgc3RyZWFtIHByb2Nlc3NpbmcuXG4gKlxuICogRm9yIG5vbi0yeHggSFRUUCByZXNwb25zZXM6XG4gKiAtIElmIHRoZSByZXNwb25zZSBib2R5IGlzIGRlZmluZWQsIGl0IGFzeW5jaHJvbm91c2x5IGV4dHJhY3RzIGFuZCBkZWNvZGVzIHRoZSByZXNwb25zZSBib2R5LlxuICogLSBJdCB0aGVuIGNyZWF0ZXMgYSBjdXN0b20gUmVhZGFibGVTdHJlYW0gdG8gcHJvcGFnYXRlIGEgZGV0YWlsZWQgZXJyb3IgbWVzc2FnZS5cbiAqXG4gKiBAcGFyYW0ge1Jlc3BvbnNlfSByZXNwb25zZSAtIFRoZSByZXNwb25zZS5cbiAqIEBwYXJhbSB7QUlTdHJlYW1QYXJzZXJ9IGN1c3RvbVBhcnNlciAtIFRoZSBjdXN0b20gcGFyc2VyIGZ1bmN0aW9uLlxuICogQHBhcmFtIHtBSVN0cmVhbUNhbGxiYWNrc0FuZE9wdGlvbnN9IGNhbGxiYWNrcyAtIFRoZSBjYWxsYmFja3MuXG4gKiBAcmV0dXJuIHtSZWFkYWJsZVN0cmVhbX0gVGhlIEFJU3RyZWFtLlxuICogQHRocm93cyBXaWxsIHRocm93IGFuIGVycm9yIGlmIHRoZSByZXNwb25zZSBpcyBub3QgT0suXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBBSVN0cmVhbShcbiAgcmVzcG9uc2U6IFJlc3BvbnNlLFxuICBjdXN0b21QYXJzZXI/OiBBSVN0cmVhbVBhcnNlcixcbiAgY2FsbGJhY2tzPzogQUlTdHJlYW1DYWxsYmFja3NBbmRPcHRpb25zLFxuKTogUmVhZGFibGVTdHJlYW08VWludDhBcnJheT4ge1xuICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgaWYgKHJlc3BvbnNlLmJvZHkpIHtcbiAgICAgIGNvbnN0IHJlYWRlciA9IHJlc3BvbnNlLmJvZHkuZ2V0UmVhZGVyKCk7XG4gICAgICByZXR1cm4gbmV3IFJlYWRhYmxlU3RyZWFtKHtcbiAgICAgICAgYXN5bmMgc3RhcnQoY29udHJvbGxlcikge1xuICAgICAgICAgIGNvbnN0IHsgZG9uZSwgdmFsdWUgfSA9IGF3YWl0IHJlYWRlci5yZWFkKCk7XG4gICAgICAgICAgaWYgKCFkb25lKSB7XG4gICAgICAgICAgICBjb25zdCBlcnJvclRleHQgPSBuZXcgVGV4dERlY29kZXIoKS5kZWNvZGUodmFsdWUpO1xuICAgICAgICAgICAgY29udHJvbGxlci5lcnJvcihuZXcgRXJyb3IoYFJlc3BvbnNlIGVycm9yOiAke2Vycm9yVGV4dH1gKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBuZXcgUmVhZGFibGVTdHJlYW0oe1xuICAgICAgICBzdGFydChjb250cm9sbGVyKSB7XG4gICAgICAgICAgY29udHJvbGxlci5lcnJvcihuZXcgRXJyb3IoJ1Jlc3BvbnNlIGVycm9yOiBObyByZXNwb25zZSBib2R5JykpO1xuICAgICAgICB9LFxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgY29uc3QgcmVzcG9uc2VCb2R5U3RyZWFtID0gcmVzcG9uc2UuYm9keSB8fCBjcmVhdGVFbXB0eVJlYWRhYmxlU3RyZWFtKCk7XG5cbiAgcmV0dXJuIHJlc3BvbnNlQm9keVN0cmVhbVxuICAgIC5waXBlVGhyb3VnaChjcmVhdGVFdmVudFN0cmVhbVRyYW5zZm9ybWVyKGN1c3RvbVBhcnNlcikpXG4gICAgLnBpcGVUaHJvdWdoKGNyZWF0ZUNhbGxiYWNrc1RyYW5zZm9ybWVyKGNhbGxiYWNrcykpO1xufVxuXG4vLyBvdXRwdXRzIGxpbmVzIGxpa2Vcbi8vIDA6IGNodW5rXG4vLyAwOiBtb3JlIGNodW5rXG4vLyAxOiBhIGZjdCBjYWxsXG4vLyB6OiBhZGRlZCBkYXRhIGZyb20gRGF0YVxuXG4vKipcbiAqIENyZWF0ZXMgYW4gZW1wdHkgUmVhZGFibGVTdHJlYW0gdGhhdCBpbW1lZGlhdGVseSBjbG9zZXMgdXBvbiBjcmVhdGlvbi5cbiAqIFRoaXMgZnVuY3Rpb24gaXMgdXNlZCBhcyBhIGZhbGxiYWNrIGZvciBjcmVhdGluZyBhIFJlYWRhYmxlU3RyZWFtIHdoZW4gdGhlIHJlc3BvbnNlIGJvZHkgaXMgbnVsbCBvciB1bmRlZmluZWQsXG4gKiBlbnN1cmluZyB0aGF0IHRoZSBzdWJzZXF1ZW50IHBpcGVsaW5lIHByb2Nlc3NpbmcgZG9lc24ndCBmYWlsIGR1ZSB0byBhIGxhY2sgb2YgYSBzdHJlYW0uXG4gKlxuICogQHJldHVybnMge1JlYWRhYmxlU3RyZWFtfSBBbiBlbXB0eSBhbmQgY2xvc2VkIFJlYWRhYmxlU3RyZWFtIGluc3RhbmNlLlxuICovXG5mdW5jdGlvbiBjcmVhdGVFbXB0eVJlYWRhYmxlU3RyZWFtKCk6IFJlYWRhYmxlU3RyZWFtIHtcbiAgcmV0dXJuIG5ldyBSZWFkYWJsZVN0cmVhbSh7XG4gICAgc3RhcnQoY29udHJvbGxlcikge1xuICAgICAgY29udHJvbGxlci5jbG9zZSgpO1xuICAgIH0sXG4gIH0pO1xufVxuXG4vKipcbiAqIEltcGxlbWVudHMgUmVhZGFibGVTdHJlYW0uZnJvbShhc3luY0l0ZXJhYmxlKSwgd2hpY2ggaXNuJ3QgZG9jdW1lbnRlZCBpbiBNRE4gYW5kIGlzbid0IGltcGxlbWVudGVkIGluIG5vZGUuXG4gKiBodHRwczovL2dpdGh1Yi5jb20vd2hhdHdnL3N0cmVhbXMvY29tbWl0LzhkN2EwYmYyNmViMmNjMjNlODg0ZGRiYWFjN2MxZGE0YjkxY2YyYmNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlYWRhYmxlRnJvbUFzeW5jSXRlcmFibGU8VD4oaXRlcmFibGU6IEFzeW5jSXRlcmFibGU8VD4pIHtcbiAgbGV0IGl0ID0gaXRlcmFibGVbU3ltYm9sLmFzeW5jSXRlcmF0b3JdKCk7XG4gIHJldHVybiBuZXcgUmVhZGFibGVTdHJlYW08VD4oe1xuICAgIGFzeW5jIHB1bGwoY29udHJvbGxlcikge1xuICAgICAgY29uc3QgeyBkb25lLCB2YWx1ZSB9ID0gYXdhaXQgaXQubmV4dCgpO1xuICAgICAgaWYgKGRvbmUpIGNvbnRyb2xsZXIuY2xvc2UoKTtcbiAgICAgIGVsc2UgY29udHJvbGxlci5lbnF1ZXVlKHZhbHVlKTtcbiAgICB9LFxuXG4gICAgYXN5bmMgY2FuY2VsKHJlYXNvbikge1xuICAgICAgYXdhaXQgaXQucmV0dXJuPy4ocmVhc29uKTtcbiAgICB9LFxuICB9KTtcbn1cbiIsImltcG9ydCB7IEpTT05WYWx1ZSwgZm9ybWF0U3RyZWFtUGFydCB9IGZyb20gJ0BhaS1zZGsvdWktdXRpbHMnO1xuaW1wb3J0IHsgSEFOR0lOR19TVFJFQU1fV0FSTklOR19USU1FX01TIH0gZnJvbSAnLi4vdXRpbC9jb25zdGFudHMnO1xuXG4vKipcbiAqIEEgc3RyZWFtIHdyYXBwZXIgdG8gc2VuZCBjdXN0b20gSlNPTi1lbmNvZGVkIGRhdGEgYmFjayB0byB0aGUgY2xpZW50LlxuICovXG5leHBvcnQgY2xhc3MgU3RyZWFtRGF0YSB7XG4gIHByaXZhdGUgZW5jb2RlciA9IG5ldyBUZXh0RW5jb2RlcigpO1xuXG4gIHByaXZhdGUgY29udHJvbGxlcjogUmVhZGFibGVTdHJlYW1Db250cm9sbGVyPFVpbnQ4QXJyYXk+IHwgbnVsbCA9IG51bGw7XG4gIHB1YmxpYyBzdHJlYW06IFJlYWRhYmxlU3RyZWFtPFVpbnQ4QXJyYXk+O1xuXG4gIHByaXZhdGUgaXNDbG9zZWQ6IGJvb2xlYW4gPSBmYWxzZTtcbiAgcHJpdmF0ZSB3YXJuaW5nVGltZW91dDogTm9kZUpTLlRpbWVvdXQgfCBudWxsID0gbnVsbDtcblxuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBjb25zdCBzZWxmID0gdGhpcztcblxuICAgIHRoaXMuc3RyZWFtID0gbmV3IFJlYWRhYmxlU3RyZWFtKHtcbiAgICAgIHN0YXJ0OiBhc3luYyBjb250cm9sbGVyID0+IHtcbiAgICAgICAgc2VsZi5jb250cm9sbGVyID0gY29udHJvbGxlcjtcblxuICAgICAgICAvLyBTZXQgYSB0aW1lb3V0IHRvIHNob3cgYSB3YXJuaW5nIGlmIHRoZSBzdHJlYW0gaXMgbm90IGNsb3NlZCB3aXRoaW4gMyBzZWNvbmRzXG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50Jykge1xuICAgICAgICAgIHNlbGYud2FybmluZ1RpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICAgICAgJ1RoZSBkYXRhIHN0cmVhbSBpcyBoYW5naW5nLiBEaWQgeW91IGZvcmdldCB0byBjbG9zZSBpdCB3aXRoIGBkYXRhLmNsb3NlKClgPycsXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH0sIEhBTkdJTkdfU1RSRUFNX1dBUk5JTkdfVElNRV9NUyk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBwdWxsOiBjb250cm9sbGVyID0+IHtcbiAgICAgICAgLy8gTm8tb3A6IHdlIGRvbid0IG5lZWQgdG8gZG8gYW55dGhpbmcgc3BlY2lhbCBvbiBwdWxsXG4gICAgICB9LFxuICAgICAgY2FuY2VsOiByZWFzb24gPT4ge1xuICAgICAgICB0aGlzLmlzQ2xvc2VkID0gdHJ1ZTtcbiAgICAgIH0sXG4gICAgfSk7XG4gIH1cblxuICBhc3luYyBjbG9zZSgpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBpZiAodGhpcy5pc0Nsb3NlZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdEYXRhIFN0cmVhbSBoYXMgYWxyZWFkeSBiZWVuIGNsb3NlZC4nKTtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuY29udHJvbGxlcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdTdHJlYW0gY29udHJvbGxlciBpcyBub3QgaW5pdGlhbGl6ZWQuJyk7XG4gICAgfVxuXG4gICAgdGhpcy5jb250cm9sbGVyLmNsb3NlKCk7XG4gICAgdGhpcy5pc0Nsb3NlZCA9IHRydWU7XG5cbiAgICAvLyBDbGVhciB0aGUgd2FybmluZyB0aW1lb3V0IGlmIHRoZSBzdHJlYW0gaXMgY2xvc2VkXG4gICAgaWYgKHRoaXMud2FybmluZ1RpbWVvdXQpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aGlzLndhcm5pbmdUaW1lb3V0KTtcbiAgICB9XG4gIH1cblxuICBhcHBlbmQodmFsdWU6IEpTT05WYWx1ZSk6IHZvaWQge1xuICAgIGlmICh0aGlzLmlzQ2xvc2VkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0RhdGEgU3RyZWFtIGhhcyBhbHJlYWR5IGJlZW4gY2xvc2VkLicpO1xuICAgIH1cblxuICAgIGlmICghdGhpcy5jb250cm9sbGVyKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1N0cmVhbSBjb250cm9sbGVyIGlzIG5vdCBpbml0aWFsaXplZC4nKTtcbiAgICB9XG5cbiAgICB0aGlzLmNvbnRyb2xsZXIuZW5xdWV1ZShcbiAgICAgIHRoaXMuZW5jb2Rlci5lbmNvZGUoZm9ybWF0U3RyZWFtUGFydCgnZGF0YScsIFt2YWx1ZV0pKSxcbiAgICApO1xuICB9XG5cbiAgYXBwZW5kTWVzc2FnZUFubm90YXRpb24odmFsdWU6IEpTT05WYWx1ZSk6IHZvaWQge1xuICAgIGlmICh0aGlzLmlzQ2xvc2VkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0RhdGEgU3RyZWFtIGhhcyBhbHJlYWR5IGJlZW4gY2xvc2VkLicpO1xuICAgIH1cblxuICAgIGlmICghdGhpcy5jb250cm9sbGVyKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1N0cmVhbSBjb250cm9sbGVyIGlzIG5vdCBpbml0aWFsaXplZC4nKTtcbiAgICB9XG5cbiAgICB0aGlzLmNvbnRyb2xsZXIuZW5xdWV1ZShcbiAgICAgIHRoaXMuZW5jb2Rlci5lbmNvZGUoZm9ybWF0U3RyZWFtUGFydCgnbWVzc2FnZV9hbm5vdGF0aW9ucycsIFt2YWx1ZV0pKSxcbiAgICApO1xuICB9XG59XG5cbi8qKlxuICogQSBUcmFuc2Zvcm1TdHJlYW0gZm9yIExMTXMgdGhhdCBkbyBub3QgaGF2ZSB0aGVpciBvd24gdHJhbnNmb3JtIHN0cmVhbSBoYW5kbGVycyBtYW5hZ2luZyBlbmNvZGluZyAoZS5nLiBPcGVuQUlTdHJlYW0gaGFzIG9uZSBmb3IgZnVuY3Rpb24gY2FsbCBoYW5kbGluZykuXG4gKiBUaGlzIGFzc3VtZXMgZXZlcnkgY2h1bmsgaXMgYSAndGV4dCcgY2h1bmsuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVTdHJlYW1EYXRhVHJhbnNmb3JtZXIoKSB7XG4gIGNvbnN0IGVuY29kZXIgPSBuZXcgVGV4dEVuY29kZXIoKTtcbiAgY29uc3QgZGVjb2RlciA9IG5ldyBUZXh0RGVjb2RlcigpO1xuICByZXR1cm4gbmV3IFRyYW5zZm9ybVN0cmVhbSh7XG4gICAgdHJhbnNmb3JtOiBhc3luYyAoY2h1bmssIGNvbnRyb2xsZXIpID0+IHtcbiAgICAgIGNvbnN0IG1lc3NhZ2UgPSBkZWNvZGVyLmRlY29kZShjaHVuayk7XG4gICAgICBjb250cm9sbGVyLmVucXVldWUoZW5jb2Rlci5lbmNvZGUoZm9ybWF0U3RyZWFtUGFydCgndGV4dCcsIG1lc3NhZ2UpKSk7XG4gICAgfSxcbiAgfSk7XG59XG5cbi8qKlxuQGRlcHJlY2F0ZWQgVXNlIGBTdHJlYW1EYXRhYCBpbnN0ZWFkLlxuICovXG5leHBvcnQgY2xhc3MgZXhwZXJpbWVudGFsX1N0cmVhbURhdGEgZXh0ZW5kcyBTdHJlYW1EYXRhIHt9XG4iLCJpbXBvcnQge1xuICBDcmVhdGVNZXNzYWdlLFxuICBGdW5jdGlvbkNhbGwsXG4gIEpTT05WYWx1ZSxcbiAgVG9vbENhbGwsXG4gIGNyZWF0ZUNodW5rRGVjb2RlcixcbiAgZm9ybWF0U3RyZWFtUGFydCxcbn0gZnJvbSAnQGFpLXNkay91aS11dGlscyc7XG5pbXBvcnQge1xuICBBSVN0cmVhbSxcbiAgRnVuY3Rpb25DYWxsUGF5bG9hZCxcbiAgVG9vbENhbGxQYXlsb2FkLFxuICBjcmVhdGVDYWxsYmFja3NUcmFuc2Zvcm1lcixcbiAgcmVhZGFibGVGcm9tQXN5bmNJdGVyYWJsZSxcbiAgdHJpbVN0YXJ0T2ZTdHJlYW1IZWxwZXIsXG4gIHR5cGUgQUlTdHJlYW1DYWxsYmFja3NBbmRPcHRpb25zLFxufSBmcm9tICcuL2FpLXN0cmVhbSc7XG5pbXBvcnQgeyBBenVyZUNoYXRDb21wbGV0aW9ucyB9IGZyb20gJy4vYXp1cmUtb3BlbmFpLXR5cGVzJztcbmltcG9ydCB7IGNyZWF0ZVN0cmVhbURhdGFUcmFuc2Zvcm1lciB9IGZyb20gJy4vc3RyZWFtLWRhdGEnO1xuXG5leHBvcnQgdHlwZSBPcGVuQUlTdHJlYW1DYWxsYmFja3MgPSBBSVN0cmVhbUNhbGxiYWNrc0FuZE9wdGlvbnMgJiB7XG4gIC8qKlxuICAgKiBAZXhhbXBsZVxuICAgKiBgYGBqc1xuICAgKiBjb25zdCByZXNwb25zZSA9IGF3YWl0IG9wZW5haS5jaGF0LmNvbXBsZXRpb25zLmNyZWF0ZSh7XG4gICAqICAgbW9kZWw6ICdncHQtMy41LXR1cmJvLTA2MTMnLFxuICAgKiAgIHN0cmVhbTogdHJ1ZSxcbiAgICogICBtZXNzYWdlcyxcbiAgICogICBmdW5jdGlvbnMsXG4gICAqIH0pXG4gICAqXG4gICAqIGNvbnN0IHN0cmVhbSA9IE9wZW5BSVN0cmVhbShyZXNwb25zZSwge1xuICAgKiAgIGV4cGVyaW1lbnRhbF9vbkZ1bmN0aW9uQ2FsbDogYXN5bmMgKGZ1bmN0aW9uQ2FsbFBheWxvYWQsIGNyZWF0ZUZ1bmN0aW9uQ2FsbE1lc3NhZ2VzKSA9PiB7XG4gICAqICAgICAvLyAuLi4gcnVuIHlvdXIgY3VzdG9tIGxvZ2ljIGhlcmVcbiAgICogICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IG15RnVuY3Rpb24oZnVuY3Rpb25DYWxsUGF5bG9hZClcbiAgICpcbiAgICogICAgIC8vIEFzayBmb3IgYW5vdGhlciBjb21wbGV0aW9uLCBvciByZXR1cm4gYSBzdHJpbmcgdG8gc2VuZCB0byB0aGUgY2xpZW50IGFzIGFuIGFzc2lzdGFudCBtZXNzYWdlLlxuICAgKiAgICAgcmV0dXJuIGF3YWl0IG9wZW5haS5jaGF0LmNvbXBsZXRpb25zLmNyZWF0ZSh7XG4gICAqICAgICAgIG1vZGVsOiAnZ3B0LTMuNS10dXJiby0wNjEzJyxcbiAgICogICAgICAgc3RyZWFtOiB0cnVlLFxuICAgKiAgICAgICAvLyBBcHBlbmQgdGhlIHJlbGV2YW50IFwiYXNzaXN0YW50XCIgYW5kIFwiZnVuY3Rpb25cIiBjYWxsIG1lc3NhZ2VzXG4gICAqICAgICAgIG1lc3NhZ2VzOiBbLi4ubWVzc2FnZXMsIC4uLmNyZWF0ZUZ1bmN0aW9uQ2FsbE1lc3NhZ2VzKHJlc3VsdCldLFxuICAgKiAgICAgICBmdW5jdGlvbnMsXG4gICAqICAgICB9KVxuICAgKiAgIH1cbiAgICogfSlcbiAgICogYGBgXG4gICAqL1xuICBleHBlcmltZW50YWxfb25GdW5jdGlvbkNhbGw/OiAoXG4gICAgZnVuY3Rpb25DYWxsUGF5bG9hZDogRnVuY3Rpb25DYWxsUGF5bG9hZCxcbiAgICBjcmVhdGVGdW5jdGlvbkNhbGxNZXNzYWdlczogKFxuICAgICAgZnVuY3Rpb25DYWxsUmVzdWx0OiBKU09OVmFsdWUsXG4gICAgKSA9PiBDcmVhdGVNZXNzYWdlW10sXG4gICkgPT4gUHJvbWlzZTxcbiAgICBSZXNwb25zZSB8IHVuZGVmaW5lZCB8IHZvaWQgfCBzdHJpbmcgfCBBc3luY0l0ZXJhYmxlT3BlbkFJU3RyZWFtUmV0dXJuVHlwZXNcbiAgPjtcbiAgLyoqXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYGpzXG4gICAqIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgb3BlbmFpLmNoYXQuY29tcGxldGlvbnMuY3JlYXRlKHtcbiAgICogICBtb2RlbDogJ2dwdC0zLjUtdHVyYm8tMTEwNicsIC8vIG9yIGdwdC00LTExMDYtcHJldmlld1xuICAgKiAgIHN0cmVhbTogdHJ1ZSxcbiAgICogICBtZXNzYWdlcyxcbiAgICogICB0b29scyxcbiAgICogICB0b29sX2Nob2ljZTogXCJhdXRvXCIsIC8vIGF1dG8gaXMgZGVmYXVsdCwgYnV0IHdlJ2xsIGJlIGV4cGxpY2l0XG4gICAqIH0pXG4gICAqXG4gICAqIGNvbnN0IHN0cmVhbSA9IE9wZW5BSVN0cmVhbShyZXNwb25zZSwge1xuICAgKiAgIGV4cGVyaW1lbnRhbF9vblRvb2xDYWxsOiBhc3luYyAodG9vbENhbGxQYXlsb2FkLCBhcHBlbmRUb29sQ2FsbE1lc3NhZ2VzKSA9PiB7XG4gICAqICAgIGxldCBtZXNzYWdlczogQ3JlYXRlTWVzc2FnZVtdID0gW11cbiAgICogICAgLy8gICBUaGVyZSBtaWdodCBiZSBtdWx0aXBsZSB0b29sIGNhbGxzLCBzbyB3ZSBuZWVkIHRvIGl0ZXJhdGUgdGhyb3VnaCB0aGVtXG4gICAqICAgIGZvciAoY29uc3QgdG9vbCBvZiB0b29sQ2FsbFBheWxvYWQudG9vbHMpIHtcbiAgICogICAgIC8vIC4uLiBydW4geW91ciBjdXN0b20gbG9naWMgaGVyZVxuICAgKiAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgbXlGdW5jdGlvbih0b29sLmZ1bmN0aW9uKVxuICAgKiAgICAvLyBBcHBlbmQgdGhlIHJlbGV2YW50IFwiYXNzaXN0YW50XCIgYW5kIFwidG9vbFwiIGNhbGwgbWVzc2FnZXNcbiAgICogICAgIGFwcGVuZFRvb2xDYWxsTWVzc2FnZSh7dG9vbF9jYWxsX2lkOnRvb2wuaWQsIGZ1bmN0aW9uX25hbWU6dG9vbC5mdW5jdGlvbi5uYW1lLCB0b29sX2NhbGxfcmVzdWx0OnJlc3VsdH0pXG4gICAqICAgIH1cbiAgICogICAgIC8vIEFzayBmb3IgYW5vdGhlciBjb21wbGV0aW9uLCBvciByZXR1cm4gYSBzdHJpbmcgdG8gc2VuZCB0byB0aGUgY2xpZW50IGFzIGFuIGFzc2lzdGFudCBtZXNzYWdlLlxuICAgKiAgICAgcmV0dXJuIGF3YWl0IG9wZW5haS5jaGF0LmNvbXBsZXRpb25zLmNyZWF0ZSh7XG4gICAqICAgICAgIG1vZGVsOiAnZ3B0LTMuNS10dXJiby0xMTA2JywgLy8gb3IgZ3B0LTQtMTEwNi1wcmV2aWV3XG4gICAqICAgICAgIHN0cmVhbTogdHJ1ZSxcbiAgICogICAgICAgLy8gQXBwZW5kIHRoZSByZXN1bHRzIG1lc3NhZ2VzLCBjYWxsaW5nIGFwcGVuZFRvb2xDYWxsTWVzc2FnZSB3aXRob3V0XG4gICAqICAgICAgIC8vIGFueSBhcmd1bWVudHMgd2lsbCBqc3V0IHJldHVybiB0aGUgYWNjdW11bGF0ZWQgbWVzc2FnZXNcbiAgICogICAgICAgbWVzc2FnZXM6IFsuLi5tZXNzYWdlcywgLi4uYXBwZW5kVG9vbENhbGxNZXNzYWdlKCldLFxuICAgKiAgICAgICB0b29scyxcbiAgICogICAgICAgIHRvb2xfY2hvaWNlOiBcImF1dG9cIiwgLy8gYXV0byBpcyBkZWZhdWx0LCBidXQgd2UnbGwgYmUgZXhwbGljaXRcbiAgICogICAgIH0pXG4gICAqICAgfVxuICAgKiB9KVxuICAgKiBgYGBcbiAgICovXG4gIGV4cGVyaW1lbnRhbF9vblRvb2xDYWxsPzogKFxuICAgIHRvb2xDYWxsUGF5bG9hZDogVG9vbENhbGxQYXlsb2FkLFxuICAgIGFwcGVuZFRvb2xDYWxsTWVzc2FnZTogKHJlc3VsdD86IHtcbiAgICAgIHRvb2xfY2FsbF9pZDogc3RyaW5nO1xuICAgICAgZnVuY3Rpb25fbmFtZTogc3RyaW5nO1xuICAgICAgdG9vbF9jYWxsX3Jlc3VsdDogSlNPTlZhbHVlO1xuICAgIH0pID0+IENyZWF0ZU1lc3NhZ2VbXSxcbiAgKSA9PiBQcm9taXNlPFxuICAgIFJlc3BvbnNlIHwgdW5kZWZpbmVkIHwgdm9pZCB8IHN0cmluZyB8IEFzeW5jSXRlcmFibGVPcGVuQUlTdHJlYW1SZXR1cm5UeXBlc1xuICA+O1xufTtcblxuLy8gaHR0cHM6Ly9naXRodWIuY29tL29wZW5haS9vcGVuYWktbm9kZS9ibG9iLzA3YjM1MDRlMWM0MGZkOTI5ZjRhYWUxNjUxYjgzYWZjMTllM2JhZjgvc3JjL3Jlc291cmNlcy9jaGF0L2NvbXBsZXRpb25zLnRzI0wyOC1MNDBcbmludGVyZmFjZSBDaGF0Q29tcGxldGlvbkNodW5rIHtcbiAgaWQ6IHN0cmluZztcbiAgY2hvaWNlczogQXJyYXk8Q2hhdENvbXBsZXRpb25DaHVua0Nob2ljZT47XG4gIGNyZWF0ZWQ6IG51bWJlcjtcbiAgbW9kZWw6IHN0cmluZztcbiAgb2JqZWN0OiBzdHJpbmc7XG59XG5cbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9vcGVuYWkvb3BlbmFpLW5vZGUvYmxvYi8wN2IzNTA0ZTFjNDBmZDkyOWY0YWFlMTY1MWI4M2FmYzE5ZTNiYWY4L3NyYy9yZXNvdXJjZXMvY2hhdC9jb21wbGV0aW9ucy50cyNMNDMtTDQ5XG4vLyBVcGRhdGVkIGZvciBodHRwczovL2dpdGh1Yi5jb20vb3BlbmFpL29wZW5haS1ub2RlL2NvbW1pdC9mMTBjNzU3ZDgzMWQ5MDQwN2JhNDdiNDY1OWQ5Y2QzNGIxYTM1YjFkXG4vLyBVcGRhdGVkIHRvIGh0dHBzOi8vZ2l0aHViLmNvbS9vcGVuYWkvb3BlbmFpLW5vZGUvY29tbWl0Lzg0YjQzMjgwMDg5ZWFjZGYxOGYxNzE3MjM1OTE4NTY4MTFiZWRkY2VcbmludGVyZmFjZSBDaGF0Q29tcGxldGlvbkNodW5rQ2hvaWNlIHtcbiAgZGVsdGE6IENob2ljZURlbHRhO1xuICBmaW5pc2hfcmVhc29uOlxuICAgIHwgJ3N0b3AnXG4gICAgfCAnbGVuZ3RoJ1xuICAgIHwgJ3Rvb2xfY2FsbHMnXG4gICAgfCAnY29udGVudF9maWx0ZXInXG4gICAgfCAnZnVuY3Rpb25fY2FsbCdcbiAgICB8IG51bGw7XG4gIGluZGV4OiBudW1iZXI7XG59XG5cbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9vcGVuYWkvb3BlbmFpLW5vZGUvYmxvYi8wN2IzNTA0ZTFjNDBmZDkyOWY0YWFlMTY1MWI4M2FmYzE5ZTNiYWY4L3NyYy9yZXNvdXJjZXMvY2hhdC9jb21wbGV0aW9ucy50cyNMMTIzLUwxMzlcbi8vIFVwZGF0ZWQgdG8gaHR0cHM6Ly9naXRodWIuY29tL29wZW5haS9vcGVuYWktbm9kZS9jb21taXQvODRiNDMyODAwODllYWNkZjE4ZjE3MTcyMzU5MTg1NjgxMWJlZGRjZVxuaW50ZXJmYWNlIENob2ljZURlbHRhIHtcbiAgLyoqXG4gICAqIFRoZSBjb250ZW50cyBvZiB0aGUgY2h1bmsgbWVzc2FnZS5cbiAgICovXG4gIGNvbnRlbnQ/OiBzdHJpbmcgfCBudWxsO1xuXG4gIC8qKlxuICAgKiBUaGUgbmFtZSBhbmQgYXJndW1lbnRzIG9mIGEgZnVuY3Rpb24gdGhhdCBzaG91bGQgYmUgY2FsbGVkLCBhcyBnZW5lcmF0ZWQgYnkgdGhlXG4gICAqIG1vZGVsLlxuICAgKi9cbiAgZnVuY3Rpb25fY2FsbD86IEZ1bmN0aW9uQ2FsbDtcblxuICAvKipcbiAgICogVGhlIHJvbGUgb2YgdGhlIGF1dGhvciBvZiB0aGlzIG1lc3NhZ2UuXG4gICAqL1xuICByb2xlPzogJ3N5c3RlbScgfCAndXNlcicgfCAnYXNzaXN0YW50JyB8ICd0b29sJztcblxuICB0b29sX2NhbGxzPzogQXJyYXk8RGVsdGFUb29sQ2FsbD47XG59XG5cbi8vIEZyb20gaHR0cHM6Ly9naXRodWIuY29tL29wZW5haS9vcGVuYWktbm9kZS9ibG9iL21hc3Rlci9zcmMvcmVzb3VyY2VzL2NoYXQvY29tcGxldGlvbnMudHNcbi8vIFVwZGF0ZWQgdG8gaHR0cHM6Ly9naXRodWIuY29tL29wZW5haS9vcGVuYWktbm9kZS9jb21taXQvODRiNDMyODAwODllYWNkZjE4ZjE3MTcyMzU5MTg1NjgxMWJlZGRjZVxuaW50ZXJmYWNlIERlbHRhVG9vbENhbGwge1xuICBpbmRleDogbnVtYmVyO1xuXG4gIC8qKlxuICAgKiBUaGUgSUQgb2YgdGhlIHRvb2wgY2FsbC5cbiAgICovXG4gIGlkPzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgZnVuY3Rpb24gdGhhdCB0aGUgbW9kZWwgY2FsbGVkLlxuICAgKi9cbiAgZnVuY3Rpb24/OiBUb29sQ2FsbEZ1bmN0aW9uO1xuXG4gIC8qKlxuICAgKiBUaGUgdHlwZSBvZiB0aGUgdG9vbC4gQ3VycmVudGx5LCBvbmx5IGBmdW5jdGlvbmAgaXMgc3VwcG9ydGVkLlxuICAgKi9cbiAgdHlwZT86ICdmdW5jdGlvbic7XG59XG5cbi8vIEZyb20gaHR0cHM6Ly9naXRodWIuY29tL29wZW5haS9vcGVuYWktbm9kZS9ibG9iL21hc3Rlci9zcmMvcmVzb3VyY2VzL2NoYXQvY29tcGxldGlvbnMudHNcbi8vIFVwZGF0ZWQgdG8gaHR0cHM6Ly9naXRodWIuY29tL29wZW5haS9vcGVuYWktbm9kZS9jb21taXQvODRiNDMyODAwODllYWNkZjE4ZjE3MTcyMzU5MTg1NjgxMWJlZGRjZVxuaW50ZXJmYWNlIFRvb2xDYWxsRnVuY3Rpb24ge1xuICAvKipcbiAgICogVGhlIGFyZ3VtZW50cyB0byBjYWxsIHRoZSBmdW5jdGlvbiB3aXRoLCBhcyBnZW5lcmF0ZWQgYnkgdGhlIG1vZGVsIGluIEpTT05cbiAgICogZm9ybWF0LiBOb3RlIHRoYXQgdGhlIG1vZGVsIGRvZXMgbm90IGFsd2F5cyBnZW5lcmF0ZSB2YWxpZCBKU09OLCBhbmQgbWF5XG4gICAqIGhhbGx1Y2luYXRlIHBhcmFtZXRlcnMgbm90IGRlZmluZWQgYnkgeW91ciBmdW5jdGlvbiBzY2hlbWEuIFZhbGlkYXRlIHRoZVxuICAgKiBhcmd1bWVudHMgaW4geW91ciBjb2RlIGJlZm9yZSBjYWxsaW5nIHlvdXIgZnVuY3Rpb24uXG4gICAqL1xuICBhcmd1bWVudHM/OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSBuYW1lIG9mIHRoZSBmdW5jdGlvbiB0byBjYWxsLlxuICAgKi9cbiAgbmFtZT86IHN0cmluZztcbn1cblxuLyoqXG4gKiBodHRwczovL2dpdGh1Yi5jb20vb3BlbmFpL29wZW5haS1ub2RlL2Jsb2IvM2VjNDNlZTc5MGEyZWI2YTBjY2RkNWYyNWZhYTIzMjUxYjBmOWI4ZS9zcmMvcmVzb3VyY2VzL2NvbXBsZXRpb25zLnRzI0wyOEMxLUw2NEMxXG4gKiBDb21wbGV0aW9ucyBBUEkuIFN0cmVhbWVkIGFuZCBub24tc3RyZWFtZWQgcmVzcG9uc2VzIGFyZSB0aGUgc2FtZS5cbiAqL1xuaW50ZXJmYWNlIENvbXBsZXRpb24ge1xuICAvKipcbiAgICogQSB1bmlxdWUgaWRlbnRpZmllciBmb3IgdGhlIGNvbXBsZXRpb24uXG4gICAqL1xuICBpZDogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgbGlzdCBvZiBjb21wbGV0aW9uIGNob2ljZXMgdGhlIG1vZGVsIGdlbmVyYXRlZCBmb3IgdGhlIGlucHV0IHByb21wdC5cbiAgICovXG4gIGNob2ljZXM6IEFycmF5PENvbXBsZXRpb25DaG9pY2U+O1xuXG4gIC8qKlxuICAgKiBUaGUgVW5peCB0aW1lc3RhbXAgb2Ygd2hlbiB0aGUgY29tcGxldGlvbiB3YXMgY3JlYXRlZC5cbiAgICovXG4gIGNyZWF0ZWQ6IG51bWJlcjtcblxuICAvKipcbiAgICogVGhlIG1vZGVsIHVzZWQgZm9yIGNvbXBsZXRpb24uXG4gICAqL1xuICBtb2RlbDogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgb2JqZWN0IHR5cGUsIHdoaWNoIGlzIGFsd2F5cyBcInRleHRfY29tcGxldGlvblwiXG4gICAqL1xuICBvYmplY3Q6IHN0cmluZztcblxuICAvKipcbiAgICogVXNhZ2Ugc3RhdGlzdGljcyBmb3IgdGhlIGNvbXBsZXRpb24gcmVxdWVzdC5cbiAgICovXG4gIHVzYWdlPzogQ29tcGxldGlvblVzYWdlO1xufVxuXG5pbnRlcmZhY2UgQ29tcGxldGlvbkNob2ljZSB7XG4gIC8qKlxuICAgKiBUaGUgcmVhc29uIHRoZSBtb2RlbCBzdG9wcGVkIGdlbmVyYXRpbmcgdG9rZW5zLiBUaGlzIHdpbGwgYmUgYHN0b3BgIGlmIHRoZSBtb2RlbFxuICAgKiBoaXQgYSBuYXR1cmFsIHN0b3AgcG9pbnQgb3IgYSBwcm92aWRlZCBzdG9wIHNlcXVlbmNlLCBvciBgbGVuZ3RoYCBpZiB0aGUgbWF4aW11bVxuICAgKiBudW1iZXIgb2YgdG9rZW5zIHNwZWNpZmllZCBpbiB0aGUgcmVxdWVzdCB3YXMgcmVhY2hlZC5cbiAgICovXG4gIGZpbmlzaF9yZWFzb246ICdzdG9wJyB8ICdsZW5ndGgnIHwgJ2NvbnRlbnRfZmlsdGVyJztcblxuICBpbmRleDogbnVtYmVyO1xuXG4gIC8vIGVkaXRlZDogUmVtb3ZlZCBDb21wbGV0aW9uQ2hvaWNlLmxvZ1Byb2JzIGFuZCByZXBsYWNlZCB3aXRoIGFueVxuICBsb2dwcm9iczogYW55IHwgbnVsbDtcblxuICB0ZXh0OiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQ29tcGxldGlvblVzYWdlIHtcbiAgLyoqXG4gICAqIFVzYWdlIHN0YXRpc3RpY3MgZm9yIHRoZSBjb21wbGV0aW9uIHJlcXVlc3QuXG4gICAqL1xuXG4gIC8qKlxuICAgKiBOdW1iZXIgb2YgdG9rZW5zIGluIHRoZSBnZW5lcmF0ZWQgY29tcGxldGlvbi5cbiAgICovXG4gIGNvbXBsZXRpb25fdG9rZW5zOiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIE51bWJlciBvZiB0b2tlbnMgaW4gdGhlIHByb21wdC5cbiAgICovXG4gIHByb21wdF90b2tlbnM6IG51bWJlcjtcblxuICAvKipcbiAgICogVG90YWwgbnVtYmVyIG9mIHRva2VucyB1c2VkIGluIHRoZSByZXF1ZXN0IChwcm9tcHQgKyBjb21wbGV0aW9uKS5cbiAgICovXG4gIHRvdGFsX3Rva2VuczogbnVtYmVyO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBwYXJzZXIgZnVuY3Rpb24gZm9yIHByb2Nlc3NpbmcgdGhlIE9wZW5BSSBzdHJlYW0gZGF0YS5cbiAqIFRoZSBwYXJzZXIgZXh0cmFjdHMgYW5kIHRyaW1zIHRleHQgY29udGVudCBmcm9tIHRoZSBKU09OIGRhdGEuIFRoaXMgcGFyc2VyXG4gKiBjYW4gaGFuZGxlIGRhdGEgZm9yIGNoYXQgb3IgY29tcGxldGlvbiBtb2RlbHMuXG4gKlxuICogQHJldHVybiB7KGRhdGE6IHN0cmluZykgPT4gc3RyaW5nIHwgdm9pZHwgeyBpc1RleHQ6IGZhbHNlOyBjb250ZW50OiBzdHJpbmcgfX1cbiAqIEEgcGFyc2VyIGZ1bmN0aW9uIHRoYXQgdGFrZXMgYSBKU09OIHN0cmluZyBhcyBpbnB1dCBhbmQgcmV0dXJucyB0aGUgZXh0cmFjdGVkIHRleHQgY29udGVudCxcbiAqIGEgY29tcGxleCBvYmplY3Qgd2l0aCBpc1RleHQ6IGZhbHNlIGZvciBmdW5jdGlvbi90b29sIGNhbGxzLCBvciBub3RoaW5nLlxuICovXG5mdW5jdGlvbiBwYXJzZU9wZW5BSVN0cmVhbSgpOiAoXG4gIGRhdGE6IHN0cmluZyxcbikgPT4gc3RyaW5nIHwgdm9pZCB8IHsgaXNUZXh0OiBmYWxzZTsgY29udGVudDogc3RyaW5nIH0ge1xuICBjb25zdCBleHRyYWN0ID0gY2h1bmtUb1RleHQoKTtcbiAgcmV0dXJuIGRhdGEgPT4gZXh0cmFjdChKU09OLnBhcnNlKGRhdGEpIGFzIE9wZW5BSVN0cmVhbVJldHVyblR5cGVzKTtcbn1cblxuLyoqXG4gKiBSZWFkcyBjaHVua3MgZnJvbSBPcGVuQUkncyBuZXcgU3RyZWFtYWJsZSBpbnRlcmZhY2UsIHdoaWNoIGlzIGVzc2VudGlhbGx5XG4gKiB0aGUgc2FtZSBhcyB0aGUgb2xkIFJlc3BvbnNlIGJvZHkgaW50ZXJmYWNlIHdpdGggYW4gaW5jbHVkZWQgU1NFIHBhcnNlclxuICogZG9pbmcgdGhlIHBhcnNpbmcgZm9yIHVzLlxuICovXG5hc3luYyBmdW5jdGlvbiogc3RyZWFtYWJsZShzdHJlYW06IEFzeW5jSXRlcmFibGVPcGVuQUlTdHJlYW1SZXR1cm5UeXBlcykge1xuICBjb25zdCBleHRyYWN0ID0gY2h1bmtUb1RleHQoKTtcblxuICBmb3IgYXdhaXQgKGxldCBjaHVuayBvZiBzdHJlYW0pIHtcbiAgICAvLyBjb252ZXJ0IGNodW5rIGlmIGl0IGlzIGFuIEF6dXJlIGNoYXQgY29tcGxldGlvbi4gQXp1cmUgZG9lcyBub3QgZXhwb3NlIGFsbFxuICAgIC8vIHByb3BlcnRpZXMgaW4gdGhlIGludGVyZmFjZXMsIGFuZCBhbHNvIHVzZXMgY2FtZWxDYXNlIGluc3RlYWQgb2Ygc25ha2VfY2FzZVxuICAgIGlmICgncHJvbXB0RmlsdGVyUmVzdWx0cycgaW4gY2h1bmspIHtcbiAgICAgIGNodW5rID0ge1xuICAgICAgICBpZDogY2h1bmsuaWQsXG4gICAgICAgIGNyZWF0ZWQ6IGNodW5rLmNyZWF0ZWQuZ2V0RGF0ZSgpLFxuICAgICAgICBvYmplY3Q6IChjaHVuayBhcyBhbnkpLm9iamVjdCwgLy8gbm90IGV4cG9zZWQgYnkgQXp1cmUgQVBJXG4gICAgICAgIG1vZGVsOiAoY2h1bmsgYXMgYW55KS5tb2RlbCwgLy8gbm90IGV4cG9zZWQgYnkgQXp1cmUgQVBJXG4gICAgICAgIGNob2ljZXM6IGNodW5rLmNob2ljZXMubWFwKGNob2ljZSA9PiAoe1xuICAgICAgICAgIGRlbHRhOiB7XG4gICAgICAgICAgICBjb250ZW50OiBjaG9pY2UuZGVsdGE/LmNvbnRlbnQsXG4gICAgICAgICAgICBmdW5jdGlvbl9jYWxsOiBjaG9pY2UuZGVsdGE/LmZ1bmN0aW9uQ2FsbCxcbiAgICAgICAgICAgIHJvbGU6IGNob2ljZS5kZWx0YT8ucm9sZSBhcyBhbnksXG4gICAgICAgICAgICB0b29sX2NhbGxzOiBjaG9pY2UuZGVsdGE/LnRvb2xDYWxscz8ubGVuZ3RoXG4gICAgICAgICAgICAgID8gY2hvaWNlLmRlbHRhPy50b29sQ2FsbHM/Lm1hcCgodG9vbENhbGwsIGluZGV4KSA9PiAoe1xuICAgICAgICAgICAgICAgICAgaW5kZXgsXG4gICAgICAgICAgICAgICAgICBpZDogdG9vbENhbGwuaWQsXG4gICAgICAgICAgICAgICAgICBmdW5jdGlvbjogdG9vbENhbGwuZnVuY3Rpb24sXG4gICAgICAgICAgICAgICAgICB0eXBlOiB0b29sQ2FsbC50eXBlLFxuICAgICAgICAgICAgICAgIH0pKVxuICAgICAgICAgICAgICA6IHVuZGVmaW5lZCxcbiAgICAgICAgICB9LFxuICAgICAgICAgIGZpbmlzaF9yZWFzb246IGNob2ljZS5maW5pc2hSZWFzb24gYXMgYW55LFxuICAgICAgICAgIGluZGV4OiBjaG9pY2UuaW5kZXgsXG4gICAgICAgIH0pKSxcbiAgICAgIH0gc2F0aXNmaWVzIENoYXRDb21wbGV0aW9uQ2h1bms7XG4gICAgfVxuXG4gICAgY29uc3QgdGV4dCA9IGV4dHJhY3QoY2h1bmspO1xuXG4gICAgaWYgKHRleHQpIHlpZWxkIHRleHQ7XG4gIH1cbn1cblxuZnVuY3Rpb24gY2h1bmtUb1RleHQoKTogKFxuICBjaHVuazogT3BlbkFJU3RyZWFtUmV0dXJuVHlwZXMsXG4pID0+IHN0cmluZyB8IHsgaXNUZXh0OiBmYWxzZTsgY29udGVudDogc3RyaW5nIH0gfCB2b2lkIHtcbiAgY29uc3QgdHJpbVN0YXJ0T2ZTdHJlYW0gPSB0cmltU3RhcnRPZlN0cmVhbUhlbHBlcigpO1xuICBsZXQgaXNGdW5jdGlvblN0cmVhbWluZ0luOiBib29sZWFuO1xuICByZXR1cm4ganNvbiA9PiB7XG4gICAgaWYgKGlzQ2hhdENvbXBsZXRpb25DaHVuayhqc29uKSkge1xuICAgICAgY29uc3QgZGVsdGEgPSBqc29uLmNob2ljZXNbMF0/LmRlbHRhO1xuICAgICAgaWYgKGRlbHRhLmZ1bmN0aW9uX2NhbGw/Lm5hbWUpIHtcbiAgICAgICAgaXNGdW5jdGlvblN0cmVhbWluZ0luID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBpc1RleHQ6IGZhbHNlLFxuICAgICAgICAgIGNvbnRlbnQ6IGB7XCJmdW5jdGlvbl9jYWxsXCI6IHtcIm5hbWVcIjogXCIke2RlbHRhLmZ1bmN0aW9uX2NhbGwubmFtZX1cIiwgXCJhcmd1bWVudHNcIjogXCJgLFxuICAgICAgICB9O1xuICAgICAgfSBlbHNlIGlmIChkZWx0YS50b29sX2NhbGxzPy5bMF0/LmZ1bmN0aW9uPy5uYW1lKSB7XG4gICAgICAgIGlzRnVuY3Rpb25TdHJlYW1pbmdJbiA9IHRydWU7XG4gICAgICAgIGNvbnN0IHRvb2xDYWxsID0gZGVsdGEudG9vbF9jYWxsc1swXTtcbiAgICAgICAgaWYgKHRvb2xDYWxsLmluZGV4ID09PSAwKSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGlzVGV4dDogZmFsc2UsXG4gICAgICAgICAgICBjb250ZW50OiBge1widG9vbF9jYWxsc1wiOlsge1wiaWRcIjogXCIke3Rvb2xDYWxsLmlkfVwiLCBcInR5cGVcIjogXCJmdW5jdGlvblwiLCBcImZ1bmN0aW9uXCI6IHtcIm5hbWVcIjogXCIke3Rvb2xDYWxsLmZ1bmN0aW9uPy5uYW1lfVwiLCBcImFyZ3VtZW50c1wiOiBcImAsXG4gICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaXNUZXh0OiBmYWxzZSxcbiAgICAgICAgICAgIGNvbnRlbnQ6IGBcIn19LCB7XCJpZFwiOiBcIiR7dG9vbENhbGwuaWR9XCIsIFwidHlwZVwiOiBcImZ1bmN0aW9uXCIsIFwiZnVuY3Rpb25cIjoge1wibmFtZVwiOiBcIiR7dG9vbENhbGwuZnVuY3Rpb24/Lm5hbWV9XCIsIFwiYXJndW1lbnRzXCI6IFwiYCxcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGRlbHRhLmZ1bmN0aW9uX2NhbGw/LmFyZ3VtZW50cykge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGlzVGV4dDogZmFsc2UsXG4gICAgICAgICAgY29udGVudDogY2xlYW51cEFyZ3VtZW50cyhkZWx0YS5mdW5jdGlvbl9jYWxsPy5hcmd1bWVudHMpLFxuICAgICAgICB9O1xuICAgICAgfSBlbHNlIGlmIChkZWx0YS50b29sX2NhbGxzPy5bMF0/LmZ1bmN0aW9uPy5hcmd1bWVudHMpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBpc1RleHQ6IGZhbHNlLFxuICAgICAgICAgIGNvbnRlbnQ6IGNsZWFudXBBcmd1bWVudHMoZGVsdGEudG9vbF9jYWxscz8uWzBdPy5mdW5jdGlvbj8uYXJndW1lbnRzKSxcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgIGlzRnVuY3Rpb25TdHJlYW1pbmdJbiAmJlxuICAgICAgICAoanNvbi5jaG9pY2VzWzBdPy5maW5pc2hfcmVhc29uID09PSAnZnVuY3Rpb25fY2FsbCcgfHxcbiAgICAgICAgICBqc29uLmNob2ljZXNbMF0/LmZpbmlzaF9yZWFzb24gPT09ICdzdG9wJylcbiAgICAgICkge1xuICAgICAgICBpc0Z1bmN0aW9uU3RyZWFtaW5nSW4gPSBmYWxzZTsgLy8gUmVzZXQgdGhlIGZsYWdcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBpc1RleHQ6IGZhbHNlLFxuICAgICAgICAgIGNvbnRlbnQ6ICdcIn19JyxcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgIGlzRnVuY3Rpb25TdHJlYW1pbmdJbiAmJlxuICAgICAgICBqc29uLmNob2ljZXNbMF0/LmZpbmlzaF9yZWFzb24gPT09ICd0b29sX2NhbGxzJ1xuICAgICAgKSB7XG4gICAgICAgIGlzRnVuY3Rpb25TdHJlYW1pbmdJbiA9IGZhbHNlOyAvLyBSZXNldCB0aGUgZmxhZ1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGlzVGV4dDogZmFsc2UsXG4gICAgICAgICAgY29udGVudDogJ1wifX1dfScsXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgdGV4dCA9IHRyaW1TdGFydE9mU3RyZWFtKFxuICAgICAgaXNDaGF0Q29tcGxldGlvbkNodW5rKGpzb24pICYmIGpzb24uY2hvaWNlc1swXS5kZWx0YS5jb250ZW50XG4gICAgICAgID8ganNvbi5jaG9pY2VzWzBdLmRlbHRhLmNvbnRlbnRcbiAgICAgICAgOiBpc0NvbXBsZXRpb24oanNvbilcbiAgICAgICAgPyBqc29uLmNob2ljZXNbMF0udGV4dFxuICAgICAgICA6ICcnLFxuICAgICk7XG5cbiAgICByZXR1cm4gdGV4dDtcbiAgfTtcblxuICBmdW5jdGlvbiBjbGVhbnVwQXJndW1lbnRzKGFyZ3VtZW50Q2h1bms6IHN0cmluZykge1xuICAgIGxldCBlc2NhcGVkUGFydGlhbEpzb24gPSBhcmd1bWVudENodW5rXG4gICAgICAucmVwbGFjZSgvXFxcXC9nLCAnXFxcXFxcXFwnKSAvLyBSZXBsYWNlIGJhY2tzbGFzaGVzIGZpcnN0IHRvIHByZXZlbnQgZG91YmxlIGVzY2FwaW5nXG4gICAgICAucmVwbGFjZSgvXFwvL2csICdcXFxcLycpIC8vIEVzY2FwZSBzbGFzaGVzXG4gICAgICAucmVwbGFjZSgvXCIvZywgJ1xcXFxcIicpIC8vIEVzY2FwZSBkb3VibGUgcXVvdGVzXG4gICAgICAucmVwbGFjZSgvXFxuL2csICdcXFxcbicpIC8vIEVzY2FwZSBuZXcgbGluZXNcbiAgICAgIC5yZXBsYWNlKC9cXHIvZywgJ1xcXFxyJykgLy8gRXNjYXBlIGNhcnJpYWdlIHJldHVybnNcbiAgICAgIC5yZXBsYWNlKC9cXHQvZywgJ1xcXFx0JykgLy8gRXNjYXBlIHRhYnNcbiAgICAgIC5yZXBsYWNlKC9cXGYvZywgJ1xcXFxmJyk7IC8vIEVzY2FwZSBmb3JtIGZlZWRzXG5cbiAgICByZXR1cm4gYCR7ZXNjYXBlZFBhcnRpYWxKc29ufWA7XG4gIH1cbn1cblxuY29uc3QgX19pbnRlcm5hbF9fT3BlbkFJRm5NZXNzYWdlc1N5bWJvbCA9IFN5bWJvbChcbiAgJ2ludGVybmFsX29wZW5haV9mbl9tZXNzYWdlcycsXG4pO1xuXG50eXBlIEFzeW5jSXRlcmFibGVPcGVuQUlTdHJlYW1SZXR1cm5UeXBlcyA9XG4gIHwgQXN5bmNJdGVyYWJsZTxDaGF0Q29tcGxldGlvbkNodW5rPlxuICB8IEFzeW5jSXRlcmFibGU8Q29tcGxldGlvbj5cbiAgfCBBc3luY0l0ZXJhYmxlPEF6dXJlQ2hhdENvbXBsZXRpb25zPjtcblxudHlwZSBFeHRyYWN0VHlwZTxUPiA9IFQgZXh0ZW5kcyBBc3luY0l0ZXJhYmxlPGluZmVyIFU+ID8gVSA6IG5ldmVyO1xuXG50eXBlIE9wZW5BSVN0cmVhbVJldHVyblR5cGVzID1cbiAgRXh0cmFjdFR5cGU8QXN5bmNJdGVyYWJsZU9wZW5BSVN0cmVhbVJldHVyblR5cGVzPjtcblxuZnVuY3Rpb24gaXNDaGF0Q29tcGxldGlvbkNodW5rKFxuICBkYXRhOiBPcGVuQUlTdHJlYW1SZXR1cm5UeXBlcyxcbik6IGRhdGEgaXMgQ2hhdENvbXBsZXRpb25DaHVuayB7XG4gIHJldHVybiAoXG4gICAgJ2Nob2ljZXMnIGluIGRhdGEgJiZcbiAgICBkYXRhLmNob2ljZXMgJiZcbiAgICBkYXRhLmNob2ljZXNbMF0gJiZcbiAgICAnZGVsdGEnIGluIGRhdGEuY2hvaWNlc1swXVxuICApO1xufVxuXG5mdW5jdGlvbiBpc0NvbXBsZXRpb24oZGF0YTogT3BlbkFJU3RyZWFtUmV0dXJuVHlwZXMpOiBkYXRhIGlzIENvbXBsZXRpb24ge1xuICByZXR1cm4gKFxuICAgICdjaG9pY2VzJyBpbiBkYXRhICYmXG4gICAgZGF0YS5jaG9pY2VzICYmXG4gICAgZGF0YS5jaG9pY2VzWzBdICYmXG4gICAgJ3RleHQnIGluIGRhdGEuY2hvaWNlc1swXVxuICApO1xufVxuXG4vKipcbiAqIEBkZXByZWNhdGVkIFVzZSB0aGUgW09wZW5BSSBwcm92aWRlcl0oaHR0cHM6Ly9zZGsudmVyY2VsLmFpL3Byb3ZpZGVycy9haS1zZGstcHJvdmlkZXJzL29wZW5haSkgaW5zdGVhZC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIE9wZW5BSVN0cmVhbShcbiAgcmVzOiBSZXNwb25zZSB8IEFzeW5jSXRlcmFibGVPcGVuQUlTdHJlYW1SZXR1cm5UeXBlcyxcbiAgY2FsbGJhY2tzPzogT3BlbkFJU3RyZWFtQ2FsbGJhY2tzLFxuKTogUmVhZGFibGVTdHJlYW0ge1xuICAvLyBBbm5vdGF0ZSB0aGUgaW50ZXJuYWwgYG1lc3NhZ2VzYCBwcm9wZXJ0eSBmb3IgcmVjdXJzaXZlIGZ1bmN0aW9uIGNhbGxzXG4gIGNvbnN0IGNiOlxuICAgIHwgdW5kZWZpbmVkXG4gICAgfCAoT3BlbkFJU3RyZWFtQ2FsbGJhY2tzICYge1xuICAgICAgICBbX19pbnRlcm5hbF9fT3BlbkFJRm5NZXNzYWdlc1N5bWJvbF0/OiBDcmVhdGVNZXNzYWdlW107XG4gICAgICB9KSA9IGNhbGxiYWNrcztcblxuICBsZXQgc3RyZWFtOiBSZWFkYWJsZVN0cmVhbTxVaW50OEFycmF5PjtcbiAgaWYgKFN5bWJvbC5hc3luY0l0ZXJhdG9yIGluIHJlcykge1xuICAgIHN0cmVhbSA9IHJlYWRhYmxlRnJvbUFzeW5jSXRlcmFibGUoc3RyZWFtYWJsZShyZXMpKS5waXBlVGhyb3VnaChcbiAgICAgIGNyZWF0ZUNhbGxiYWNrc1RyYW5zZm9ybWVyKFxuICAgICAgICBjYj8uZXhwZXJpbWVudGFsX29uRnVuY3Rpb25DYWxsIHx8IGNiPy5leHBlcmltZW50YWxfb25Ub29sQ2FsbFxuICAgICAgICAgID8ge1xuICAgICAgICAgICAgICAuLi5jYixcbiAgICAgICAgICAgICAgb25GaW5hbDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgfVxuICAgICAgICAgIDoge1xuICAgICAgICAgICAgICAuLi5jYixcbiAgICAgICAgICAgIH0sXG4gICAgICApLFxuICAgICk7XG4gIH0gZWxzZSB7XG4gICAgc3RyZWFtID0gQUlTdHJlYW0oXG4gICAgICByZXMsXG4gICAgICBwYXJzZU9wZW5BSVN0cmVhbSgpLFxuICAgICAgY2I/LmV4cGVyaW1lbnRhbF9vbkZ1bmN0aW9uQ2FsbCB8fCBjYj8uZXhwZXJpbWVudGFsX29uVG9vbENhbGxcbiAgICAgICAgPyB7XG4gICAgICAgICAgICAuLi5jYixcbiAgICAgICAgICAgIG9uRmluYWw6IHVuZGVmaW5lZCxcbiAgICAgICAgICB9XG4gICAgICAgIDoge1xuICAgICAgICAgICAgLi4uY2IsXG4gICAgICAgICAgfSxcbiAgICApO1xuICB9XG5cbiAgaWYgKGNiICYmIChjYi5leHBlcmltZW50YWxfb25GdW5jdGlvbkNhbGwgfHwgY2IuZXhwZXJpbWVudGFsX29uVG9vbENhbGwpKSB7XG4gICAgY29uc3QgZnVuY3Rpb25DYWxsVHJhbnNmb3JtZXIgPSBjcmVhdGVGdW5jdGlvbkNhbGxUcmFuc2Zvcm1lcihjYik7XG4gICAgcmV0dXJuIHN0cmVhbS5waXBlVGhyb3VnaChmdW5jdGlvbkNhbGxUcmFuc2Zvcm1lcik7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHN0cmVhbS5waXBlVGhyb3VnaChjcmVhdGVTdHJlYW1EYXRhVHJhbnNmb3JtZXIoKSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlRnVuY3Rpb25DYWxsVHJhbnNmb3JtZXIoXG4gIGNhbGxiYWNrczogT3BlbkFJU3RyZWFtQ2FsbGJhY2tzICYge1xuICAgIFtfX2ludGVybmFsX19PcGVuQUlGbk1lc3NhZ2VzU3ltYm9sXT86IENyZWF0ZU1lc3NhZ2VbXTtcbiAgfSxcbik6IFRyYW5zZm9ybVN0cmVhbTxVaW50OEFycmF5LCBVaW50OEFycmF5PiB7XG4gIGNvbnN0IHRleHRFbmNvZGVyID0gbmV3IFRleHRFbmNvZGVyKCk7XG4gIGxldCBpc0ZpcnN0Q2h1bmsgPSB0cnVlO1xuICBsZXQgYWdncmVnYXRlZFJlc3BvbnNlID0gJyc7XG4gIGxldCBhZ2dyZWdhdGVkRmluYWxDb21wbGV0aW9uUmVzcG9uc2UgPSAnJztcbiAgbGV0IGlzRnVuY3Rpb25TdHJlYW1pbmdJbiA9IGZhbHNlO1xuXG4gIGxldCBmdW5jdGlvbkNhbGxNZXNzYWdlczogQ3JlYXRlTWVzc2FnZVtdID1cbiAgICBjYWxsYmFja3NbX19pbnRlcm5hbF9fT3BlbkFJRm5NZXNzYWdlc1N5bWJvbF0gfHwgW107XG5cbiAgY29uc3QgZGVjb2RlID0gY3JlYXRlQ2h1bmtEZWNvZGVyKCk7XG5cbiAgcmV0dXJuIG5ldyBUcmFuc2Zvcm1TdHJlYW0oe1xuICAgIGFzeW5jIHRyYW5zZm9ybShjaHVuaywgY29udHJvbGxlcik6IFByb21pc2U8dm9pZD4ge1xuICAgICAgY29uc3QgbWVzc2FnZSA9IGRlY29kZShjaHVuayk7XG4gICAgICBhZ2dyZWdhdGVkRmluYWxDb21wbGV0aW9uUmVzcG9uc2UgKz0gbWVzc2FnZTtcblxuICAgICAgY29uc3Qgc2hvdWxkSGFuZGxlQXNGdW5jdGlvbiA9XG4gICAgICAgIGlzRmlyc3RDaHVuayAmJlxuICAgICAgICAobWVzc2FnZS5zdGFydHNXaXRoKCd7XCJmdW5jdGlvbl9jYWxsXCI6JykgfHxcbiAgICAgICAgICBtZXNzYWdlLnN0YXJ0c1dpdGgoJ3tcInRvb2xfY2FsbHNcIjonKSk7XG5cbiAgICAgIGlmIChzaG91bGRIYW5kbGVBc0Z1bmN0aW9uKSB7XG4gICAgICAgIGlzRnVuY3Rpb25TdHJlYW1pbmdJbiA9IHRydWU7XG4gICAgICAgIGFnZ3JlZ2F0ZWRSZXNwb25zZSArPSBtZXNzYWdlO1xuICAgICAgICBpc0ZpcnN0Q2h1bmsgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBTdHJlYW0gYXMgbm9ybWFsXG4gICAgICBpZiAoIWlzRnVuY3Rpb25TdHJlYW1pbmdJbikge1xuICAgICAgICBjb250cm9sbGVyLmVucXVldWUoXG4gICAgICAgICAgdGV4dEVuY29kZXIuZW5jb2RlKGZvcm1hdFN0cmVhbVBhcnQoJ3RleHQnLCBtZXNzYWdlKSksXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFnZ3JlZ2F0ZWRSZXNwb25zZSArPSBtZXNzYWdlO1xuICAgICAgfVxuICAgIH0sXG4gICAgYXN5bmMgZmx1c2goY29udHJvbGxlcik6IFByb21pc2U8dm9pZD4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKFxuICAgICAgICAgICFpc0ZpcnN0Q2h1bmsgJiZcbiAgICAgICAgICBpc0Z1bmN0aW9uU3RyZWFtaW5nSW4gJiZcbiAgICAgICAgICAoY2FsbGJhY2tzLmV4cGVyaW1lbnRhbF9vbkZ1bmN0aW9uQ2FsbCB8fFxuICAgICAgICAgICAgY2FsbGJhY2tzLmV4cGVyaW1lbnRhbF9vblRvb2xDYWxsKVxuICAgICAgICApIHtcbiAgICAgICAgICBpc0Z1bmN0aW9uU3RyZWFtaW5nSW4gPSBmYWxzZTtcbiAgICAgICAgICBjb25zdCBwYXlsb2FkID0gSlNPTi5wYXJzZShhZ2dyZWdhdGVkUmVzcG9uc2UpO1xuICAgICAgICAgIC8vIEFwcGVuZCB0aGUgZnVuY3Rpb24gY2FsbCBtZXNzYWdlIHRvIHRoZSBsaXN0XG4gICAgICAgICAgbGV0IG5ld0Z1bmN0aW9uQ2FsbE1lc3NhZ2VzOiBDcmVhdGVNZXNzYWdlW10gPSBbXG4gICAgICAgICAgICAuLi5mdW5jdGlvbkNhbGxNZXNzYWdlcyxcbiAgICAgICAgICBdO1xuXG4gICAgICAgICAgbGV0IGZ1bmN0aW9uUmVzcG9uc2U6XG4gICAgICAgICAgICB8IFJlc3BvbnNlXG4gICAgICAgICAgICB8IHVuZGVmaW5lZFxuICAgICAgICAgICAgfCB2b2lkXG4gICAgICAgICAgICB8IHN0cmluZ1xuICAgICAgICAgICAgfCBBc3luY0l0ZXJhYmxlT3BlbkFJU3RyZWFtUmV0dXJuVHlwZXNcbiAgICAgICAgICAgIHwgdW5kZWZpbmVkID0gdW5kZWZpbmVkO1xuICAgICAgICAgIC8vIFRoaXMgY2FsbGJhY2tzLmV4cGVyaW1lbnRhbF9vbkZ1bmN0aW9uQ2FsbCBjaGVjayBzaG91bGQgbm90IGJlIG5lY2Vzc2FyeSBidXQgVFMgY29tcGxhaW5zXG4gICAgICAgICAgaWYgKGNhbGxiYWNrcy5leHBlcmltZW50YWxfb25GdW5jdGlvbkNhbGwpIHtcbiAgICAgICAgICAgIC8vIElmIHRoZSB1c2VyIGlzIHVzaW5nIHRoZSBleHBlcmltZW50YWxfb25GdW5jdGlvbkNhbGwgY2FsbGJhY2ssIHRoZXkgc2hvdWxkIG5vdCBiZSB1c2luZyB0b29sc1xuICAgICAgICAgICAgLy8gaWYgcGF5bG9hZC5mdW5jdGlvbl9jYWxsIGlzIG5vdCBkZWZpbmVkIGJ5IHRpbWUgd2UgZ2V0IGhlcmUgd2UgbXVzdCBoYXZlIGdvdHRlbiBhIHRvb2wgcmVzcG9uc2VcbiAgICAgICAgICAgIC8vIGFuZCB0aGUgdXNlciBoYWQgZGVmaW5lZCBleHBlcmltZW50YWxfb25Ub29sQ2FsbFxuICAgICAgICAgICAgaWYgKHBheWxvYWQuZnVuY3Rpb25fY2FsbCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICAgICAgICAnZXhwZXJpbWVudGFsX29uRnVuY3Rpb25DYWxsIHNob3VsZCBub3QgYmUgZGVmaW5lZCB3aGVuIHVzaW5nIHRvb2xzJyxcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3QgYXJndW1lbnRzUGF5bG9hZCA9IEpTT04ucGFyc2UoXG4gICAgICAgICAgICAgIHBheWxvYWQuZnVuY3Rpb25fY2FsbC5hcmd1bWVudHMsXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICBmdW5jdGlvblJlc3BvbnNlID0gYXdhaXQgY2FsbGJhY2tzLmV4cGVyaW1lbnRhbF9vbkZ1bmN0aW9uQ2FsbChcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG5hbWU6IHBheWxvYWQuZnVuY3Rpb25fY2FsbC5uYW1lLFxuICAgICAgICAgICAgICAgIGFyZ3VtZW50czogYXJndW1lbnRzUGF5bG9hZCxcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgcmVzdWx0ID0+IHtcbiAgICAgICAgICAgICAgICAvLyBBcHBlbmQgdGhlIGZ1bmN0aW9uIGNhbGwgcmVxdWVzdCBhbmQgcmVzdWx0IG1lc3NhZ2VzIHRvIHRoZSBsaXN0XG4gICAgICAgICAgICAgICAgbmV3RnVuY3Rpb25DYWxsTWVzc2FnZXMgPSBbXG4gICAgICAgICAgICAgICAgICAuLi5mdW5jdGlvbkNhbGxNZXNzYWdlcyxcbiAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgcm9sZTogJ2Fzc2lzdGFudCcsXG4gICAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6ICcnLFxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbl9jYWxsOiBwYXlsb2FkLmZ1bmN0aW9uX2NhbGwsXG4gICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICByb2xlOiAnZnVuY3Rpb24nLFxuICAgICAgICAgICAgICAgICAgICBuYW1lOiBwYXlsb2FkLmZ1bmN0aW9uX2NhbGwubmFtZSxcbiAgICAgICAgICAgICAgICAgICAgY29udGVudDogSlNPTi5zdHJpbmdpZnkocmVzdWx0KSxcbiAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICAvLyBSZXR1cm4gaXQgdG8gdGhlIHVzZXJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3RnVuY3Rpb25DYWxsTWVzc2FnZXM7XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoY2FsbGJhY2tzLmV4cGVyaW1lbnRhbF9vblRvb2xDYWxsKSB7XG4gICAgICAgICAgICBjb25zdCB0b29sQ2FsbHM6IFRvb2xDYWxsUGF5bG9hZCA9IHtcbiAgICAgICAgICAgICAgdG9vbHM6IFtdLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgdG9vbCBvZiBwYXlsb2FkLnRvb2xfY2FsbHMpIHtcbiAgICAgICAgICAgICAgdG9vbENhbGxzLnRvb2xzLnB1c2goe1xuICAgICAgICAgICAgICAgIGlkOiB0b29sLmlkLFxuICAgICAgICAgICAgICAgIHR5cGU6ICdmdW5jdGlvbicsXG4gICAgICAgICAgICAgICAgZnVuYzoge1xuICAgICAgICAgICAgICAgICAgbmFtZTogdG9vbC5mdW5jdGlvbi5uYW1lLFxuICAgICAgICAgICAgICAgICAgYXJndW1lbnRzOiBKU09OLnBhcnNlKHRvb2wuZnVuY3Rpb24uYXJndW1lbnRzKSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCByZXNwb25zZUluZGV4ID0gMDtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGZ1bmN0aW9uUmVzcG9uc2UgPSBhd2FpdCBjYWxsYmFja3MuZXhwZXJpbWVudGFsX29uVG9vbENhbGwoXG4gICAgICAgICAgICAgICAgdG9vbENhbGxzLFxuICAgICAgICAgICAgICAgIHJlc3VsdCA9PiB7XG4gICAgICAgICAgICAgICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgdG9vbF9jYWxsX2lkLCBmdW5jdGlvbl9uYW1lLCB0b29sX2NhbGxfcmVzdWx0IH0gPVxuICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgLy8gQXBwZW5kIHRoZSBmdW5jdGlvbiBjYWxsIHJlcXVlc3QgYW5kIHJlc3VsdCBtZXNzYWdlcyB0byB0aGUgbGlzdFxuICAgICAgICAgICAgICAgICAgICBuZXdGdW5jdGlvbkNhbGxNZXNzYWdlcyA9IFtcbiAgICAgICAgICAgICAgICAgICAgICAuLi5uZXdGdW5jdGlvbkNhbGxNZXNzYWdlcyxcbiAgICAgICAgICAgICAgICAgICAgICAvLyBPbmx5IGFwcGVuZCB0aGUgYXNzaXN0YW50IG1lc3NhZ2UgaWYgaXQncyB0aGUgZmlyc3QgcmVzcG9uc2VcbiAgICAgICAgICAgICAgICAgICAgICAuLi4ocmVzcG9uc2VJbmRleCA9PT0gMFxuICAgICAgICAgICAgICAgICAgICAgICAgPyBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcm9sZTogJ2Fzc2lzdGFudCcgYXMgY29uc3QsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50OiAnJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvb2xfY2FsbHM6IHBheWxvYWQudG9vbF9jYWxscy5tYXAoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICh0YzogVG9vbENhbGwpID0+ICh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IHRjLmlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdmdW5jdGlvbicsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb246IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IHRjLmZ1bmN0aW9uLm5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB3ZSBzZW5kIHRoZSBhcmd1bWVudHMgYW4gb2JqZWN0IHRvIHRoZSB1c2VyLCBidXQgYXMgdGhlIEFQSSBleHBlY3RzIGEgc3RyaW5nLCB3ZSBuZWVkIHRvIHN0cmluZ2lmeSBpdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJndW1lbnRzOiBKU09OLnN0cmluZ2lmeShcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGMuZnVuY3Rpb24uYXJndW1lbnRzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICAgICAgICAgICAgOiBbXSksXG4gICAgICAgICAgICAgICAgICAgICAgLy8gQXBwZW5kIHRoZSBmdW5jdGlvbiBjYWxsIHJlc3VsdCBtZXNzYWdlXG4gICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgcm9sZTogJ3Rvb2wnLFxuICAgICAgICAgICAgICAgICAgICAgICAgdG9vbF9jYWxsX2lkLFxuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogZnVuY3Rpb25fbmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6IEpTT04uc3RyaW5naWZ5KHRvb2xfY2FsbF9yZXN1bHQpLFxuICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlSW5kZXgrKztcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIC8vIFJldHVybiBpdCB0byB0aGUgdXNlclxuICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ld0Z1bmN0aW9uQ2FsbE1lc3NhZ2VzO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGNhbGxpbmcgZXhwZXJpbWVudGFsX29uVG9vbENhbGw6JywgZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKCFmdW5jdGlvblJlc3BvbnNlKSB7XG4gICAgICAgICAgICAvLyBUaGUgdXNlciBkaWRuJ3QgZG8gYW55dGhpbmcgd2l0aCB0aGUgZnVuY3Rpb24gY2FsbCBvbiB0aGUgc2VydmVyIGFuZCB3YW50c1xuICAgICAgICAgICAgLy8gdG8gZWl0aGVyIGRvIG5vdGhpbmcgb3IgcnVuIGl0IG9uIHRoZSBjbGllbnRcbiAgICAgICAgICAgIC8vIHNvIHdlIGp1c3QgcmV0dXJuIHRoZSBmdW5jdGlvbiBjYWxsIGFzIGEgbWVzc2FnZVxuICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKFxuICAgICAgICAgICAgICB0ZXh0RW5jb2Rlci5lbmNvZGUoXG4gICAgICAgICAgICAgICAgZm9ybWF0U3RyZWFtUGFydChcbiAgICAgICAgICAgICAgICAgIHBheWxvYWQuZnVuY3Rpb25fY2FsbCA/ICdmdW5jdGlvbl9jYWxsJyA6ICd0b29sX2NhbGxzJyxcbiAgICAgICAgICAgICAgICAgIC8vIHBhcnNlIHRvIHByZXZlbnQgZG91YmxlLWVuY29kaW5nOlxuICAgICAgICAgICAgICAgICAgSlNPTi5wYXJzZShhZ2dyZWdhdGVkUmVzcG9uc2UpLFxuICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICksXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGZ1bmN0aW9uUmVzcG9uc2UgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAvLyBUaGUgdXNlciByZXR1cm5lZCBhIHN0cmluZywgc28gd2UganVzdCByZXR1cm4gaXQgYXMgYSBtZXNzYWdlXG4gICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoXG4gICAgICAgICAgICAgIHRleHRFbmNvZGVyLmVuY29kZShmb3JtYXRTdHJlYW1QYXJ0KCd0ZXh0JywgZnVuY3Rpb25SZXNwb25zZSkpLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGFnZ3JlZ2F0ZWRGaW5hbENvbXBsZXRpb25SZXNwb25zZSA9IGZ1bmN0aW9uUmVzcG9uc2U7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gUmVjdXJzaXZlbHk6XG5cbiAgICAgICAgICAvLyBXZSBkb24ndCB3YW50IHRvIHRyaWdnZXIgb25TdGFydCBvciBvbkNvbXBsZXRlIHJlY3Vyc2l2ZWx5XG4gICAgICAgICAgLy8gc28gd2UgcmVtb3ZlIHRoZW0gZnJvbSB0aGUgY2FsbGJhY2tzXG4gICAgICAgICAgLy8gc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS92ZXJjZWwvYWkvaXNzdWVzLzM1MVxuICAgICAgICAgIGNvbnN0IGZpbHRlcmVkQ2FsbGJhY2tzOiBPcGVuQUlTdHJlYW1DYWxsYmFja3MgPSB7XG4gICAgICAgICAgICAuLi5jYWxsYmFja3MsXG4gICAgICAgICAgICBvblN0YXJ0OiB1bmRlZmluZWQsXG4gICAgICAgICAgfTtcbiAgICAgICAgICAvLyBXZSBvbmx5IHdhbnQgb25GaW5hbCB0byBiZSBjYWxsZWQgdGhlIF9sYXN0XyB0aW1lXG4gICAgICAgICAgY2FsbGJhY2tzLm9uRmluYWwgPSB1bmRlZmluZWQ7XG5cbiAgICAgICAgICBjb25zdCBvcGVuQUlTdHJlYW0gPSBPcGVuQUlTdHJlYW0oZnVuY3Rpb25SZXNwb25zZSwge1xuICAgICAgICAgICAgLi4uZmlsdGVyZWRDYWxsYmFja3MsXG4gICAgICAgICAgICBbX19pbnRlcm5hbF9fT3BlbkFJRm5NZXNzYWdlc1N5bWJvbF06IG5ld0Z1bmN0aW9uQ2FsbE1lc3NhZ2VzLFxuICAgICAgICAgIH0gYXMgQUlTdHJlYW1DYWxsYmFja3NBbmRPcHRpb25zKTtcblxuICAgICAgICAgIGNvbnN0IHJlYWRlciA9IG9wZW5BSVN0cmVhbS5nZXRSZWFkZXIoKTtcblxuICAgICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICBjb25zdCB7IGRvbmUsIHZhbHVlIH0gPSBhd2FpdCByZWFkZXIucmVhZCgpO1xuICAgICAgICAgICAgaWYgKGRvbmUpIHtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUodmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgaWYgKGNhbGxiYWNrcy5vbkZpbmFsICYmIGFnZ3JlZ2F0ZWRGaW5hbENvbXBsZXRpb25SZXNwb25zZSkge1xuICAgICAgICAgIGF3YWl0IGNhbGxiYWNrcy5vbkZpbmFsKGFnZ3JlZ2F0ZWRGaW5hbENvbXBsZXRpb25SZXNwb25zZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICB9KTtcbn1cbiIsIi8qKlxuICogQ29uc3VtZXMgYSBSZWFkYWJsZVN0cmVhbSB1bnRpbCBpdCdzIGZ1bGx5IHJlYWQuXG4gKlxuICogVGhpcyBmdW5jdGlvbiByZWFkcyB0aGUgc3RyZWFtIGNodW5rIGJ5IGNodW5rIHVudGlsIHRoZSBzdHJlYW0gaXMgZXhoYXVzdGVkLlxuICogSXQgZG9lc24ndCBwcm9jZXNzIG9yIHJldHVybiB0aGUgZGF0YSBmcm9tIHRoZSBzdHJlYW07IGl0IHNpbXBseSBlbnN1cmVzXG4gKiB0aGF0IHRoZSBlbnRpcmUgc3RyZWFtIGlzIHJlYWQuXG4gKlxuICogQHBhcmFtIHtSZWFkYWJsZVN0cmVhbX0gc3RyZWFtIC0gVGhlIFJlYWRhYmxlU3RyZWFtIHRvIGJlIGNvbnN1bWVkLlxuICogQHJldHVybnMge1Byb21pc2U8dm9pZD59IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHdoZW4gdGhlIHN0cmVhbSBpcyBmdWxseSBjb25zdW1lZC5cbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGNvbnN1bWVTdHJlYW0oc3RyZWFtOiBSZWFkYWJsZVN0cmVhbSk6IFByb21pc2U8dm9pZD4ge1xuICBjb25zdCByZWFkZXIgPSBzdHJlYW0uZ2V0UmVhZGVyKCk7XG4gIHdoaWxlICh0cnVlKSB7XG4gICAgY29uc3QgeyBkb25lIH0gPSBhd2FpdCByZWFkZXIucmVhZCgpO1xuICAgIGlmIChkb25lKSBicmVhaztcbiAgfVxufVxuIiwiZXhwb3J0IGNvbnN0IFNUUkVBTUFCTEVfVkFMVUVfVFlQRSA9IFN5bWJvbC5mb3IoJ3VpLnN0cmVhbWFibGUudmFsdWUnKTtcblxuZXhwb3J0IHR5cGUgU3RyZWFtYWJsZVBhdGNoID0gdW5kZWZpbmVkIHwgWzAsIHN0cmluZ107IC8vIEFwcGVuZCBzdHJpbmcuXG5cbmRlY2xhcmUgY29uc3QgX19pbnRlcm5hbF9jdXJyOiB1bmlxdWUgc3ltYm9sO1xuZGVjbGFyZSBjb25zdCBfX2ludGVybmFsX2Vycm9yOiB1bmlxdWUgc3ltYm9sO1xuXG4vKipcbiAqIFN0cmVhbWFibGVWYWx1ZSBpcyBhIHZhbHVlIHRoYXQgY2FuIGJlIHN0cmVhbWVkIG92ZXIgdGhlIG5ldHdvcmsgdmlhIEFJIEFjdGlvbnMuXG4gKiBUbyByZWFkIHRoZSBzdHJlYW1lZCB2YWx1ZXMsIHVzZSB0aGUgYHJlYWRTdHJlYW1hYmxlVmFsdWVgIG9yIGB1c2VTdHJlYW1hYmxlVmFsdWVgIEFQSXMuXG4gKi9cbmV4cG9ydCB0eXBlIFN0cmVhbWFibGVWYWx1ZTxUID0gYW55LCBFID0gYW55PiA9IHtcbiAgLyoqXG4gICAqIEBpbnRlcm5hbCBVc2UgYHJlYWRTdHJlYW1hYmxlVmFsdWVgIHRvIHJlYWQgdGhlIHZhbHVlcy5cbiAgICovXG4gIHR5cGU/OiB0eXBlb2YgU1RSRUFNQUJMRV9WQUxVRV9UWVBFO1xuICAvKipcbiAgICogQGludGVybmFsIFVzZSBgcmVhZFN0cmVhbWFibGVWYWx1ZWAgdG8gcmVhZCB0aGUgdmFsdWVzLlxuICAgKi9cbiAgY3Vycj86IFQ7XG4gIC8qKlxuICAgKiBAaW50ZXJuYWwgVXNlIGByZWFkU3RyZWFtYWJsZVZhbHVlYCB0byByZWFkIHRoZSB2YWx1ZXMuXG4gICAqL1xuICBlcnJvcj86IEU7XG4gIC8qKlxuICAgKiBAaW50ZXJuYWwgVXNlIGByZWFkU3RyZWFtYWJsZVZhbHVlYCB0byByZWFkIHRoZSB2YWx1ZXMuXG4gICAqL1xuICBkaWZmPzogU3RyZWFtYWJsZVBhdGNoO1xuICAvKipcbiAgICogQGludGVybmFsIFVzZSBgcmVhZFN0cmVhbWFibGVWYWx1ZWAgdG8gcmVhZCB0aGUgdmFsdWVzLlxuICAgKi9cbiAgbmV4dD86IFByb21pc2U8U3RyZWFtYWJsZVZhbHVlPFQsIEU+PjtcblxuICAvLyBicmFuZGVkIHR5cGVzIHRvIG1haW50YWluIHR5cGUgc2lnbmF0dXJlIGFmdGVyIGludGVybmFsIHByb3BlcnRpZXMgYXJlIHN0cmlwcGVkLlxuICBbX19pbnRlcm5hbF9jdXJyXT86IFQ7XG4gIFtfX2ludGVybmFsX2Vycm9yXT86IEU7XG59O1xuIiwiaW1wb3J0IHsgSEFOR0lOR19TVFJFQU1fV0FSTklOR19USU1FX01TIH0gZnJvbSAnLi4vLi4vdXRpbC9jb25zdGFudHMnO1xuaW1wb3J0IHsgY3JlYXRlUmVzb2x2YWJsZVByb21pc2UgfSBmcm9tICcuLi8uLi91dGlsL2NyZWF0ZS1yZXNvbHZhYmxlLXByb21pc2UnO1xuaW1wb3J0IHtcbiAgU1RSRUFNQUJMRV9WQUxVRV9UWVBFLFxuICBTdHJlYW1hYmxlUGF0Y2gsXG4gIFN0cmVhbWFibGVWYWx1ZSxcbn0gZnJvbSAnLi9zdHJlYW1hYmxlLXZhbHVlJztcblxuY29uc3QgU1RSRUFNQUJMRV9WQUxVRV9JTlRFUk5BTF9MT0NLID0gU3ltYm9sKCdzdHJlYW1hYmxlLnZhbHVlLmxvY2snKTtcblxuLyoqXG4gKiBDcmVhdGUgYSB3cmFwcGVkLCBjaGFuZ2VhYmxlIHZhbHVlIHRoYXQgY2FuIGJlIHN0cmVhbWVkIHRvIHRoZSBjbGllbnQuXG4gKiBPbiB0aGUgY2xpZW50IHNpZGUsIHRoZSB2YWx1ZSBjYW4gYmUgYWNjZXNzZWQgdmlhIHRoZSByZWFkU3RyZWFtYWJsZVZhbHVlKCkgQVBJLlxuICovXG5mdW5jdGlvbiBjcmVhdGVTdHJlYW1hYmxlVmFsdWU8VCA9IGFueSwgRSA9IGFueT4oXG4gIGluaXRpYWxWYWx1ZT86IFQgfCBSZWFkYWJsZVN0cmVhbTxUPixcbikge1xuICBjb25zdCBpc1JlYWRhYmxlU3RyZWFtID1cbiAgICBpbml0aWFsVmFsdWUgaW5zdGFuY2VvZiBSZWFkYWJsZVN0cmVhbSB8fFxuICAgICh0eXBlb2YgaW5pdGlhbFZhbHVlID09PSAnb2JqZWN0JyAmJlxuICAgICAgaW5pdGlhbFZhbHVlICE9PSBudWxsICYmXG4gICAgICAnZ2V0UmVhZGVyJyBpbiBpbml0aWFsVmFsdWUgJiZcbiAgICAgIHR5cGVvZiBpbml0aWFsVmFsdWUuZ2V0UmVhZGVyID09PSAnZnVuY3Rpb24nICYmXG4gICAgICAnbG9ja2VkJyBpbiBpbml0aWFsVmFsdWUgJiZcbiAgICAgIHR5cGVvZiBpbml0aWFsVmFsdWUubG9ja2VkID09PSAnYm9vbGVhbicpO1xuXG4gIGlmICghaXNSZWFkYWJsZVN0cmVhbSkge1xuICAgIHJldHVybiBjcmVhdGVTdHJlYW1hYmxlVmFsdWVJbXBsPFQsIEU+KGluaXRpYWxWYWx1ZSk7XG4gIH1cblxuICBjb25zdCBzdHJlYW1hYmxlVmFsdWUgPSBjcmVhdGVTdHJlYW1hYmxlVmFsdWVJbXBsPFQsIEU+KCk7XG5cbiAgLy8gU2luY2UgdGhlIHN0cmVhbWFibGUgdmFsdWUgd2lsbCBiZSBmcm9tIGEgcmVhZGFibGUgc3RyZWFtLCBpdCdzIG5vdCBhbGxvd2VkXG4gIC8vIHRvIHVwZGF0ZSB0aGUgdmFsdWUgbWFudWFsbHkgYXMgdGhhdCBpbnRyb2R1Y2VzIHJhY2UgY29uZGl0aW9ucyBhbmRcbiAgLy8gdW5leHBlY3RlZCBiZWhhdmlvci5cbiAgLy8gV2UgbG9jayB0aGUgdmFsdWUgdG8gcHJldmVudCBhbnkgdXBkYXRlcyBmcm9tIHRoZSB1c2VyLlxuICBzdHJlYW1hYmxlVmFsdWVbU1RSRUFNQUJMRV9WQUxVRV9JTlRFUk5BTF9MT0NLXSA9IHRydWU7XG5cbiAgKGFzeW5jICgpID0+IHtcbiAgICB0cnkge1xuICAgICAgLy8gQ29uc3VtZSB0aGUgcmVhZGFibGUgc3RyZWFtIGFuZCB1cGRhdGUgdGhlIHZhbHVlLlxuICAgICAgY29uc3QgcmVhZGVyID0gaW5pdGlhbFZhbHVlLmdldFJlYWRlcigpO1xuXG4gICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICBjb25zdCB7IHZhbHVlLCBkb25lIH0gPSBhd2FpdCByZWFkZXIucmVhZCgpO1xuICAgICAgICBpZiAoZG9uZSkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVW5sb2NrIHRoZSB2YWx1ZSB0byBhbGxvdyB1cGRhdGVzLlxuICAgICAgICBzdHJlYW1hYmxlVmFsdWVbU1RSRUFNQUJMRV9WQUxVRV9JTlRFUk5BTF9MT0NLXSA9IGZhbHNlO1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgIHN0cmVhbWFibGVWYWx1ZS5hcHBlbmQodmFsdWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN0cmVhbWFibGVWYWx1ZS51cGRhdGUodmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIC8vIExvY2sgdGhlIHZhbHVlIGFnYWluLlxuICAgICAgICBzdHJlYW1hYmxlVmFsdWVbU1RSRUFNQUJMRV9WQUxVRV9JTlRFUk5BTF9MT0NLXSA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIHN0cmVhbWFibGVWYWx1ZVtTVFJFQU1BQkxFX1ZBTFVFX0lOVEVSTkFMX0xPQ0tdID0gZmFsc2U7XG4gICAgICBzdHJlYW1hYmxlVmFsdWUuZG9uZSgpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHN0cmVhbWFibGVWYWx1ZVtTVFJFQU1BQkxFX1ZBTFVFX0lOVEVSTkFMX0xPQ0tdID0gZmFsc2U7XG4gICAgICBzdHJlYW1hYmxlVmFsdWUuZXJyb3IoZSk7XG4gICAgfVxuICB9KSgpO1xuXG4gIHJldHVybiBzdHJlYW1hYmxlVmFsdWU7XG59XG5cbi8vIEl0J3MgbmVjZXNzYXJ5IHRvIGRlZmluZSB0aGUgdHlwZSBtYW51YWxseSBoZXJlLCBvdGhlcndpc2UgVHlwZVNjcmlwdCBjb21waWxlclxuLy8gd2lsbCBub3QgYmUgYWJsZSB0byBpbmZlciB0aGUgY29ycmVjdCByZXR1cm4gdHlwZSBhcyBpdCdzIGNpcmN1bGFyLlxudHlwZSBTdHJlYW1hYmxlVmFsdWVXcmFwcGVyPFQsIEU+ID0ge1xuICAvKipcbiAgICogVGhlIHZhbHVlIG9mIHRoZSBzdHJlYW1hYmxlLiBUaGlzIGNhbiBiZSByZXR1cm5lZCBmcm9tIGEgU2VydmVyIEFjdGlvbiBhbmRcbiAgICogcmVjZWl2ZWQgYnkgdGhlIGNsaWVudC4gVG8gcmVhZCB0aGUgc3RyZWFtZWQgdmFsdWVzLCB1c2UgdGhlXG4gICAqIGByZWFkU3RyZWFtYWJsZVZhbHVlYCBvciBgdXNlU3RyZWFtYWJsZVZhbHVlYCBBUElzLlxuICAgKi9cbiAgcmVhZG9ubHkgdmFsdWU6IFN0cmVhbWFibGVWYWx1ZTxULCBFPjtcblxuICAvKipcbiAgICogVGhpcyBtZXRob2QgdXBkYXRlcyB0aGUgY3VycmVudCB2YWx1ZSB3aXRoIGEgbmV3IG9uZS5cbiAgICovXG4gIHVwZGF0ZSh2YWx1ZTogVCk6IFN0cmVhbWFibGVWYWx1ZVdyYXBwZXI8VCwgRT47XG5cbiAgLyoqXG4gICAqIFRoaXMgbWV0aG9kIGlzIHVzZWQgdG8gYXBwZW5kIGEgZGVsdGEgc3RyaW5nIHRvIHRoZSBjdXJyZW50IHZhbHVlLiBJdFxuICAgKiByZXF1aXJlcyB0aGUgY3VycmVudCB2YWx1ZSBvZiB0aGUgc3RyZWFtYWJsZSB0byBiZSBhIHN0cmluZy5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogYGBganN4XG4gICAqIGNvbnN0IHN0cmVhbWFibGUgPSBjcmVhdGVTdHJlYW1hYmxlVmFsdWUoJ2hlbGxvJyk7XG4gICAqIHN0cmVhbWFibGUuYXBwZW5kKCcgd29ybGQnKTtcbiAgICpcbiAgICogLy8gVGhlIHZhbHVlIHdpbGwgYmUgJ2hlbGxvIHdvcmxkJ1xuICAgKiBgYGBcbiAgICovXG4gIGFwcGVuZCh2YWx1ZTogVCk6IFN0cmVhbWFibGVWYWx1ZVdyYXBwZXI8VCwgRT47XG5cbiAgLyoqXG4gICAqIFRoaXMgbWV0aG9kIGlzIHVzZWQgdG8gc2lnbmFsIHRoYXQgdGhlcmUgaXMgYW4gZXJyb3IgaW4gdGhlIHZhbHVlIHN0cmVhbS5cbiAgICogSXQgd2lsbCBiZSB0aHJvd24gb24gdGhlIGNsaWVudCBzaWRlIHdoZW4gY29uc3VtZWQgdmlhXG4gICAqIGByZWFkU3RyZWFtYWJsZVZhbHVlYCBvciBgdXNlU3RyZWFtYWJsZVZhbHVlYC5cbiAgICovXG4gIGVycm9yKGVycm9yOiBhbnkpOiBTdHJlYW1hYmxlVmFsdWVXcmFwcGVyPFQsIEU+O1xuXG4gIC8qKlxuICAgKiBUaGlzIG1ldGhvZCBtYXJrcyB0aGUgdmFsdWUgYXMgZmluYWxpemVkLiBZb3UgY2FuIGVpdGhlciBjYWxsIGl0IHdpdGhvdXRcbiAgICogYW55IHBhcmFtZXRlcnMgb3Igd2l0aCBhIG5ldyB2YWx1ZSBhcyB0aGUgZmluYWwgc3RhdGUuXG4gICAqIE9uY2UgY2FsbGVkLCB0aGUgdmFsdWUgY2Fubm90IGJlIHVwZGF0ZWQgb3IgYXBwZW5kZWQgYW55bW9yZS5cbiAgICpcbiAgICogVGhpcyBtZXRob2QgaXMgYWx3YXlzICoqcmVxdWlyZWQqKiB0byBiZSBjYWxsZWQsIG90aGVyd2lzZSB0aGUgcmVzcG9uc2VcbiAgICogd2lsbCBiZSBzdHVjayBpbiBhIGxvYWRpbmcgc3RhdGUuXG4gICAqL1xuICBkb25lKC4uLmFyZ3M6IFtUXSB8IFtdKTogU3RyZWFtYWJsZVZhbHVlV3JhcHBlcjxULCBFPjtcblxuICAvKipcbiAgICogQGludGVybmFsIFRoaXMgaXMgYW4gaW50ZXJuYWwgbG9jayB0byBwcmV2ZW50IHRoZSB2YWx1ZSBmcm9tIGJlaW5nXG4gICAqIHVwZGF0ZWQgYnkgdGhlIHVzZXIuXG4gICAqL1xuICBbU1RSRUFNQUJMRV9WQUxVRV9JTlRFUk5BTF9MT0NLXTogYm9vbGVhbjtcbn07XG5cbmZ1bmN0aW9uIGNyZWF0ZVN0cmVhbWFibGVWYWx1ZUltcGw8VCA9IGFueSwgRSA9IGFueT4oaW5pdGlhbFZhbHVlPzogVCkge1xuICBsZXQgY2xvc2VkID0gZmFsc2U7XG4gIGxldCBsb2NrZWQgPSBmYWxzZTtcbiAgbGV0IHJlc29sdmFibGUgPSBjcmVhdGVSZXNvbHZhYmxlUHJvbWlzZTxTdHJlYW1hYmxlVmFsdWU8VCwgRT4+KCk7XG5cbiAgbGV0IGN1cnJlbnRWYWx1ZSA9IGluaXRpYWxWYWx1ZTtcbiAgbGV0IGN1cnJlbnRFcnJvcjogRSB8IHVuZGVmaW5lZDtcbiAgbGV0IGN1cnJlbnRQcm9taXNlOiB0eXBlb2YgcmVzb2x2YWJsZS5wcm9taXNlIHwgdW5kZWZpbmVkID1cbiAgICByZXNvbHZhYmxlLnByb21pc2U7XG4gIGxldCBjdXJyZW50UGF0Y2hWYWx1ZTogU3RyZWFtYWJsZVBhdGNoO1xuXG4gIGZ1bmN0aW9uIGFzc2VydFN0cmVhbShtZXRob2Q6IHN0cmluZykge1xuICAgIGlmIChjbG9zZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihtZXRob2QgKyAnOiBWYWx1ZSBzdHJlYW0gaXMgYWxyZWFkeSBjbG9zZWQuJyk7XG4gICAgfVxuICAgIGlmIChsb2NrZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgbWV0aG9kICsgJzogVmFsdWUgc3RyZWFtIGlzIGxvY2tlZCBhbmQgY2Fubm90IGJlIHVwZGF0ZWQuJyxcbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgbGV0IHdhcm5pbmdUaW1lb3V0OiBOb2RlSlMuVGltZW91dCB8IHVuZGVmaW5lZDtcbiAgZnVuY3Rpb24gd2FyblVuY2xvc2VkU3RyZWFtKCkge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50Jykge1xuICAgICAgaWYgKHdhcm5pbmdUaW1lb3V0KSB7XG4gICAgICAgIGNsZWFyVGltZW91dCh3YXJuaW5nVGltZW91dCk7XG4gICAgICB9XG4gICAgICB3YXJuaW5nVGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgJ1RoZSBzdHJlYW1hYmxlIHZhbHVlIGhhcyBiZWVuIHNsb3cgdG8gdXBkYXRlLiBUaGlzIG1heSBiZSBhIGJ1ZyBvciBhIHBlcmZvcm1hbmNlIGlzc3VlIG9yIHlvdSBmb3Jnb3QgdG8gY2FsbCBgLmRvbmUoKWAuJyxcbiAgICAgICAgKTtcbiAgICAgIH0sIEhBTkdJTkdfU1RSRUFNX1dBUk5JTkdfVElNRV9NUyk7XG4gICAgfVxuICB9XG4gIHdhcm5VbmNsb3NlZFN0cmVhbSgpO1xuXG4gIGZ1bmN0aW9uIGNyZWF0ZVdyYXBwZWQoaW5pdGlhbENodW5rPzogYm9vbGVhbik6IFN0cmVhbWFibGVWYWx1ZTxULCBFPiB7XG4gICAgLy8gVGhpcyBtYWtlcyB0aGUgcGF5bG9hZCBtdWNoIHNtYWxsZXIgaWYgdGhlcmUncmUgbXV0YXRpdmUgdXBkYXRlcyBiZWZvcmUgdGhlIGZpcnN0IHJlYWQuXG4gICAgbGV0IGluaXQ6IFBhcnRpYWw8U3RyZWFtYWJsZVZhbHVlPFQsIEU+PjtcblxuICAgIGlmIChjdXJyZW50RXJyb3IgIT09IHVuZGVmaW5lZCkge1xuICAgICAgaW5pdCA9IHsgZXJyb3I6IGN1cnJlbnRFcnJvciB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoY3VycmVudFBhdGNoVmFsdWUgJiYgIWluaXRpYWxDaHVuaykge1xuICAgICAgICBpbml0ID0geyBkaWZmOiBjdXJyZW50UGF0Y2hWYWx1ZSB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaW5pdCA9IHsgY3VycjogY3VycmVudFZhbHVlIH07XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGN1cnJlbnRQcm9taXNlKSB7XG4gICAgICBpbml0Lm5leHQgPSBjdXJyZW50UHJvbWlzZTtcbiAgICB9XG5cbiAgICBpZiAoaW5pdGlhbENodW5rKSB7XG4gICAgICBpbml0LnR5cGUgPSBTVFJFQU1BQkxFX1ZBTFVFX1RZUEU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGluaXQ7XG4gIH1cblxuICAvLyBVcGRhdGUgdGhlIGludGVybmFsIGBjdXJyZW50VmFsdWVgIGFuZCBgY3VycmVudFBhdGNoVmFsdWVgIGlmIG5lZWRlZC5cbiAgZnVuY3Rpb24gdXBkYXRlVmFsdWVTdGF0ZXModmFsdWU6IFQpIHtcbiAgICAvLyBJZiB3ZSBjYW4gb25seSBzZW5kIGEgcGF0Y2ggb3ZlciB0aGUgd2lyZSwgaXQncyBiZXR0ZXIgdG8gZG8gc28uXG4gICAgY3VycmVudFBhdGNoVmFsdWUgPSB1bmRlZmluZWQ7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGlmICh0eXBlb2YgY3VycmVudFZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICBpZiAodmFsdWUuc3RhcnRzV2l0aChjdXJyZW50VmFsdWUpKSB7XG4gICAgICAgICAgY3VycmVudFBhdGNoVmFsdWUgPSBbMCwgdmFsdWUuc2xpY2UoY3VycmVudFZhbHVlLmxlbmd0aCldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgY3VycmVudFZhbHVlID0gdmFsdWU7XG4gIH1cblxuICBjb25zdCBzdHJlYW1hYmxlOiBTdHJlYW1hYmxlVmFsdWVXcmFwcGVyPFQsIEU+ID0ge1xuICAgIHNldCBbU1RSRUFNQUJMRV9WQUxVRV9JTlRFUk5BTF9MT0NLXShzdGF0ZTogYm9vbGVhbikge1xuICAgICAgbG9ja2VkID0gc3RhdGU7XG4gICAgfSxcbiAgICBnZXQgdmFsdWUoKSB7XG4gICAgICByZXR1cm4gY3JlYXRlV3JhcHBlZCh0cnVlKTtcbiAgICB9LFxuICAgIHVwZGF0ZSh2YWx1ZTogVCkge1xuICAgICAgYXNzZXJ0U3RyZWFtKCcudXBkYXRlKCknKTtcblxuICAgICAgY29uc3QgcmVzb2x2ZVByZXZpb3VzID0gcmVzb2x2YWJsZS5yZXNvbHZlO1xuICAgICAgcmVzb2x2YWJsZSA9IGNyZWF0ZVJlc29sdmFibGVQcm9taXNlKCk7XG5cbiAgICAgIHVwZGF0ZVZhbHVlU3RhdGVzKHZhbHVlKTtcbiAgICAgIGN1cnJlbnRQcm9taXNlID0gcmVzb2x2YWJsZS5wcm9taXNlO1xuICAgICAgcmVzb2x2ZVByZXZpb3VzKGNyZWF0ZVdyYXBwZWQoKSk7XG5cbiAgICAgIHdhcm5VbmNsb3NlZFN0cmVhbSgpO1xuXG4gICAgICByZXR1cm4gc3RyZWFtYWJsZTtcbiAgICB9LFxuICAgIGFwcGVuZCh2YWx1ZTogVCkge1xuICAgICAgYXNzZXJ0U3RyZWFtKCcuYXBwZW5kKCknKTtcblxuICAgICAgaWYgKFxuICAgICAgICB0eXBlb2YgY3VycmVudFZhbHVlICE9PSAnc3RyaW5nJyAmJlxuICAgICAgICB0eXBlb2YgY3VycmVudFZhbHVlICE9PSAndW5kZWZpbmVkJ1xuICAgICAgKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICBgLmFwcGVuZCgpOiBUaGUgY3VycmVudCB2YWx1ZSBpcyBub3QgYSBzdHJpbmcuIFJlY2VpdmVkOiAke3R5cGVvZiBjdXJyZW50VmFsdWV9YCxcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICBgLmFwcGVuZCgpOiBUaGUgdmFsdWUgaXMgbm90IGEgc3RyaW5nLiBSZWNlaXZlZDogJHt0eXBlb2YgdmFsdWV9YCxcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgcmVzb2x2ZVByZXZpb3VzID0gcmVzb2x2YWJsZS5yZXNvbHZlO1xuICAgICAgcmVzb2x2YWJsZSA9IGNyZWF0ZVJlc29sdmFibGVQcm9taXNlKCk7XG5cbiAgICAgIGlmICh0eXBlb2YgY3VycmVudFZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICBjdXJyZW50UGF0Y2hWYWx1ZSA9IFswLCB2YWx1ZV07XG4gICAgICAgIChjdXJyZW50VmFsdWUgYXMgc3RyaW5nKSA9IGN1cnJlbnRWYWx1ZSArIHZhbHVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY3VycmVudFBhdGNoVmFsdWUgPSB1bmRlZmluZWQ7XG4gICAgICAgIGN1cnJlbnRWYWx1ZSA9IHZhbHVlO1xuICAgICAgfVxuXG4gICAgICBjdXJyZW50UHJvbWlzZSA9IHJlc29sdmFibGUucHJvbWlzZTtcbiAgICAgIHJlc29sdmVQcmV2aW91cyhjcmVhdGVXcmFwcGVkKCkpO1xuXG4gICAgICB3YXJuVW5jbG9zZWRTdHJlYW0oKTtcblxuICAgICAgcmV0dXJuIHN0cmVhbWFibGU7XG4gICAgfSxcbiAgICBlcnJvcihlcnJvcjogYW55KSB7XG4gICAgICBhc3NlcnRTdHJlYW0oJy5lcnJvcigpJyk7XG5cbiAgICAgIGlmICh3YXJuaW5nVGltZW91dCkge1xuICAgICAgICBjbGVhclRpbWVvdXQod2FybmluZ1RpbWVvdXQpO1xuICAgICAgfVxuICAgICAgY2xvc2VkID0gdHJ1ZTtcbiAgICAgIGN1cnJlbnRFcnJvciA9IGVycm9yO1xuICAgICAgY3VycmVudFByb21pc2UgPSB1bmRlZmluZWQ7XG5cbiAgICAgIHJlc29sdmFibGUucmVzb2x2ZSh7IGVycm9yIH0pO1xuXG4gICAgICByZXR1cm4gc3RyZWFtYWJsZTtcbiAgICB9LFxuICAgIGRvbmUoLi4uYXJnczogW10gfCBbVF0pIHtcbiAgICAgIGFzc2VydFN0cmVhbSgnLmRvbmUoKScpO1xuXG4gICAgICBpZiAod2FybmluZ1RpbWVvdXQpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHdhcm5pbmdUaW1lb3V0KTtcbiAgICAgIH1cbiAgICAgIGNsb3NlZCA9IHRydWU7XG4gICAgICBjdXJyZW50UHJvbWlzZSA9IHVuZGVmaW5lZDtcblxuICAgICAgaWYgKGFyZ3MubGVuZ3RoKSB7XG4gICAgICAgIHVwZGF0ZVZhbHVlU3RhdGVzKGFyZ3NbMF0pO1xuICAgICAgICByZXNvbHZhYmxlLnJlc29sdmUoY3JlYXRlV3JhcHBlZCgpKTtcbiAgICAgICAgcmV0dXJuIHN0cmVhbWFibGU7XG4gICAgICB9XG5cbiAgICAgIHJlc29sdmFibGUucmVzb2x2ZSh7fSk7XG5cbiAgICAgIHJldHVybiBzdHJlYW1hYmxlO1xuICAgIH0sXG4gIH07XG5cbiAgcmV0dXJuIHN0cmVhbWFibGU7XG59XG5cbmV4cG9ydCB7IGNyZWF0ZVN0cmVhbWFibGVWYWx1ZSB9O1xuIl0sIm5hbWVzIjpbImpzb25kaWZmcGF0Y2giLCJBc3luY0xvY2FsU3RvcmFnZSIsImNyZWF0ZVJlc29sdmFibGVQcm9taXNlIiwicmVzb2x2ZSIsInJlamVjdCIsInByb21pc2UiLCJQcm9taXNlIiwicmVzIiwicmVqIiwiaXNGdW5jdGlvbiIsInZhbHVlIiwiYXN5bmNBSVN0YXRlU3RvcmFnZSIsImdldEFJU3RhdGVTdG9yZU9yVGhyb3ciLCJtZXNzYWdlIiwic3RvcmUiLCJnZXRTdG9yZSIsIkVycm9yIiwid2l0aEFJU3RhdGUiLCJzdGF0ZSIsIm9wdGlvbnMiLCJmbiIsInJ1biIsImN1cnJlbnRTdGF0ZSIsIkpTT04iLCJwYXJzZSIsInN0cmluZ2lmeSIsIm9yaWdpbmFsU3RhdGUiLCJzZWFsZWQiLCJnZXRBSVN0YXRlRGVsdGFQcm9taXNlIiwibXV0YXRpb25EZWx0YVByb21pc2UiLCJzZWFsTXV0YWJsZUFJU3RhdGUiLCJnZXRBSVN0YXRlIiwiYXJncyIsImxlbmd0aCIsImtleSIsIlN0cmluZyIsImdldE11dGFibGVBSVN0YXRlIiwibXV0YXRpb25EZWx0YVJlc29sdmUiLCJkb1VwZGF0ZSIsIm5ld1N0YXRlIiwiZG9uZSIsIl9hIiwiX2IiLCJvblNldEFJU3RhdGUiLCJjYWxsIiwibXV0YWJsZVN0YXRlIiwiZ2V0IiwidXBkYXRlIiwibmV3QUlTdGF0ZSIsImRvbmVBcmdzIiwiZGVsdGEiLCJkaWZmIiwiUmVhY3QiLCJJbnRlcm5hbEFJUHJvdmlkZXIiLCJqc3giLCJpbm5lckFjdGlvbiIsImFjdGlvbiIsInJlc3VsdCIsIndyYXBBY3Rpb24iLCJiaW5kIiwiY3JlYXRlQUkiLCJhY3Rpb25zIiwiaW5pdGlhbEFJU3RhdGUiLCJpbml0aWFsVUlTdGF0ZSIsIm9uR2V0VUlTdGF0ZSIsIndyYXBwZWRBY3Rpb25zIiwibmFtZSIsIndyYXBwZWRTeW5jVUlTdGF0ZSIsIkFJIiwicHJvcHMiLCJ1aVN0YXRlIiwiYWlTdGF0ZSIsImFpU3RhdGVEZWx0YSIsIm5ld0FJU3RhdGVEZWx0YSIsIm5ld1VJU3RhdGUiLCJpbml0aWFsQUlTdGF0ZVBhdGNoIiwiY2hpbGRyZW4iLCJzYWZlUGFyc2VKU09OIiwiQUlTREtFcnJvciIsIm1hcmtlciIsInN5bWJvbCIsIlN5bWJvbCIsImZvciIsIkRvd25sb2FkRXJyb3IiLCJjb25zdHJ1Y3RvciIsInVybCIsInN0YXR1c0NvZGUiLCJzdGF0dXNUZXh0IiwiY2F1c2UiLCJpc0luc3RhbmNlIiwiZXJyb3IiLCJoYXNNYXJrZXIiLCJpc0Rvd25sb2FkRXJyb3IiLCJ0b0pTT04iLCJkb3dubG9hZCIsImZldGNoSW1wbGVtZW50YXRpb24iLCJmZXRjaCIsInVybFRleHQiLCJ0b1N0cmluZyIsInJlc3BvbnNlIiwib2siLCJzdGF0dXMiLCJkYXRhIiwiVWludDhBcnJheSIsImFycmF5QnVmZmVyIiwibWltZVR5cGUiLCJoZWFkZXJzIiwibWltZVR5cGVTaWduYXR1cmVzIiwiYnl0ZXMiLCJkZXRlY3RJbWFnZU1pbWVUeXBlIiwiaW1hZ2UiLCJldmVyeSIsImJ5dGUiLCJpbmRleCIsImNvbnZlcnRCYXNlNjRUb1VpbnQ4QXJyYXkiLCJjb252ZXJ0VWludDhBcnJheVRvQmFzZTY0IiwiSW52YWxpZERhdGFDb250ZW50RXJyb3IiLCJjb250ZW50IiwiaXNJbnZhbGlkRGF0YUNvbnRlbnRFcnJvciIsInN0YWNrIiwieiIsImRhdGFDb250ZW50U2NoZW1hIiwidW5pb24iLCJzdHJpbmciLCJpbnN0YW5jZW9mIiwiQXJyYXlCdWZmZXIiLCJjdXN0b20iLCJnbG9iYWxUaGlzIiwiQnVmZmVyIiwiaXNCdWZmZXIiLCJjb252ZXJ0RGF0YUNvbnRlbnRUb0Jhc2U2NFN0cmluZyIsImNvbnZlcnREYXRhQ29udGVudFRvVWludDhBcnJheSIsImNvbnZlcnRVaW50OEFycmF5VG9UZXh0IiwidWludDhBcnJheSIsIlRleHREZWNvZGVyIiwiZGVjb2RlIiwiSW52YWxpZE1lc3NhZ2VSb2xlRXJyb3IiLCJyb2xlIiwiaXNJbnZhbGlkTWVzc2FnZVJvbGVFcnJvciIsInNwbGl0RGF0YVVybCIsImRhdGFVcmwiLCJoZWFkZXIiLCJiYXNlNjRDb250ZW50Iiwic3BsaXQiLCJjb252ZXJ0VG9MYW5ndWFnZU1vZGVsUHJvbXB0IiwicHJvbXB0IiwibW9kZWxTdXBwb3J0c0ltYWdlVXJscyIsIm1vZGVsU3VwcG9ydHNVcmwiLCJkb3dubG9hZEltcGxlbWVudGF0aW9uIiwiZG93bmxvYWRlZEFzc2V0cyIsImRvd25sb2FkQXNzZXRzIiwibWVzc2FnZXMiLCJzeXN0ZW0iLCJtYXAiLCJjb252ZXJ0VG9MYW5ndWFnZU1vZGVsTWVzc2FnZSIsInByb3ZpZGVyTWV0YWRhdGEiLCJleHBlcmltZW50YWxfcHJvdmlkZXJNZXRhZGF0YSIsInR5cGUiLCJ0ZXh0IiwicGFydCIsImNvbnZlcnRQYXJ0VG9MYW5ndWFnZU1vZGVsUGFydCIsImZpbHRlciIsInJlc3QiLCJ0b29sQ2FsbElkIiwidG9vbE5hbWUiLCJleHBlcmltZW50YWxfY29udGVudCIsImlzRXJyb3IiLCJfZXhoYXVzdGl2ZUNoZWNrIiwidXJscyIsIkFycmF5IiwiaXNBcnJheSIsImZsYXQiLCJzdGFydHNXaXRoIiwiVVJMIiwiZG93bmxvYWRlZEltYWdlcyIsImFsbCIsIk9iamVjdCIsImZyb21FbnRyaWVzIiwibm9ybWFsaXplZERhdGEiLCJwcm90b2NvbCIsImRhdGFVcmxNaW1lVHlwZSIsImRvd25sb2FkZWRGaWxlIiwiSW52YWxpZEFyZ3VtZW50RXJyb3IiLCJwYXJhbWV0ZXIiLCJpc0ludmFsaWRBcmd1bWVudEVycm9yIiwicHJlcGFyZUNhbGxTZXR0aW5ncyIsIm1heFRva2VucyIsInRlbXBlcmF0dXJlIiwidG9wUCIsInRvcEsiLCJwcmVzZW5jZVBlbmFsdHkiLCJmcmVxdWVuY3lQZW5hbHR5Iiwic3RvcFNlcXVlbmNlcyIsInNlZWQiLCJtYXhSZXRyaWVzIiwiTnVtYmVyIiwiaXNJbnRlZ2VyIiwiYXNTY2hlbWEiLCJpc05vbkVtcHR5T2JqZWN0Iiwib2JqZWN0Iiwia2V5cyIsInByZXBhcmVUb29sc0FuZFRvb2xDaG9pY2UiLCJ0b29scyIsInRvb2xDaG9pY2UiLCJhY3RpdmVUb29scyIsImZpbHRlcmVkVG9vbHMiLCJlbnRyaWVzIiwiaW5jbHVkZXMiLCJ0b29sIiwidG9vbFR5cGUiLCJkZXNjcmlwdGlvbiIsInBhcmFtZXRlcnMiLCJqc29uU2NoZW1hIiwiaWQiLCJleGhhdXN0aXZlQ2hlY2siLCJJbnZhbGlkUHJvbXB0RXJyb3IiLCJzYWZlVmFsaWRhdGVUeXBlcyIsImpzb25WYWx1ZVNjaGVtYSIsImxhenkiLCJudWxsIiwibnVtYmVyIiwiYm9vbGVhbiIsInJlY29yZCIsImFycmF5IiwicHJvdmlkZXJNZXRhZGF0YVNjaGVtYSIsInRvb2xSZXN1bHRDb250ZW50U2NoZW1hIiwibGl0ZXJhbCIsIm9wdGlvbmFsIiwidGV4dFBhcnRTY2hlbWEiLCJpbWFnZVBhcnRTY2hlbWEiLCJmaWxlUGFydFNjaGVtYSIsInRvb2xDYWxsUGFydFNjaGVtYSIsInVua25vd24iLCJ0b29sUmVzdWx0UGFydFNjaGVtYSIsImNvcmVTeXN0ZW1NZXNzYWdlU2NoZW1hIiwiY29yZVVzZXJNZXNzYWdlU2NoZW1hIiwiY29yZUFzc2lzdGFudE1lc3NhZ2VTY2hlbWEiLCJjb3JlVG9vbE1lc3NhZ2VTY2hlbWEiLCJjb3JlTWVzc2FnZVNjaGVtYSIsImRldGVjdFByb21wdFR5cGUiLCJjaGFyYWN0ZXJpc3RpY3MiLCJkZXRlY3RTaW5nbGVNZXNzYWdlQ2hhcmFjdGVyaXN0aWNzIiwic29tZSIsImMiLCJhdHRhY2htZW50c1RvUGFydHMiLCJhdHRhY2htZW50cyIsIl9jIiwicGFydHMiLCJhdHRhY2htZW50IiwiY29udGVudFR5cGUiLCJwdXNoIiwiTWVzc2FnZUNvbnZlcnNpb25FcnJvciIsIm9yaWdpbmFsTWVzc2FnZSIsImNvbnZlcnRUb0NvcmVNZXNzYWdlcyIsImNvcmVNZXNzYWdlcyIsInRvb2xJbnZvY2F0aW9ucyIsImV4cGVyaW1lbnRhbF9hdHRhY2htZW50cyIsInRvb2xJbnZvY2F0aW9uIiwiZXhwZXJpbWVudGFsX3RvVG9vbFJlc3VsdENvbnRlbnQiLCJzdGFuZGFyZGl6ZVByb21wdCIsInByb21wdFR5cGUiLCJ2YWxpZGF0aW9uUmVzdWx0Iiwic2NoZW1hIiwic3VjY2VzcyIsImNhbGN1bGF0ZUxhbmd1YWdlTW9kZWxVc2FnZSIsInVzYWdlIiwicHJvbXB0VG9rZW5zIiwiY29tcGxldGlvblRva2VucyIsInRvdGFsVG9rZW5zIiwiZ2V0RXJyb3JNZXNzYWdlIiwiSW52YWxpZFRvb2xBcmd1bWVudHNFcnJvciIsInRvb2xBcmdzIiwiaXNJbnZhbGlkVG9vbEFyZ3VtZW50c0Vycm9yIiwiTm9TdWNoVG9vbEVycm9yIiwiYXZhaWxhYmxlVG9vbHMiLCJqb2luIiwiaXNOb1N1Y2hUb29sRXJyb3IiLCJpc0FzeW5jR2VuZXJhdG9yIiwiYXN5bmNJdGVyYXRvciIsImlzR2VuZXJhdG9yIiwiaXRlcmF0b3IiLCJBUElDYWxsRXJyb3IiLCJpc0Fib3J0RXJyb3IiLCJkZWxheSIsImRlbGF5SW5NcyIsInNldFRpbWVvdXQiLCJSZXRyeUVycm9yIiwicmVhc29uIiwiZXJyb3JzIiwibGFzdEVycm9yIiwiaXNSZXRyeUVycm9yIiwicmV0cnlXaXRoRXhwb25lbnRpYWxCYWNrb2ZmIiwiaW5pdGlhbERlbGF5SW5NcyIsImJhY2tvZmZGYWN0b3IiLCJmIiwiX3JldHJ5V2l0aEV4cG9uZW50aWFsQmFja29mZiIsImVycm9yTWVzc2FnZSIsIm5ld0Vycm9ycyIsInRyeU51bWJlciIsImlzQVBJQ2FsbEVycm9yIiwiaXNSZXRyeWFibGUiLCJIQU5HSU5HX1NUUkVBTV9XQVJOSU5HX1RJTUVfTVMiLCJTdXNwZW5zZSIsIkZyYWdtZW50IiwianN4cyIsIlIiLCJjdXJyZW50IiwibiIsIm5leHQiLCJjaHVuayIsImFwcGVuZCIsImZhbGxiYWNrIiwiY3JlYXRlU3VzcGVuZGVkQ2h1bmsiLCJpbml0aWFsVmFsdWUiLCJyb3ciLCJjcmVhdGVTdHJlYW1hYmxlVUkiLCJjdXJyZW50VmFsdWUiLCJjbG9zZWQiLCJhc3NlcnRTdHJlYW0iLCJtZXRob2QiLCJ3YXJuaW5nVGltZW91dCIsIndhcm5VbmNsb3NlZFN0cmVhbSIsInByb2Nlc3MiLCJjbGVhclRpbWVvdXQiLCJjb25zb2xlIiwid2FybiIsInN0cmVhbWFibGUiLCJyZXNvbHZhYmxlIiwiZGVmYXVsdFRleHRSZW5kZXJlciIsInN0cmVhbVVJIiwibW9kZWwiLCJhYm9ydFNpZ25hbCIsImluaXRpYWwiLCJvbkZpbmlzaCIsInNldHRpbmdzIiwidWkiLCJ0ZXh0UmVuZGVyIiwiZmluaXNoZWQiLCJmaW5pc2hFdmVudCIsInJlbmRlciIsInJlbmRlcmVyIiwic3RyZWFtYWJsZVVJIiwiaXNMYXN0Q2FsbCIsInJlbmRlckZpbmlzaGVkIiwidGhlbiIsInJlbmRlcmVyUmVzdWx0Iiwibm9kZSIsInJldHJ5IiwidmFsaWRhdGVkUHJvbXB0IiwiZG9TdHJlYW0iLCJtb2RlIiwiaW5wdXRGb3JtYXQiLCJzdXBwb3J0c0ltYWdlVXJscyIsInN1cHBvcnRzVXJsIiwic3RyZWFtIiwiZm9ya2VkU3RyZWFtIiwidGVlIiwiaGFzVG9vbENhbGwiLCJyZWFkZXIiLCJnZXRSZWFkZXIiLCJyZWFkIiwidGV4dERlbHRhIiwicGFyc2VSZXN1bHQiLCJnZW5lcmF0ZSIsImZpbmlzaFJlYXNvbiIsIndhcm5pbmdzIiwicmF3UmVzcG9uc2UiLCJ6b2RUb0pzb25TY2hlbWEiLCJjcmVhdGVQYXJzZXIiLCJjcmVhdGVFdmVudFN0cmVhbVRyYW5zZm9ybWVyIiwiY3VzdG9tUGFyc2VyIiwidGV4dERlY29kZXIiLCJldmVudFNvdXJjZVBhcnNlciIsIlRyYW5zZm9ybVN0cmVhbSIsInN0YXJ0IiwiY29udHJvbGxlciIsImV2ZW50IiwidGVybWluYXRlIiwicGFyc2VkTWVzc2FnZSIsImVucXVldWUiLCJ0cmFuc2Zvcm0iLCJmZWVkIiwiY3JlYXRlQ2FsbGJhY2tzVHJhbnNmb3JtZXIiLCJjYiIsInRleHRFbmNvZGVyIiwiVGV4dEVuY29kZXIiLCJhZ2dyZWdhdGVkUmVzcG9uc2UiLCJjYWxsYmFja3MiLCJvblN0YXJ0IiwiZW5jb2RlIiwib25Ub2tlbiIsIm9uVGV4dCIsImZsdXNoIiwiaXNPcGVuQUlDYWxsYmFja3MiLCJpc09mVHlwZU9wZW5BSVN0cmVhbUNhbGxiYWNrcyIsIm9uQ29tcGxldGlvbiIsIm9uRmluYWwiLCJ0cmltU3RhcnRPZlN0cmVhbUhlbHBlciIsImlzU3RyZWFtU3RhcnQiLCJ0cmltU3RhcnQiLCJBSVN0cmVhbSIsImJvZHkiLCJSZWFkYWJsZVN0cmVhbSIsImVycm9yVGV4dCIsInJlc3BvbnNlQm9keVN0cmVhbSIsImNyZWF0ZUVtcHR5UmVhZGFibGVTdHJlYW0iLCJwaXBlVGhyb3VnaCIsImNsb3NlIiwicmVhZGFibGVGcm9tQXN5bmNJdGVyYWJsZSIsIml0ZXJhYmxlIiwiaXQiLCJwdWxsIiwiY2FuY2VsIiwicmV0dXJuIiwiZm9ybWF0U3RyZWFtUGFydCIsImNyZWF0ZVN0cmVhbURhdGFUcmFuc2Zvcm1lciIsImVuY29kZXIiLCJkZWNvZGVyIiwiY3JlYXRlQ2h1bmtEZWNvZGVyIiwicGFyc2VPcGVuQUlTdHJlYW0iLCJleHRyYWN0IiwiY2h1bmtUb1RleHQiLCJjcmVhdGVkIiwiZ2V0RGF0ZSIsImNob2ljZXMiLCJjaG9pY2UiLCJfZCIsIl9lIiwiX2YiLCJfZyIsImZ1bmN0aW9uX2NhbGwiLCJmdW5jdGlvbkNhbGwiLCJ0b29sX2NhbGxzIiwidG9vbENhbGxzIiwidG9vbENhbGwiLCJmdW5jdGlvbiIsImZpbmlzaF9yZWFzb24iLCJ0cmltU3RhcnRPZlN0cmVhbSIsImlzRnVuY3Rpb25TdHJlYW1pbmdJbiIsImpzb24iLCJfaCIsIl9pIiwiX2oiLCJfayIsIl9sIiwiX20iLCJfbiIsIl9vIiwiX3AiLCJfcSIsIl9yIiwiaXNDaGF0Q29tcGxldGlvbkNodW5rIiwiaXNUZXh0IiwiYXJndW1lbnRzIiwiY2xlYW51cEFyZ3VtZW50cyIsImlzQ29tcGxldGlvbiIsImFyZ3VtZW50Q2h1bmsiLCJlc2NhcGVkUGFydGlhbEpzb24iLCJyZXBsYWNlIiwiX19pbnRlcm5hbF9fT3BlbkFJRm5NZXNzYWdlc1N5bWJvbCIsIk9wZW5BSVN0cmVhbSIsImV4cGVyaW1lbnRhbF9vbkZ1bmN0aW9uQ2FsbCIsImV4cGVyaW1lbnRhbF9vblRvb2xDYWxsIiwiZnVuY3Rpb25DYWxsVHJhbnNmb3JtZXIiLCJjcmVhdGVGdW5jdGlvbkNhbGxUcmFuc2Zvcm1lciIsImlzRmlyc3RDaHVuayIsImFnZ3JlZ2F0ZWRGaW5hbENvbXBsZXRpb25SZXNwb25zZSIsImZ1bmN0aW9uQ2FsbE1lc3NhZ2VzIiwic2hvdWxkSGFuZGxlQXNGdW5jdGlvbiIsInBheWxvYWQiLCJuZXdGdW5jdGlvbkNhbGxNZXNzYWdlcyIsImZ1bmN0aW9uUmVzcG9uc2UiLCJhcmd1bWVudHNQYXlsb2FkIiwiZnVuYyIsInJlc3BvbnNlSW5kZXgiLCJ0b29sX2NhbGxfaWQiLCJmdW5jdGlvbl9uYW1lIiwidG9vbF9jYWxsX3Jlc3VsdCIsInRjIiwiZSIsImZpbHRlcmVkQ2FsbGJhY2tzIiwib3BlbkFJU3RyZWFtIiwiY29uc3VtZVN0cmVhbSIsImZ1bmN0aW9ucyIsImhhbmRsZVJlbmRlciIsImhhc0Z1bmN0aW9uIiwicHJvdmlkZXIiLCJjaGF0IiwiY29tcGxldGlvbnMiLCJjcmVhdGUiLCJmdW5jdGlvbkNhbGxQYXlsb2FkIiwidG9vbENhbGxQYXlsb2FkIiwiU1RSRUFNQUJMRV9WQUxVRV9UWVBFIiwiU1RSRUFNQUJMRV9WQUxVRV9JTlRFUk5BTF9MT0NLIiwiY3JlYXRlU3RyZWFtYWJsZVZhbHVlIiwiaXNSZWFkYWJsZVN0cmVhbSIsImxvY2tlZCIsImNyZWF0ZVN0cmVhbWFibGVWYWx1ZUltcGwiLCJzdHJlYW1hYmxlVmFsdWUiLCJjdXJyZW50RXJyb3IiLCJjdXJyZW50UHJvbWlzZSIsImN1cnJlbnRQYXRjaFZhbHVlIiwiY3JlYXRlV3JhcHBlZCIsImluaXRpYWxDaHVuayIsImluaXQiLCJjdXJyIiwidXBkYXRlVmFsdWVTdGF0ZXMiLCJzbGljZSIsInJlc29sdmVQcmV2aW91cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/.pnpm/ai@3.4.33_openai@4.79.1_ws@8.18.0_zod@3.24.1__react@18.3.1_sswr@2.1.0_svelte@5.19.0__svelte@5_pdcg7nlabbjux4kj5rjyhlky2i/node_modules/ai/rsc/dist/rsc-server.mjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/.pnpm/ai@3.4.33_openai@4.79.1_ws@8.18.0_zod@3.24.1__react@18.3.1_sswr@2.1.0_svelte@5.19.0__svelte@5_pdcg7nlabbjux4kj5rjyhlky2i/node_modules/ai/rsc/dist/rsc-shared.mjs":
/*!*********************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/ai@3.4.33_openai@4.79.1_ws@8.18.0_zod@3.24.1__react@18.3.1_sswr@2.1.0_svelte@5.19.0__svelte@5_pdcg7nlabbjux4kj5rjyhlky2i/node_modules/ai/rsc/dist/rsc-shared.mjs ***!
  \*********************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   InternalAIProvider: () => (/* binding */ e0),
/* harmony export */   readStreamableValue: () => (/* binding */ e1),
/* harmony export */   useAIState: () => (/* binding */ e2),
/* harmony export */   useActions: () => (/* binding */ e3),
/* harmony export */   useStreamableValue: () => (/* binding */ e4),
/* harmony export */   useSyncUIState: () => (/* binding */ e5),
/* harmony export */   useUIState: () => (/* binding */ e6)
/* harmony export */ });
/* harmony import */ var next_dist_build_webpack_loaders_next_flight_loader_module_proxy__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! next/dist/build/webpack/loaders/next-flight-loader/module-proxy */ "(rsc)/./node_modules/.pnpm/next@14.2.23_@opentelemetry+api@1.9.0_@playwright+test@1.49.1_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/next/dist/build/webpack/loaders/next-flight-loader/module-proxy.js");


const e0 = (0,next_dist_build_webpack_loaders_next_flight_loader_module_proxy__WEBPACK_IMPORTED_MODULE_0__.createProxy)(String.raw`/Users/samuelselvanathan/Documents/onesies/generative-ui/node_modules/.pnpm/ai@3.4.33_openai@4.79.1_ws@8.18.0_zod@3.24.1__react@18.3.1_sswr@2.1.0_svelte@5.19.0__svelte@5_pdcg7nlabbjux4kj5rjyhlky2i/node_modules/ai/rsc/dist/rsc-shared.mjs#InternalAIProvider`);

const e1 = (0,next_dist_build_webpack_loaders_next_flight_loader_module_proxy__WEBPACK_IMPORTED_MODULE_0__.createProxy)(String.raw`/Users/samuelselvanathan/Documents/onesies/generative-ui/node_modules/.pnpm/ai@3.4.33_openai@4.79.1_ws@8.18.0_zod@3.24.1__react@18.3.1_sswr@2.1.0_svelte@5.19.0__svelte@5_pdcg7nlabbjux4kj5rjyhlky2i/node_modules/ai/rsc/dist/rsc-shared.mjs#readStreamableValue`);

const e2 = (0,next_dist_build_webpack_loaders_next_flight_loader_module_proxy__WEBPACK_IMPORTED_MODULE_0__.createProxy)(String.raw`/Users/samuelselvanathan/Documents/onesies/generative-ui/node_modules/.pnpm/ai@3.4.33_openai@4.79.1_ws@8.18.0_zod@3.24.1__react@18.3.1_sswr@2.1.0_svelte@5.19.0__svelte@5_pdcg7nlabbjux4kj5rjyhlky2i/node_modules/ai/rsc/dist/rsc-shared.mjs#useAIState`);

const e3 = (0,next_dist_build_webpack_loaders_next_flight_loader_module_proxy__WEBPACK_IMPORTED_MODULE_0__.createProxy)(String.raw`/Users/samuelselvanathan/Documents/onesies/generative-ui/node_modules/.pnpm/ai@3.4.33_openai@4.79.1_ws@8.18.0_zod@3.24.1__react@18.3.1_sswr@2.1.0_svelte@5.19.0__svelte@5_pdcg7nlabbjux4kj5rjyhlky2i/node_modules/ai/rsc/dist/rsc-shared.mjs#useActions`);

const e4 = (0,next_dist_build_webpack_loaders_next_flight_loader_module_proxy__WEBPACK_IMPORTED_MODULE_0__.createProxy)(String.raw`/Users/samuelselvanathan/Documents/onesies/generative-ui/node_modules/.pnpm/ai@3.4.33_openai@4.79.1_ws@8.18.0_zod@3.24.1__react@18.3.1_sswr@2.1.0_svelte@5.19.0__svelte@5_pdcg7nlabbjux4kj5rjyhlky2i/node_modules/ai/rsc/dist/rsc-shared.mjs#useStreamableValue`);

const e5 = (0,next_dist_build_webpack_loaders_next_flight_loader_module_proxy__WEBPACK_IMPORTED_MODULE_0__.createProxy)(String.raw`/Users/samuelselvanathan/Documents/onesies/generative-ui/node_modules/.pnpm/ai@3.4.33_openai@4.79.1_ws@8.18.0_zod@3.24.1__react@18.3.1_sswr@2.1.0_svelte@5.19.0__svelte@5_pdcg7nlabbjux4kj5rjyhlky2i/node_modules/ai/rsc/dist/rsc-shared.mjs#useSyncUIState`);

const e6 = (0,next_dist_build_webpack_loaders_next_flight_loader_module_proxy__WEBPACK_IMPORTED_MODULE_0__.createProxy)(String.raw`/Users/samuelselvanathan/Documents/onesies/generative-ui/node_modules/.pnpm/ai@3.4.33_openai@4.79.1_ws@8.18.0_zod@3.24.1__react@18.3.1_sswr@2.1.0_svelte@5.19.0__svelte@5_pdcg7nlabbjux4kj5rjyhlky2i/node_modules/ai/rsc/dist/rsc-shared.mjs#useUIState`);


/***/ })

};
;